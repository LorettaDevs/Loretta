// <auto-generated />

#pragma warning disable CS1591
#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Loretta.CodeAnalysis.Syntax.InternalSyntax;
using Loretta.Utilities;

namespace Loretta.CodeAnalysis.Lua.Syntax.InternalSyntax
{


    internal sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {
        internal readonly GreenNode? tokens;

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens)
          : base(kind)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Tokens => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.tokens);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.tokens : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.SkippedTokensTriviaSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);

        internal SkippedTokensTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var tokens = (GreenNode?)reader.ReadValue();
            if (tokens != null)
            {
                AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.tokens);
        }

        static SkippedTokensTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SkippedTokensTriviaSyntax), r => new SkippedTokensTriviaSyntax(r));
        }
    }

    /// <summary>Represents a block of code.</summary>
    internal sealed partial class StatementListSyntax : LuaSyntaxNode
    {
        internal readonly GreenNode? statements;

        internal StatementListSyntax(SyntaxKind kind, GreenNode? statements, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal StatementListSyntax(SyntaxKind kind, GreenNode? statements)
          : base(kind)
        {
            this.SlotCount = 1;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        /// <summary>The list of statements contained within this block.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.statements : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.StatementListSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitStatementList(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitStatementList(this);

        public StatementListSyntax Update(Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
            if (statements != this.Statements)
            {
                var newNode = SyntaxFactory.StatementList(statements);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new StatementListSyntax(this.Kind, this.statements, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new StatementListSyntax(this.Kind, this.statements, GetDiagnostics(), annotations);

        internal StatementListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var statements = (GreenNode?)reader.ReadValue();
            if (statements != null)
            {
                AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.statements);
        }

        static StatementListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(StatementListSyntax), r => new StatementListSyntax(r));
        }
    }

    /// <summary>The base type for parameter nodes.</summary>
    internal abstract partial class ParameterSyntax : LuaSyntaxNode
    {
        internal ParameterSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal ParameterSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected ParameterSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Represents a named function parameter.</summary>
    internal sealed partial class NamedParameterSyntax : ParameterSyntax
    {
        internal readonly SyntaxToken identifier;
        internal readonly TypeBindingSyntax? typeBinding;

        internal NamedParameterSyntax(SyntaxKind kind, SyntaxToken identifier, TypeBindingSyntax? typeBinding, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        internal NamedParameterSyntax(SyntaxKind kind, SyntaxToken identifier, TypeBindingSyntax? typeBinding)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        /// <summary>The name of the parameter.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>
        /// The
        /// <see cref="TypeBindingSyntax" />
        /// containing the (optional) type.
        /// </summary>
        public TypeBindingSyntax? TypeBinding => this.typeBinding;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.typeBinding,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.NamedParameterSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitNamedParameter(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitNamedParameter(this);

        public NamedParameterSyntax Update(SyntaxToken identifier, TypeBindingSyntax typeBinding)
        {
            if (identifier != this.Identifier || typeBinding != this.TypeBinding)
            {
                var newNode = SyntaxFactory.NamedParameter(identifier, typeBinding);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NamedParameterSyntax(this.Kind, this.identifier, this.typeBinding, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NamedParameterSyntax(this.Kind, this.identifier, this.typeBinding, GetDiagnostics(), annotations);

        internal NamedParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeBinding = (TypeBindingSyntax?)reader.ReadValue();
            if (typeBinding != null)
            {
                AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeBinding);
        }

        static NamedParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NamedParameterSyntax), r => new NamedParameterSyntax(r));
        }
    }

    /// <summary>Represents a vararg function parameter.</summary>
    internal sealed partial class VarArgParameterSyntax : ParameterSyntax
    {
        internal readonly SyntaxToken varArgToken;
        internal readonly TypeBindingSyntax? typeBinding;

        internal VarArgParameterSyntax(SyntaxKind kind, SyntaxToken varArgToken, TypeBindingSyntax? typeBinding, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(varArgToken);
            this.varArgToken = varArgToken;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        internal VarArgParameterSyntax(SyntaxKind kind, SyntaxToken varArgToken, TypeBindingSyntax? typeBinding)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(varArgToken);
            this.varArgToken = varArgToken;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        /// <summary>The vararg token.</summary>
        public SyntaxToken VarArgToken => this.varArgToken;
        /// <summary>
        /// The
        /// <see cref="TypeBindingSyntax" />
        /// containing the (optional) type.
        /// </summary>
        public TypeBindingSyntax? TypeBinding => this.typeBinding;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.varArgToken,
                1 => this.typeBinding,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.VarArgParameterSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitVarArgParameter(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitVarArgParameter(this);

        public VarArgParameterSyntax Update(SyntaxToken varArgToken, TypeBindingSyntax typeBinding)
        {
            if (varArgToken != this.VarArgToken || typeBinding != this.TypeBinding)
            {
                var newNode = SyntaxFactory.VarArgParameter(varArgToken, typeBinding);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new VarArgParameterSyntax(this.Kind, this.varArgToken, this.typeBinding, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new VarArgParameterSyntax(this.Kind, this.varArgToken, this.typeBinding, GetDiagnostics(), annotations);

        internal VarArgParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var varArgToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(varArgToken);
            this.varArgToken = varArgToken;
            var typeBinding = (TypeBindingSyntax?)reader.ReadValue();
            if (typeBinding != null)
            {
                AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.varArgToken);
            writer.WriteValue(this.typeBinding);
        }

        static VarArgParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(VarArgParameterSyntax), r => new VarArgParameterSyntax(r));
        }
    }

    /// <summary>Represents a function declaration's parameter list.</summary>
    internal sealed partial class ParameterListSyntax : LuaSyntaxNode
    {
        internal readonly SyntaxToken openParenthesisToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken closeParenthesisToken;

        internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenthesisToken, GreenNode? parameters, SyntaxToken closeParenthesisToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenthesisToken, GreenNode? parameters, SyntaxToken closeParenthesisToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        /// <summary>The parameter list opening parenthesis.</summary>
        public SyntaxToken OpenParenthesisToken => this.openParenthesisToken;
        /// <summary>The parameter list opening parenthesis.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.parameters));
        /// <summary>The close parenthesis token.</summary>
        public SyntaxToken CloseParenthesisToken => this.closeParenthesisToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenthesisToken,
                1 => this.parameters,
                2 => this.closeParenthesisToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ParameterListSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitParameterList(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitParameterList(this);

        public ParameterListSyntax Update(SyntaxToken openParenthesisToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken != this.OpenParenthesisToken || parameters != this.Parameters || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.ParameterList(openParenthesisToken, parameters, closeParenthesisToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParameterListSyntax(this.Kind, this.openParenthesisToken, this.parameters, this.closeParenthesisToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParameterListSyntax(this.Kind, this.openParenthesisToken, this.parameters, this.closeParenthesisToken, GetDiagnostics(), annotations);

        internal ParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var closeParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenthesisToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeParenthesisToken);
        }

        static ParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParameterListSyntax), r => new ParameterListSyntax(r));
        }
    }

    /// <summary>The base class for table fields.</summary>
    internal abstract partial class TableFieldSyntax : LuaSyntaxNode
    {
        internal TableFieldSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal TableFieldSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected TableFieldSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Represents a table field whose key is an identifier.</summary>
    internal sealed partial class IdentifierKeyedTableFieldSyntax : TableFieldSyntax
    {
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax value;

        internal IdentifierKeyedTableFieldSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax value, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal IdentifierKeyedTableFieldSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax value)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        /// <summary>The table field's key.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>The equals token.</summary>
        public SyntaxToken EqualsToken => this.equalsToken;
        /// <summary>The table field's value.</summary>
        public ExpressionSyntax Value => this.value;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.equalsToken,
                2 => this.value,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.IdentifierKeyedTableFieldSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIdentifierKeyedTableField(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitIdentifierKeyedTableField(this);

        public IdentifierKeyedTableFieldSyntax Update(SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax value)
        {
            if (identifier != this.Identifier || equalsToken != this.EqualsToken || value != this.Value)
            {
                var newNode = SyntaxFactory.IdentifierKeyedTableField(identifier, equalsToken, value);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IdentifierKeyedTableFieldSyntax(this.Kind, this.identifier, this.equalsToken, this.value, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IdentifierKeyedTableFieldSyntax(this.Kind, this.identifier, this.equalsToken, this.value, GetDiagnostics(), annotations);

        internal IdentifierKeyedTableFieldSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var value = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.value);
        }

        static IdentifierKeyedTableFieldSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IdentifierKeyedTableFieldSyntax), r => new IdentifierKeyedTableFieldSyntax(r));
        }
    }

    /// <summary>Represents a table field whose key is an expression.</summary>
    internal sealed partial class ExpressionKeyedTableFieldSyntax : TableFieldSyntax
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly ExpressionSyntax key;
        internal readonly SyntaxToken closeBracketToken;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax value;

        internal ExpressionKeyedTableFieldSyntax(SyntaxKind kind, SyntaxToken openBracketToken, ExpressionSyntax key, SyntaxToken closeBracketToken, SyntaxToken equalsToken, ExpressionSyntax value, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(key);
            this.key = key;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal ExpressionKeyedTableFieldSyntax(SyntaxKind kind, SyntaxToken openBracketToken, ExpressionSyntax key, SyntaxToken closeBracketToken, SyntaxToken equalsToken, ExpressionSyntax value)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(key);
            this.key = key;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        /// <summary>The opening bracket token.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        /// <summary>The table field's key.</summary>
        public ExpressionSyntax Key => this.key;
        /// <summary>The closing bracket token.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;
        /// <summary>The equals token.</summary>
        public SyntaxToken EqualsToken => this.equalsToken;
        /// <summary>The field's value.</summary>
        public ExpressionSyntax Value => this.value;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.key,
                2 => this.closeBracketToken,
                3 => this.equalsToken,
                4 => this.value,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ExpressionKeyedTableFieldSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitExpressionKeyedTableField(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitExpressionKeyedTableField(this);

        public ExpressionKeyedTableFieldSyntax Update(SyntaxToken openBracketToken, ExpressionSyntax key, SyntaxToken closeBracketToken, SyntaxToken equalsToken, ExpressionSyntax value)
        {
            if (openBracketToken != this.OpenBracketToken || key != this.Key || closeBracketToken != this.CloseBracketToken || equalsToken != this.EqualsToken || value != this.Value)
            {
                var newNode = SyntaxFactory.ExpressionKeyedTableField(openBracketToken, key, closeBracketToken, equalsToken, value);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExpressionKeyedTableFieldSyntax(this.Kind, this.openBracketToken, this.key, this.closeBracketToken, this.equalsToken, this.value, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExpressionKeyedTableFieldSyntax(this.Kind, this.openBracketToken, this.key, this.closeBracketToken, this.equalsToken, this.value, GetDiagnostics(), annotations);

        internal ExpressionKeyedTableFieldSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var key = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(key);
            this.key = key;
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var value = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.key);
            writer.WriteValue(this.closeBracketToken);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.value);
        }

        static ExpressionKeyedTableFieldSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExpressionKeyedTableFieldSyntax), r => new ExpressionKeyedTableFieldSyntax(r));
        }
    }

    /// <summary>Represents a table field without a key.</summary>
    internal sealed partial class UnkeyedTableFieldSyntax : TableFieldSyntax
    {
        internal readonly ExpressionSyntax value;

        internal UnkeyedTableFieldSyntax(SyntaxKind kind, ExpressionSyntax value, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal UnkeyedTableFieldSyntax(SyntaxKind kind, ExpressionSyntax value)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        /// <summary>The table field's value.</summary>
        public ExpressionSyntax Value => this.value;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.value : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.UnkeyedTableFieldSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitUnkeyedTableField(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitUnkeyedTableField(this);

        public UnkeyedTableFieldSyntax Update(ExpressionSyntax value)
        {
            if (value != this.Value)
            {
                var newNode = SyntaxFactory.UnkeyedTableField(value);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UnkeyedTableFieldSyntax(this.Kind, this.value, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UnkeyedTableFieldSyntax(this.Kind, this.value, GetDiagnostics(), annotations);

        internal UnkeyedTableFieldSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var value = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.value);
        }

        static UnkeyedTableFieldSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UnkeyedTableFieldSyntax), r => new UnkeyedTableFieldSyntax(r));
        }
    }

    /// <summary>The base class for function name nodes.</summary>
    internal abstract partial class FunctionNameSyntax : LuaSyntaxNode
    {
        internal FunctionNameSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal FunctionNameSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected FunctionNameSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>The member name.</summary>
        public abstract SyntaxToken Name { get; }
    }

    /// <summary>Represents a function name which is only an identifier.</summary>
    internal sealed partial class SimpleFunctionNameSyntax : FunctionNameSyntax
    {
        internal readonly SyntaxToken name;

        internal SimpleFunctionNameSyntax(SyntaxKind kind, SyntaxToken name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal SimpleFunctionNameSyntax(SyntaxKind kind, SyntaxToken name)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        /// <summary>The function name.</summary>
        public override SyntaxToken Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.name : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.SimpleFunctionNameSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitSimpleFunctionName(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitSimpleFunctionName(this);

        public SimpleFunctionNameSyntax Update(SyntaxToken name)
        {
            if (name != this.Name)
            {
                var newNode = SyntaxFactory.SimpleFunctionName(name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SimpleFunctionNameSyntax(this.Kind, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SimpleFunctionNameSyntax(this.Kind, this.name, GetDiagnostics(), annotations);

        internal SimpleFunctionNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var name = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
        }

        static SimpleFunctionNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SimpleFunctionNameSyntax), r => new SimpleFunctionNameSyntax(r));
        }
    }

    /// <summary>Represents a function name which is a member.</summary>
    internal sealed partial class MemberFunctionNameSyntax : FunctionNameSyntax
    {
        internal readonly FunctionNameSyntax baseName;
        internal readonly SyntaxToken dotToken;
        internal readonly SyntaxToken name;

        internal MemberFunctionNameSyntax(SyntaxKind kind, FunctionNameSyntax baseName, SyntaxToken dotToken, SyntaxToken name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal MemberFunctionNameSyntax(SyntaxKind kind, FunctionNameSyntax baseName, SyntaxToken dotToken, SyntaxToken name)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        /// <summary>The base function name.</summary>
        public FunctionNameSyntax BaseName => this.baseName;
        /// <summary>The dot token.</summary>
        public SyntaxToken DotToken => this.dotToken;
        /// <summary>The member name.</summary>
        public override SyntaxToken Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.baseName,
                1 => this.dotToken,
                2 => this.name,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.MemberFunctionNameSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitMemberFunctionName(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitMemberFunctionName(this);

        public MemberFunctionNameSyntax Update(FunctionNameSyntax baseName, SyntaxToken dotToken, SyntaxToken name)
        {
            if (baseName != this.BaseName || dotToken != this.DotToken || name != this.Name)
            {
                var newNode = SyntaxFactory.MemberFunctionName(baseName, dotToken, name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MemberFunctionNameSyntax(this.Kind, this.baseName, this.dotToken, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MemberFunctionNameSyntax(this.Kind, this.baseName, this.dotToken, this.name, GetDiagnostics(), annotations);

        internal MemberFunctionNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var baseName = (FunctionNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            var dotToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            var name = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.baseName);
            writer.WriteValue(this.dotToken);
            writer.WriteValue(this.name);
        }

        static MemberFunctionNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(MemberFunctionNameSyntax), r => new MemberFunctionNameSyntax(r));
        }
    }

    /// <summary>Represents a method-style function name syntax.</summary>
    internal sealed partial class MethodFunctionNameSyntax : FunctionNameSyntax
    {
        internal readonly FunctionNameSyntax baseName;
        internal readonly SyntaxToken colonToken;
        internal readonly SyntaxToken name;

        internal MethodFunctionNameSyntax(SyntaxKind kind, FunctionNameSyntax baseName, SyntaxToken colonToken, SyntaxToken name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal MethodFunctionNameSyntax(SyntaxKind kind, FunctionNameSyntax baseName, SyntaxToken colonToken, SyntaxToken name)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        /// <summary>The base name for this method.</summary>
        public FunctionNameSyntax BaseName => this.baseName;
        /// <summary>The colon token.</summary>
        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>The method name.</summary>
        public override SyntaxToken Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.baseName,
                1 => this.colonToken,
                2 => this.name,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.MethodFunctionNameSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitMethodFunctionName(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitMethodFunctionName(this);

        public MethodFunctionNameSyntax Update(FunctionNameSyntax baseName, SyntaxToken colonToken, SyntaxToken name)
        {
            if (baseName != this.BaseName || colonToken != this.ColonToken || name != this.Name)
            {
                var newNode = SyntaxFactory.MethodFunctionName(baseName, colonToken, name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MethodFunctionNameSyntax(this.Kind, this.baseName, this.colonToken, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MethodFunctionNameSyntax(this.Kind, this.baseName, this.colonToken, this.name, GetDiagnostics(), annotations);

        internal MethodFunctionNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var baseName = (FunctionNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(baseName);
            this.baseName = baseName;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var name = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.baseName);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.name);
        }

        static MethodFunctionNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(MethodFunctionNameSyntax), r => new MethodFunctionNameSyntax(r));
        }
    }

    /// <summary>The base class for function arguments.</summary>
    internal abstract partial class FunctionArgumentSyntax : LuaSyntaxNode
    {
        internal FunctionArgumentSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal FunctionArgumentSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected FunctionArgumentSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Represents a string being passed as a function call's argument.</summary>
    internal sealed partial class StringFunctionArgumentSyntax : FunctionArgumentSyntax
    {
        internal readonly LiteralExpressionSyntax expression;

        internal StringFunctionArgumentSyntax(SyntaxKind kind, LiteralExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal StringFunctionArgumentSyntax(SyntaxKind kind, LiteralExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        /// <summary>The string literal being passed as an argument.</summary>
        public LiteralExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.expression : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.StringFunctionArgumentSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitStringFunctionArgument(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitStringFunctionArgument(this);

        public StringFunctionArgumentSyntax Update(LiteralExpressionSyntax expression)
        {
            if (expression != this.Expression)
            {
                var newNode = SyntaxFactory.StringFunctionArgument(expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new StringFunctionArgumentSyntax(this.Kind, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new StringFunctionArgumentSyntax(this.Kind, this.expression, GetDiagnostics(), annotations);

        internal StringFunctionArgumentSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var expression = (LiteralExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
        }

        static StringFunctionArgumentSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(StringFunctionArgumentSyntax), r => new StringFunctionArgumentSyntax(r));
        }
    }

    /// <summary>Represents a table being passed as a function call's arguments.</summary>
    internal sealed partial class TableConstructorFunctionArgumentSyntax : FunctionArgumentSyntax
    {
        internal readonly TableConstructorExpressionSyntax tableConstructor;

        internal TableConstructorFunctionArgumentSyntax(SyntaxKind kind, TableConstructorExpressionSyntax tableConstructor, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(tableConstructor);
            this.tableConstructor = tableConstructor;
        }

        internal TableConstructorFunctionArgumentSyntax(SyntaxKind kind, TableConstructorExpressionSyntax tableConstructor)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(tableConstructor);
            this.tableConstructor = tableConstructor;
        }

        /// <summary>The actual table constructor.</summary>
        public TableConstructorExpressionSyntax TableConstructor => this.tableConstructor;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.tableConstructor : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TableConstructorFunctionArgumentSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTableConstructorFunctionArgument(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTableConstructorFunctionArgument(this);

        public TableConstructorFunctionArgumentSyntax Update(TableConstructorExpressionSyntax tableConstructor)
        {
            if (tableConstructor != this.TableConstructor)
            {
                var newNode = SyntaxFactory.TableConstructorFunctionArgument(tableConstructor);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TableConstructorFunctionArgumentSyntax(this.Kind, this.tableConstructor, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TableConstructorFunctionArgumentSyntax(this.Kind, this.tableConstructor, GetDiagnostics(), annotations);

        internal TableConstructorFunctionArgumentSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var tableConstructor = (TableConstructorExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(tableConstructor);
            this.tableConstructor = tableConstructor;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.tableConstructor);
        }

        static TableConstructorFunctionArgumentSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TableConstructorFunctionArgumentSyntax), r => new TableConstructorFunctionArgumentSyntax(r));
        }
    }

    /// <summary>Represents a list of expressions being passed as a function's arguments.</summary>
    internal sealed partial class ExpressionListFunctionArgumentSyntax : FunctionArgumentSyntax
    {
        internal readonly SyntaxToken openParenthesisToken;
        internal readonly GreenNode? expressions;
        internal readonly SyntaxToken closeParenthesisToken;

        internal ExpressionListFunctionArgumentSyntax(SyntaxKind kind, SyntaxToken openParenthesisToken, GreenNode? expressions, SyntaxToken closeParenthesisToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal ExpressionListFunctionArgumentSyntax(SyntaxKind kind, SyntaxToken openParenthesisToken, GreenNode? expressions, SyntaxToken closeParenthesisToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        /// <summary>The argument list's opening parenthesis token.</summary>
        public SyntaxToken OpenParenthesisToken => this.openParenthesisToken;
        /// <summary>The list of expressions.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Expressions => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.expressions));
        /// <summary>The argument list's closing parenthesis token.</summary>
        public SyntaxToken CloseParenthesisToken => this.closeParenthesisToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenthesisToken,
                1 => this.expressions,
                2 => this.closeParenthesisToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ExpressionListFunctionArgumentSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitExpressionListFunctionArgument(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitExpressionListFunctionArgument(this);

        public ExpressionListFunctionArgumentSyntax Update(SyntaxToken openParenthesisToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken != this.OpenParenthesisToken || expressions != this.Expressions || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.ExpressionListFunctionArgument(openParenthesisToken, expressions, closeParenthesisToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExpressionListFunctionArgumentSyntax(this.Kind, this.openParenthesisToken, this.expressions, this.closeParenthesisToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExpressionListFunctionArgumentSyntax(this.Kind, this.openParenthesisToken, this.expressions, this.closeParenthesisToken, GetDiagnostics(), annotations);

        internal ExpressionListFunctionArgumentSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            var expressions = (GreenNode?)reader.ReadValue();
            if (expressions != null)
            {
                AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            var closeParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenthesisToken);
            writer.WriteValue(this.expressions);
            writer.WriteValue(this.closeParenthesisToken);
        }

        static ExpressionListFunctionArgumentSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExpressionListFunctionArgumentSyntax), r => new ExpressionListFunctionArgumentSyntax(r));
        }
    }

    /// <summary>
    /// The base class interpolated string parts, either an
    /// <see cref="InterpolatedStringTextSyntax" />
    /// with
    /// plain text or an
    /// <see cref="InterpolationSyntax" />
    /// with an expression to be formatted.
    /// </summary>
    internal abstract partial class InterpolatedStringContentSyntax : LuaSyntaxNode
    {
        internal InterpolatedStringContentSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal InterpolatedStringContentSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected InterpolatedStringContentSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>
    /// The part of an interpolated string with plain text.
    /// </summary>
    internal sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
    {
        internal readonly SyntaxToken textToken;

        internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(textToken);
            this.textToken = textToken;
        }

        internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(textToken);
            this.textToken = textToken;
        }

        /// <summary>The text contents of a part of the interpolated string.</summary>
        public SyntaxToken TextToken => this.textToken;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.textToken : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.InterpolatedStringTextSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitInterpolatedStringText(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolatedStringText(this);

        public InterpolatedStringTextSyntax Update(SyntaxToken textToken)
        {
            if (textToken != this.TextToken)
            {
                var newNode = SyntaxFactory.InterpolatedStringText(textToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolatedStringTextSyntax(this.Kind, this.textToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolatedStringTextSyntax(this.Kind, this.textToken, GetDiagnostics(), annotations);

        internal InterpolatedStringTextSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var textToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(textToken);
            this.textToken = textToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.textToken);
        }

        static InterpolatedStringTextSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolatedStringTextSyntax), r => new InterpolatedStringTextSyntax(r));
        }
    }

    /// <summary>
    /// An expression to be interpolated into the string.
    /// </summary>
    internal sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeBraceToken;

        internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        /// <summary>
        /// This could be a single <c>{</c> or multiple in a row.
        /// </summary>
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public ExpressionSyntax Expression => this.expression;
        /// <summary>
        /// This could be a single <c>}</c> or multiple in a row.
        /// </summary>
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.expression,
                2 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.InterpolationSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitInterpolation(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolation(this);

        public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || expression != this.Expression || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.Interpolation(openBraceToken, expression, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.closeBraceToken, GetDiagnostics(), annotations);

        internal InterpolationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeBraceToken);
        }

        static InterpolationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolationSyntax), r => new InterpolationSyntax(r));
        }
    }

    /// <summary>The base class for expressions.</summary>
    internal abstract partial class ExpressionSyntax : LuaSyntaxNode
    {
        internal ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal ExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected ExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Represents an anonymous function expression.</summary>
    internal sealed partial class AnonymousFunctionExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken functionKeyword;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly ParameterListSyntax parameters;
        internal readonly TypeBindingSyntax? typeBinding;
        internal readonly StatementListSyntax body;
        internal readonly SyntaxToken endKeyword;

        internal AnonymousFunctionExpressionSyntax(SyntaxKind kind, SyntaxToken functionKeyword, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(functionKeyword);
            this.functionKeyword = functionKeyword;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
        }

        internal AnonymousFunctionExpressionSyntax(SyntaxKind kind, SyntaxToken functionKeyword, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword)
          : base(kind)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(functionKeyword);
            this.functionKeyword = functionKeyword;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
        }

        /// <summary>The 'function' keyword.</summary>
        public SyntaxToken FunctionKeyword => this.functionKeyword;
        /// <summary>Gets the type parameter list for this function (if any).</summary>
        public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        /// <summary>The list of parameters.</summary>
        public ParameterListSyntax Parameters => this.parameters;
        /// <summary>The function's (optional) return type.</summary>
        public TypeBindingSyntax? TypeBinding => this.typeBinding;
        /// <summary>The function's body.</summary>
        public StatementListSyntax Body => this.body;
        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => this.endKeyword;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.functionKeyword,
                1 => this.typeParameterList,
                2 => this.parameters,
                3 => this.typeBinding,
                4 => this.body,
                5 => this.endKeyword,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.AnonymousFunctionExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitAnonymousFunctionExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitAnonymousFunctionExpression(this);

        public AnonymousFunctionExpressionSyntax Update(SyntaxToken functionKeyword, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax typeBinding, StatementListSyntax body, SyntaxToken endKeyword)
        {
            if (functionKeyword != this.FunctionKeyword || typeParameterList != this.TypeParameterList || parameters != this.Parameters || typeBinding != this.TypeBinding || body != this.Body || endKeyword != this.EndKeyword)
            {
                var newNode = SyntaxFactory.AnonymousFunctionExpression(functionKeyword, typeParameterList, parameters, typeBinding, body, endKeyword);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AnonymousFunctionExpressionSyntax(this.Kind, this.functionKeyword, this.typeParameterList, this.parameters, this.typeBinding, this.body, this.endKeyword, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AnonymousFunctionExpressionSyntax(this.Kind, this.functionKeyword, this.typeParameterList, this.parameters, this.typeBinding, this.body, this.endKeyword, GetDiagnostics(), annotations);

        internal AnonymousFunctionExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var functionKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(functionKeyword);
            this.functionKeyword = functionKeyword;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var parameters = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
            var typeBinding = (TypeBindingSyntax?)reader.ReadValue();
            if (typeBinding != null)
            {
                AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
            var body = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
            var endKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.functionKeyword);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.typeBinding);
            writer.WriteValue(this.body);
            writer.WriteValue(this.endKeyword);
        }

        static AnonymousFunctionExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AnonymousFunctionExpressionSyntax), r => new AnonymousFunctionExpressionSyntax(r));
        }
    }

    /// <summary>Represents a table constructor expression.</summary>
    internal sealed partial class TableConstructorExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? fields;
        internal readonly SyntaxToken closeBraceToken;

        internal TableConstructorExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? fields, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (fields != null)
            {
                this.AdjustFlagsAndWidth(fields);
                this.fields = fields;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal TableConstructorExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? fields, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (fields != null)
            {
                this.AdjustFlagsAndWidth(fields);
                this.fields = fields;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        /// <summary>The opening brace token.</summary>
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        /// <summary>The list of fields.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TableFieldSyntax> Fields => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TableFieldSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.fields));
        /// <summary>The closing brace token.</summary>
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.fields,
                2 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TableConstructorExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTableConstructorExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTableConstructorExpression(this);

        public TableConstructorExpressionSyntax Update(SyntaxToken openBraceToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TableFieldSyntax> fields, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || fields != this.Fields || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.TableConstructorExpression(openBraceToken, fields, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TableConstructorExpressionSyntax(this.Kind, this.openBraceToken, this.fields, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TableConstructorExpressionSyntax(this.Kind, this.openBraceToken, this.fields, this.closeBraceToken, GetDiagnostics(), annotations);

        internal TableConstructorExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var fields = (GreenNode?)reader.ReadValue();
            if (fields != null)
            {
                AdjustFlagsAndWidth(fields);
                this.fields = fields;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.fields);
            writer.WriteValue(this.closeBraceToken);
        }

        static TableConstructorExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TableConstructorExpressionSyntax), r => new TableConstructorExpressionSyntax(r));
        }
    }

    /// <summary>Represents a literal expression.</summary>
    internal sealed partial class LiteralExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        /// <summary>The literal token.</summary>
        public SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.LiteralExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLiteralExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitLiteralExpression(this);

        public LiteralExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralExpression(this.Kind, token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LiteralExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LiteralExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal LiteralExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static LiteralExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LiteralExpressionSyntax), r => new LiteralExpressionSyntax(r));
        }
    }

    internal sealed partial class InterpolatedStringExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken stringStartToken;
        internal readonly GreenNode? contents;
        internal readonly SyntaxToken stringEndToken;

        internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode? contents, SyntaxToken stringEndToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stringStartToken);
            this.stringStartToken = stringStartToken;
            if (contents != null)
            {
                this.AdjustFlagsAndWidth(contents);
                this.contents = contents;
            }
            this.AdjustFlagsAndWidth(stringEndToken);
            this.stringEndToken = stringEndToken;
        }

        internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode? contents, SyntaxToken stringEndToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stringStartToken);
            this.stringStartToken = stringStartToken;
            if (contents != null)
            {
                this.AdjustFlagsAndWidth(contents);
                this.contents = contents;
            }
            this.AdjustFlagsAndWidth(stringEndToken);
            this.stringEndToken = stringEndToken;
        }

        /// <summary>
        /// The first part of an interpolated string:
        /// <c>`</c>
        /// </summary>
        public SyntaxToken StringStartToken => this.stringStartToken;
        /// <summary>
        /// List of parts of the interpolated string, each one is either a literal part or an interpolation.
        /// </summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> Contents => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax>(this.contents);
        /// <summary>
        /// The closing <c>`</c> of the interpolated string.
        /// </summary>
        public SyntaxToken StringEndToken => this.stringEndToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.stringStartToken,
                1 => this.contents,
                2 => this.stringEndToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.InterpolatedStringExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitInterpolatedStringExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolatedStringExpression(this);

        public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
        {
            if (stringStartToken != this.StringStartToken || contents != this.Contents || stringEndToken != this.StringEndToken)
            {
                var newNode = SyntaxFactory.InterpolatedStringExpression(stringStartToken, contents, stringEndToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, GetDiagnostics(), annotations);

        internal InterpolatedStringExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var stringStartToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(stringStartToken);
            this.stringStartToken = stringStartToken;
            var contents = (GreenNode?)reader.ReadValue();
            if (contents != null)
            {
                AdjustFlagsAndWidth(contents);
                this.contents = contents;
            }
            var stringEndToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(stringEndToken);
            this.stringEndToken = stringEndToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.stringStartToken);
            writer.WriteValue(this.contents);
            writer.WriteValue(this.stringEndToken);
        }

        static InterpolatedStringExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolatedStringExpressionSyntax), r => new InterpolatedStringExpressionSyntax(r));
        }
    }

    /// <summary>Represents a vararg expression.</summary>
    internal sealed partial class VarArgExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken varArgToken;

        internal VarArgExpressionSyntax(SyntaxKind kind, SyntaxToken varArgToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(varArgToken);
            this.varArgToken = varArgToken;
        }

        internal VarArgExpressionSyntax(SyntaxKind kind, SyntaxToken varArgToken)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(varArgToken);
            this.varArgToken = varArgToken;
        }

        /// <summary>The vararg token.</summary>
        public SyntaxToken VarArgToken => this.varArgToken;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.varArgToken : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.VarArgExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitVarArgExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitVarArgExpression(this);

        public VarArgExpressionSyntax Update(SyntaxToken varArgToken)
        {
            if (varArgToken != this.VarArgToken)
            {
                var newNode = SyntaxFactory.VarArgExpression(varArgToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new VarArgExpressionSyntax(this.Kind, this.varArgToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new VarArgExpressionSyntax(this.Kind, this.varArgToken, GetDiagnostics(), annotations);

        internal VarArgExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var varArgToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(varArgToken);
            this.varArgToken = varArgToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.varArgToken);
        }

        static VarArgExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(VarArgExpressionSyntax), r => new VarArgExpressionSyntax(r));
        }
    }

    /// <summary>The base class for variable expressions (values that can be assigned to).</summary>
    internal abstract partial class VariableExpressionSyntax : PrefixExpressionSyntax
    {
        internal VariableExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal VariableExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected VariableExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>A name expression.</summary>
    internal sealed partial class IdentifierNameSyntax : VariableExpressionSyntax
    {
        internal readonly SyntaxToken identifier;

        internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        /// <summary>The identifier.</summary>
        public SyntaxToken Identifier => this.identifier;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.identifier : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.IdentifierNameSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIdentifierName(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitIdentifierName(this);

        public IdentifierNameSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.IdentifierName(identifier);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IdentifierNameSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IdentifierNameSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);

        internal IdentifierNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
        }

        static IdentifierNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IdentifierNameSyntax), r => new IdentifierNameSyntax(r));
        }
    }

    internal sealed partial class MemberAccessExpressionSyntax : VariableExpressionSyntax
    {
        internal readonly PrefixExpressionSyntax expression;
        internal readonly SyntaxToken dotSeparator;
        internal readonly SyntaxToken memberName;

        internal MemberAccessExpressionSyntax(SyntaxKind kind, PrefixExpressionSyntax expression, SyntaxToken dotSeparator, SyntaxToken memberName, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(dotSeparator);
            this.dotSeparator = dotSeparator;
            this.AdjustFlagsAndWidth(memberName);
            this.memberName = memberName;
        }

        internal MemberAccessExpressionSyntax(SyntaxKind kind, PrefixExpressionSyntax expression, SyntaxToken dotSeparator, SyntaxToken memberName)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(dotSeparator);
            this.dotSeparator = dotSeparator;
            this.AdjustFlagsAndWidth(memberName);
            this.memberName = memberName;
        }

        /// <summary>The expression that contains the member being accessed.</summary>
        public PrefixExpressionSyntax Expression => this.expression;
        /// <summary>The dot separating the expression and the identifier.</summary>
        public SyntaxToken DotSeparator => this.dotSeparator;
        /// <summary>The identifier representing the member name.</summary>
        public SyntaxToken MemberName => this.memberName;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.dotSeparator,
                2 => this.memberName,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.MemberAccessExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitMemberAccessExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitMemberAccessExpression(this);

        public MemberAccessExpressionSyntax Update(PrefixExpressionSyntax expression, SyntaxToken dotSeparator, SyntaxToken memberName)
        {
            if (expression != this.Expression || dotSeparator != this.DotSeparator || memberName != this.MemberName)
            {
                var newNode = SyntaxFactory.MemberAccessExpression(expression, dotSeparator, memberName);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MemberAccessExpressionSyntax(this.Kind, this.expression, this.dotSeparator, this.memberName, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MemberAccessExpressionSyntax(this.Kind, this.expression, this.dotSeparator, this.memberName, GetDiagnostics(), annotations);

        internal MemberAccessExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var expression = (PrefixExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var dotSeparator = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(dotSeparator);
            this.dotSeparator = dotSeparator;
            var memberName = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(memberName);
            this.memberName = memberName;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.dotSeparator);
            writer.WriteValue(this.memberName);
        }

        static MemberAccessExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(MemberAccessExpressionSyntax), r => new MemberAccessExpressionSyntax(r));
        }
    }

    internal sealed partial class ElementAccessExpressionSyntax : VariableExpressionSyntax
    {
        internal readonly PrefixExpressionSyntax expression;
        internal readonly SyntaxToken openBracketToken;
        internal readonly ExpressionSyntax keyExpression;
        internal readonly SyntaxToken closeBracketToken;

        internal ElementAccessExpressionSyntax(SyntaxKind kind, PrefixExpressionSyntax expression, SyntaxToken openBracketToken, ExpressionSyntax keyExpression, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(keyExpression);
            this.keyExpression = keyExpression;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal ElementAccessExpressionSyntax(SyntaxKind kind, PrefixExpressionSyntax expression, SyntaxToken openBracketToken, ExpressionSyntax keyExpression, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(keyExpression);
            this.keyExpression = keyExpression;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        /// <summary>The expression that contains the member being accessed.</summary>
        public PrefixExpressionSyntax Expression => this.expression;
        /// <summary>The opening bracket token.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        /// <summary>The key expression.</summary>
        public ExpressionSyntax KeyExpression => this.keyExpression;
        /// <summary>The closing bracket token.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.openBracketToken,
                2 => this.keyExpression,
                3 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ElementAccessExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitElementAccessExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitElementAccessExpression(this);

        public ElementAccessExpressionSyntax Update(PrefixExpressionSyntax expression, SyntaxToken openBracketToken, ExpressionSyntax keyExpression, SyntaxToken closeBracketToken)
        {
            if (expression != this.Expression || openBracketToken != this.OpenBracketToken || keyExpression != this.KeyExpression || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.ElementAccessExpression(expression, openBracketToken, keyExpression, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElementAccessExpressionSyntax(this.Kind, this.expression, this.openBracketToken, this.keyExpression, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElementAccessExpressionSyntax(this.Kind, this.expression, this.openBracketToken, this.keyExpression, this.closeBracketToken, GetDiagnostics(), annotations);

        internal ElementAccessExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var expression = (PrefixExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var keyExpression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(keyExpression);
            this.keyExpression = keyExpression;
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.keyExpression);
            writer.WriteValue(this.closeBracketToken);
        }

        static ElementAccessExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElementAccessExpressionSyntax), r => new ElementAccessExpressionSyntax(r));
        }
    }

    /// <summary>Represents an unary expression.</summary>
    internal sealed partial class UnaryExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken operatorToken;
        internal readonly ExpressionSyntax operand;

        internal UnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        internal UnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        /// <summary>The operator token.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>The operand expression.</summary>
        public ExpressionSyntax Operand => this.operand;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.operatorToken,
                1 => this.operand,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.UnaryExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitUnaryExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitUnaryExpression(this);

        public UnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            if (operatorToken != this.OperatorToken || operand != this.Operand)
            {
                var newNode = SyntaxFactory.UnaryExpression(this.Kind, operatorToken, operand);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, GetDiagnostics(), annotations);

        internal UnaryExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var operand = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.operand);
        }

        static UnaryExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UnaryExpressionSyntax), r => new UnaryExpressionSyntax(r));
        }
    }

    /// <summary>Represents a binary expression.</summary>
    internal sealed partial class BinaryExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax left;
        internal readonly SyntaxToken operatorToken;
        internal readonly ExpressionSyntax right;

        internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        /// <summary>The expression on the left side of the operator.</summary>
        public ExpressionSyntax Left => this.left;
        /// <summary>The operator token.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>The expression on the right side of the operator.</summary>
        public ExpressionSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.operatorToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.BinaryExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitBinaryExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitBinaryExpression(this);

        public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.BinaryExpression(this.Kind, left, operatorToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);

        internal BinaryExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var right = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.right);
        }

        static BinaryExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BinaryExpressionSyntax), r => new BinaryExpressionSyntax(r));
        }
    }

    /// <summary>
    /// Represents an elseif clause in an if expression.
    /// </summary>
    internal sealed partial class ElseIfExpressionClauseSyntax : LuaSyntaxNode
    {
        internal readonly SyntaxToken elseIfKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken thenKeyword;
        internal readonly ExpressionSyntax value;

        internal ElseIfExpressionClauseSyntax(SyntaxKind kind, SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax value, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(elseIfKeyword);
            this.elseIfKeyword = elseIfKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal ElseIfExpressionClauseSyntax(SyntaxKind kind, SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax value)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(elseIfKeyword);
            this.elseIfKeyword = elseIfKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        /// <summary>The 'elseif' keyword.</summary>
        public SyntaxToken ElseIfKeyword => this.elseIfKeyword;
        /// <summary>The elseif's condition.</summary>
        public ExpressionSyntax Condition => this.condition;
        /// <summary>The 'then' keyword.</summary>
        public SyntaxToken ThenKeyword => this.thenKeyword;
        /// <summary>The value to be returned if the condition is true.</summary>
        public ExpressionSyntax Value => this.value;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.elseIfKeyword,
                1 => this.condition,
                2 => this.thenKeyword,
                3 => this.value,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ElseIfExpressionClauseSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitElseIfExpressionClause(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitElseIfExpressionClause(this);

        public ElseIfExpressionClauseSyntax Update(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax value)
        {
            if (elseIfKeyword != this.ElseIfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || value != this.Value)
            {
                var newNode = SyntaxFactory.ElseIfExpressionClause(elseIfKeyword, condition, thenKeyword, value);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElseIfExpressionClauseSyntax(this.Kind, this.elseIfKeyword, this.condition, this.thenKeyword, this.value, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElseIfExpressionClauseSyntax(this.Kind, this.elseIfKeyword, this.condition, this.thenKeyword, this.value, GetDiagnostics(), annotations);

        internal ElseIfExpressionClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var elseIfKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(elseIfKeyword);
            this.elseIfKeyword = elseIfKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var thenKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            var value = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.elseIfKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.thenKeyword);
            writer.WriteValue(this.value);
        }

        static ElseIfExpressionClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElseIfExpressionClauseSyntax), r => new ElseIfExpressionClauseSyntax(r));
        }
    }

    /// <summary>
    /// Represents Luau's if expression.
    /// </summary>
    internal sealed partial class IfExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken ifKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken thenKeyword;
        internal readonly ExpressionSyntax trueValue;
        internal readonly GreenNode? elseIfClauses;
        internal readonly SyntaxToken elseKeyword;
        internal readonly ExpressionSyntax falseValue;

        internal IfExpressionSyntax(SyntaxKind kind, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax trueValue, GreenNode? elseIfClauses, SyntaxToken elseKeyword, ExpressionSyntax falseValue, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            this.AdjustFlagsAndWidth(trueValue);
            this.trueValue = trueValue;
            if (elseIfClauses != null)
            {
                this.AdjustFlagsAndWidth(elseIfClauses);
                this.elseIfClauses = elseIfClauses;
            }
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(falseValue);
            this.falseValue = falseValue;
        }

        internal IfExpressionSyntax(SyntaxKind kind, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax trueValue, GreenNode? elseIfClauses, SyntaxToken elseKeyword, ExpressionSyntax falseValue)
          : base(kind)
        {
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            this.AdjustFlagsAndWidth(trueValue);
            this.trueValue = trueValue;
            if (elseIfClauses != null)
            {
                this.AdjustFlagsAndWidth(elseIfClauses);
                this.elseIfClauses = elseIfClauses;
            }
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(falseValue);
            this.falseValue = falseValue;
        }

        /// <summary>The 'if' keyword.</summary>
        public SyntaxToken IfKeyword => this.ifKeyword;
        /// <summary>The if's condition.</summary>
        public ExpressionSyntax Condition => this.condition;
        /// <summary>The 'then' keyword.</summary>
        public SyntaxToken ThenKeyword => this.thenKeyword;
        /// <summary>The value that will be returned if condition is true.</summary>
        public ExpressionSyntax TrueValue => this.trueValue;
        /// <summary>The elseif clauses.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfExpressionClauseSyntax> ElseIfClauses => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfExpressionClauseSyntax>(this.elseIfClauses);
        /// <summary>The 'else' keyword.</summary>
        public SyntaxToken ElseKeyword => this.elseKeyword;
        /// <summary>The value that will be returned if none of the previous conditions are true.</summary>
        public ExpressionSyntax FalseValue => this.falseValue;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.ifKeyword,
                1 => this.condition,
                2 => this.thenKeyword,
                3 => this.trueValue,
                4 => this.elseIfClauses,
                5 => this.elseKeyword,
                6 => this.falseValue,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.IfExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIfExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitIfExpression(this);

        public IfExpressionSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax trueValue, Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfExpressionClauseSyntax> elseIfClauses, SyntaxToken elseKeyword, ExpressionSyntax falseValue)
        {
            if (ifKeyword != this.IfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || trueValue != this.TrueValue || elseIfClauses != this.ElseIfClauses || elseKeyword != this.ElseKeyword || falseValue != this.FalseValue)
            {
                var newNode = SyntaxFactory.IfExpression(ifKeyword, condition, thenKeyword, trueValue, elseIfClauses, elseKeyword, falseValue);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IfExpressionSyntax(this.Kind, this.ifKeyword, this.condition, this.thenKeyword, this.trueValue, this.elseIfClauses, this.elseKeyword, this.falseValue, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IfExpressionSyntax(this.Kind, this.ifKeyword, this.condition, this.thenKeyword, this.trueValue, this.elseIfClauses, this.elseKeyword, this.falseValue, GetDiagnostics(), annotations);

        internal IfExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 7;
            var ifKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var thenKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            var trueValue = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(trueValue);
            this.trueValue = trueValue;
            var elseIfClauses = (GreenNode?)reader.ReadValue();
            if (elseIfClauses != null)
            {
                AdjustFlagsAndWidth(elseIfClauses);
                this.elseIfClauses = elseIfClauses;
            }
            var elseKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            var falseValue = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(falseValue);
            this.falseValue = falseValue;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.ifKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.thenKeyword);
            writer.WriteValue(this.trueValue);
            writer.WriteValue(this.elseIfClauses);
            writer.WriteValue(this.elseKeyword);
            writer.WriteValue(this.falseValue);
        }

        static IfExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IfExpressionSyntax), r => new IfExpressionSyntax(r));
        }
    }

    /// <summary>
    /// The base node for prefix expressions (expressions that can be called as functions,
    /// have methods called on them and/or have members/elements accessed on them).
    /// </summary>
    internal abstract partial class PrefixExpressionSyntax : ExpressionSyntax
    {
        internal PrefixExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal PrefixExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected PrefixExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class ParenthesizedExpressionSyntax : PrefixExpressionSyntax
    {
        internal readonly SyntaxToken openParenthesisToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeParenthesisToken;

        internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        /// <summary>The opening parenthesis token.</summary>
        public SyntaxToken OpenParenthesisToken => this.openParenthesisToken;
        /// <summary>The inner expression.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>The closing parenthesis token.</summary>
        public SyntaxToken CloseParenthesisToken => this.closeParenthesisToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenthesisToken,
                1 => this.expression,
                2 => this.closeParenthesisToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ParenthesizedExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitParenthesizedExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedExpression(this);

        public ParenthesizedExpressionSyntax Update(SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken != this.OpenParenthesisToken || expression != this.Expression || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.ParenthesizedExpression(openParenthesisToken, expression, closeParenthesisToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParenthesizedExpressionSyntax(this.Kind, this.openParenthesisToken, this.expression, this.closeParenthesisToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParenthesizedExpressionSyntax(this.Kind, this.openParenthesisToken, this.expression, this.closeParenthesisToken, GetDiagnostics(), annotations);

        internal ParenthesizedExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenthesisToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenthesisToken);
        }

        static ParenthesizedExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParenthesizedExpressionSyntax), r => new ParenthesizedExpressionSyntax(r));
        }
    }

    /// <summary>Represents a function call expression.</summary>
    internal sealed partial class FunctionCallExpressionSyntax : PrefixExpressionSyntax
    {
        internal readonly PrefixExpressionSyntax expression;
        internal readonly FunctionArgumentSyntax argument;

        internal FunctionCallExpressionSyntax(SyntaxKind kind, PrefixExpressionSyntax expression, FunctionArgumentSyntax argument, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argument);
            this.argument = argument;
        }

        internal FunctionCallExpressionSyntax(SyntaxKind kind, PrefixExpressionSyntax expression, FunctionArgumentSyntax argument)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argument);
            this.argument = argument;
        }

        /// <summary>The expression returning the function to be called.</summary>
        public PrefixExpressionSyntax Expression => this.expression;
        /// <summary>The function's arguments.</summary>
        public FunctionArgumentSyntax Argument => this.argument;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.argument,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.FunctionCallExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitFunctionCallExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitFunctionCallExpression(this);

        public FunctionCallExpressionSyntax Update(PrefixExpressionSyntax expression, FunctionArgumentSyntax argument)
        {
            if (expression != this.Expression || argument != this.Argument)
            {
                var newNode = SyntaxFactory.FunctionCallExpression(expression, argument);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FunctionCallExpressionSyntax(this.Kind, this.expression, this.argument, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FunctionCallExpressionSyntax(this.Kind, this.expression, this.argument, GetDiagnostics(), annotations);

        internal FunctionCallExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var expression = (PrefixExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var argument = (FunctionArgumentSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argument);
            this.argument = argument;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.argument);
        }

        static FunctionCallExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FunctionCallExpressionSyntax), r => new FunctionCallExpressionSyntax(r));
        }
    }

    /// <summary>Represents a method call (obj:method args...) expression.</summary>
    internal sealed partial class MethodCallExpressionSyntax : PrefixExpressionSyntax
    {
        internal readonly PrefixExpressionSyntax expression;
        internal readonly SyntaxToken colonToken;
        internal readonly SyntaxToken identifier;
        internal readonly FunctionArgumentSyntax argument;

        internal MethodCallExpressionSyntax(SyntaxKind kind, PrefixExpressionSyntax expression, SyntaxToken colonToken, SyntaxToken identifier, FunctionArgumentSyntax argument, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(argument);
            this.argument = argument;
        }

        internal MethodCallExpressionSyntax(SyntaxKind kind, PrefixExpressionSyntax expression, SyntaxToken colonToken, SyntaxToken identifier, FunctionArgumentSyntax argument)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(argument);
            this.argument = argument;
        }

        /// <summary>The expression that contains the method being called.</summary>
        public PrefixExpressionSyntax Expression => this.expression;
        /// <summary>The colon token.</summary>
        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>The identifier containing the method name.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>The method call's arguments.</summary>
        public FunctionArgumentSyntax Argument => this.argument;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.colonToken,
                2 => this.identifier,
                3 => this.argument,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.MethodCallExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitMethodCallExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitMethodCallExpression(this);

        public MethodCallExpressionSyntax Update(PrefixExpressionSyntax expression, SyntaxToken colonToken, SyntaxToken identifier, FunctionArgumentSyntax argument)
        {
            if (expression != this.Expression || colonToken != this.ColonToken || identifier != this.Identifier || argument != this.Argument)
            {
                var newNode = SyntaxFactory.MethodCallExpression(expression, colonToken, identifier, argument);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MethodCallExpressionSyntax(this.Kind, this.expression, this.colonToken, this.identifier, this.argument, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MethodCallExpressionSyntax(this.Kind, this.expression, this.colonToken, this.identifier, this.argument, GetDiagnostics(), annotations);

        internal MethodCallExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var expression = (PrefixExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var argument = (FunctionArgumentSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argument);
            this.argument = argument;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.argument);
        }

        static MethodCallExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(MethodCallExpressionSyntax), r => new MethodCallExpressionSyntax(r));
        }
    }

    /// <summary>The base class for statements.</summary>
    internal abstract partial class StatementSyntax : LuaSyntaxNode
    {
        internal StatementSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal StatementSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected StatementSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public abstract SyntaxToken? SemicolonToken { get; }
    }

    /// <summary>Represents a variable attribute syntax.</summary>
    internal sealed partial class VariableAttributeSyntax : LuaSyntaxNode
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken greaterThanToken;

        internal VariableAttributeSyntax(SyntaxKind kind, SyntaxToken lessThanToken, SyntaxToken identifier, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal VariableAttributeSyntax(SyntaxKind kind, SyntaxToken lessThanToken, SyntaxToken identifier, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        /// <summary>
        /// The leading <c>&lt;</c> token.
        /// </summary>
        public SyntaxToken LessThanToken => this.lessThanToken;
        /// <summary>The attribute name identifier token.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>
        /// The trailing <c>&gt;</c> token.
        /// </summary>
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.identifier,
                2 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.VariableAttributeSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitVariableAttribute(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitVariableAttribute(this);

        public VariableAttributeSyntax Update(SyntaxToken lessThanToken, SyntaxToken identifier, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || identifier != this.Identifier || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.VariableAttribute(lessThanToken, identifier, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new VariableAttributeSyntax(this.Kind, this.lessThanToken, this.identifier, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new VariableAttributeSyntax(this.Kind, this.lessThanToken, this.identifier, this.greaterThanToken, GetDiagnostics(), annotations);

        internal VariableAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.greaterThanToken);
        }

        static VariableAttributeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(VariableAttributeSyntax), r => new VariableAttributeSyntax(r));
        }
    }

    /// <summary>
    /// Represents a variable name in a
    /// <see cref="LocalVariableDeclarationStatementSyntax" />
    /// node.
    /// </summary>
    internal sealed partial class LocalDeclarationNameSyntax : LuaSyntaxNode
    {
        internal readonly IdentifierNameSyntax identifierName;
        internal readonly VariableAttributeSyntax? attribute;
        internal readonly TypeBindingSyntax? typeBinding;

        internal LocalDeclarationNameSyntax(SyntaxKind kind, IdentifierNameSyntax identifierName, VariableAttributeSyntax? attribute, TypeBindingSyntax? typeBinding, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifierName);
            this.identifierName = identifierName;
            if (attribute != null)
            {
                this.AdjustFlagsAndWidth(attribute);
                this.attribute = attribute;
            }
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        internal LocalDeclarationNameSyntax(SyntaxKind kind, IdentifierNameSyntax identifierName, VariableAttributeSyntax? attribute, TypeBindingSyntax? typeBinding)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifierName);
            this.identifierName = identifierName;
            if (attribute != null)
            {
                this.AdjustFlagsAndWidth(attribute);
                this.attribute = attribute;
            }
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        /// <summary>
        /// The
        /// <see cref="IdentifierNameSyntax" />
        /// containing the name.
        /// </summary>
        public IdentifierNameSyntax IdentifierName => this.identifierName;
        /// <summary>
        /// The
        /// <see cref="VariableAttributeSyntax" />
        /// containing the (optional) variable attribute.
        /// </summary>
        public VariableAttributeSyntax? Attribute => this.attribute;
        /// <summary>
        /// The
        /// <see cref="TypeBindingSyntax" />
        /// containing the (optional) type.
        /// </summary>
        public TypeBindingSyntax? TypeBinding => this.typeBinding;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifierName,
                1 => this.attribute,
                2 => this.typeBinding,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.LocalDeclarationNameSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLocalDeclarationName(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitLocalDeclarationName(this);

        public LocalDeclarationNameSyntax Update(IdentifierNameSyntax identifierName, VariableAttributeSyntax attribute, TypeBindingSyntax typeBinding)
        {
            if (identifierName != this.IdentifierName || attribute != this.Attribute || typeBinding != this.TypeBinding)
            {
                var newNode = SyntaxFactory.LocalDeclarationName(identifierName, attribute, typeBinding);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LocalDeclarationNameSyntax(this.Kind, this.identifierName, this.attribute, this.typeBinding, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LocalDeclarationNameSyntax(this.Kind, this.identifierName, this.attribute, this.typeBinding, GetDiagnostics(), annotations);

        internal LocalDeclarationNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var identifierName = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(identifierName);
            this.identifierName = identifierName;
            var attribute = (VariableAttributeSyntax?)reader.ReadValue();
            if (attribute != null)
            {
                AdjustFlagsAndWidth(attribute);
                this.attribute = attribute;
            }
            var typeBinding = (TypeBindingSyntax?)reader.ReadValue();
            if (typeBinding != null)
            {
                AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifierName);
            writer.WriteValue(this.attribute);
            writer.WriteValue(this.typeBinding);
        }

        static LocalDeclarationNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LocalDeclarationNameSyntax), r => new LocalDeclarationNameSyntax(r));
        }
    }

    /// <summary>Represents the values being assigned to the names in an assignment or variable declaration.
    /// </summary>
    internal sealed partial class EqualsValuesClauseSyntax : LuaSyntaxNode
    {
        internal readonly SyntaxToken equalsToken;
        internal readonly GreenNode? values;

        internal EqualsValuesClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, GreenNode? values, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            if (values != null)
            {
                this.AdjustFlagsAndWidth(values);
                this.values = values;
            }
        }

        internal EqualsValuesClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, GreenNode? values)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            if (values != null)
            {
                this.AdjustFlagsAndWidth(values);
                this.values = values;
            }
        }

        /// <summary>The equals token.</summary>
        public SyntaxToken EqualsToken => this.equalsToken;
        /// <summary>The list of values being assigned.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Values => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.values));

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.equalsToken,
                1 => this.values,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.EqualsValuesClauseSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitEqualsValuesClause(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitEqualsValuesClause(this);

        public EqualsValuesClauseSyntax Update(SyntaxToken equalsToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> values)
        {
            if (equalsToken != this.EqualsToken || values != this.Values)
            {
                var newNode = SyntaxFactory.EqualsValuesClause(equalsToken, values);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EqualsValuesClauseSyntax(this.Kind, this.equalsToken, this.values, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EqualsValuesClauseSyntax(this.Kind, this.equalsToken, this.values, GetDiagnostics(), annotations);

        internal EqualsValuesClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var values = (GreenNode?)reader.ReadValue();
            if (values != null)
            {
                AdjustFlagsAndWidth(values);
                this.values = values;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.values);
        }

        static EqualsValuesClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EqualsValuesClauseSyntax), r => new EqualsValuesClauseSyntax(r));
        }
    }

    /// <summary>Represents an assignment statement.</summary>
    internal sealed partial class AssignmentStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? variables;
        internal readonly EqualsValuesClauseSyntax equalsValues;
        internal readonly SyntaxToken? semicolonToken;

        internal AssignmentStatementSyntax(SyntaxKind kind, GreenNode? variables, EqualsValuesClauseSyntax equalsValues, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (variables != null)
            {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
            this.AdjustFlagsAndWidth(equalsValues);
            this.equalsValues = equalsValues;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal AssignmentStatementSyntax(SyntaxKind kind, GreenNode? variables, EqualsValuesClauseSyntax equalsValues, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 3;
            if (variables != null)
            {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
            this.AdjustFlagsAndWidth(equalsValues);
            this.equalsValues = equalsValues;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The variables being assigned to.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<PrefixExpressionSyntax> Variables => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<PrefixExpressionSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.variables));
        /// <summary>The values being assigned to the names (if any).</summary>
        public EqualsValuesClauseSyntax EqualsValues => this.equalsValues;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.variables,
                1 => this.equalsValues,
                2 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.AssignmentStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitAssignmentStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitAssignmentStatement(this);

        public AssignmentStatementSyntax Update(Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<PrefixExpressionSyntax> variables, EqualsValuesClauseSyntax equalsValues, SyntaxToken semicolonToken)
        {
            if (variables != this.Variables || equalsValues != this.EqualsValues || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.AssignmentStatement(variables, equalsValues, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AssignmentStatementSyntax(this.Kind, this.variables, this.equalsValues, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AssignmentStatementSyntax(this.Kind, this.variables, this.equalsValues, this.semicolonToken, GetDiagnostics(), annotations);

        internal AssignmentStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var variables = (GreenNode?)reader.ReadValue();
            if (variables != null)
            {
                AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
            var equalsValues = (EqualsValuesClauseSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(equalsValues);
            this.equalsValues = equalsValues;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.variables);
            writer.WriteValue(this.equalsValues);
            writer.WriteValue(this.semicolonToken);
        }

        static AssignmentStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AssignmentStatementSyntax), r => new AssignmentStatementSyntax(r));
        }
    }

    internal sealed partial class CompoundAssignmentStatementSyntax : StatementSyntax
    {
        internal readonly PrefixExpressionSyntax variable;
        internal readonly SyntaxToken assignmentOperatorToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken? semicolonToken;

        internal CompoundAssignmentStatementSyntax(SyntaxKind kind, PrefixExpressionSyntax variable, SyntaxToken assignmentOperatorToken, ExpressionSyntax expression, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(variable);
            this.variable = variable;
            this.AdjustFlagsAndWidth(assignmentOperatorToken);
            this.assignmentOperatorToken = assignmentOperatorToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal CompoundAssignmentStatementSyntax(SyntaxKind kind, PrefixExpressionSyntax variable, SyntaxToken assignmentOperatorToken, ExpressionSyntax expression, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(variable);
            this.variable = variable;
            this.AdjustFlagsAndWidth(assignmentOperatorToken);
            this.assignmentOperatorToken = assignmentOperatorToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The variable being assigned to.</summary>
        public PrefixExpressionSyntax Variable => this.variable;
        /// <summary>The compound assignment operator token.</summary>
        public SyntaxToken AssignmentOperatorToken => this.assignmentOperatorToken;
        /// <summary>The expression on the right side of the operator.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.variable,
                1 => this.assignmentOperatorToken,
                2 => this.expression,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.CompoundAssignmentStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitCompoundAssignmentStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitCompoundAssignmentStatement(this);

        public CompoundAssignmentStatementSyntax Update(PrefixExpressionSyntax variable, SyntaxToken assignmentOperatorToken, ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
            if (variable != this.Variable || assignmentOperatorToken != this.AssignmentOperatorToken || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.CompoundAssignmentStatement(this.Kind, variable, assignmentOperatorToken, expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CompoundAssignmentStatementSyntax(this.Kind, this.variable, this.assignmentOperatorToken, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CompoundAssignmentStatementSyntax(this.Kind, this.variable, this.assignmentOperatorToken, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal CompoundAssignmentStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var variable = (PrefixExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(variable);
            this.variable = variable;
            var assignmentOperatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(assignmentOperatorToken);
            this.assignmentOperatorToken = assignmentOperatorToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.variable);
            writer.WriteValue(this.assignmentOperatorToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static CompoundAssignmentStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CompoundAssignmentStatementSyntax), r => new CompoundAssignmentStatementSyntax(r));
        }
    }

    /// <summary>Represents a local variable declaration statement.</summary>
    internal sealed partial class LocalVariableDeclarationStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken localKeyword;
        internal readonly GreenNode? names;
        internal readonly EqualsValuesClauseSyntax? equalsValues;
        internal readonly SyntaxToken? semicolonToken;

        internal LocalVariableDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken localKeyword, GreenNode? names, EqualsValuesClauseSyntax? equalsValues, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(localKeyword);
            this.localKeyword = localKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            if (equalsValues != null)
            {
                this.AdjustFlagsAndWidth(equalsValues);
                this.equalsValues = equalsValues;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal LocalVariableDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken localKeyword, GreenNode? names, EqualsValuesClauseSyntax? equalsValues, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(localKeyword);
            this.localKeyword = localKeyword;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            if (equalsValues != null)
            {
                this.AdjustFlagsAndWidth(equalsValues);
                this.equalsValues = equalsValues;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'local' keyword.</summary>
        public SyntaxToken LocalKeyword => this.localKeyword;
        /// <summary>The list of names being assigned to.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<LocalDeclarationNameSyntax> Names => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<LocalDeclarationNameSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.names));
        /// <summary>The values being assigned to the names (if any).</summary>
        public EqualsValuesClauseSyntax? EqualsValues => this.equalsValues;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.localKeyword,
                1 => this.names,
                2 => this.equalsValues,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.LocalVariableDeclarationStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLocalVariableDeclarationStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitLocalVariableDeclarationStatement(this);

        public LocalVariableDeclarationStatementSyntax Update(SyntaxToken localKeyword, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<LocalDeclarationNameSyntax> names, EqualsValuesClauseSyntax equalsValues, SyntaxToken semicolonToken)
        {
            if (localKeyword != this.LocalKeyword || names != this.Names || equalsValues != this.EqualsValues || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.LocalVariableDeclarationStatement(localKeyword, names, equalsValues, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LocalVariableDeclarationStatementSyntax(this.Kind, this.localKeyword, this.names, this.equalsValues, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LocalVariableDeclarationStatementSyntax(this.Kind, this.localKeyword, this.names, this.equalsValues, this.semicolonToken, GetDiagnostics(), annotations);

        internal LocalVariableDeclarationStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var localKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(localKeyword);
            this.localKeyword = localKeyword;
            var names = (GreenNode?)reader.ReadValue();
            if (names != null)
            {
                AdjustFlagsAndWidth(names);
                this.names = names;
            }
            var equalsValues = (EqualsValuesClauseSyntax?)reader.ReadValue();
            if (equalsValues != null)
            {
                AdjustFlagsAndWidth(equalsValues);
                this.equalsValues = equalsValues;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.localKeyword);
            writer.WriteValue(this.names);
            writer.WriteValue(this.equalsValues);
            writer.WriteValue(this.semicolonToken);
        }

        static LocalVariableDeclarationStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LocalVariableDeclarationStatementSyntax), r => new LocalVariableDeclarationStatementSyntax(r));
        }
    }

    /// <summary>This node represents an identifier name with a type binding.</summary>
    internal sealed partial class TypedIdentifierNameSyntax : LuaSyntaxNode
    {
        internal readonly IdentifierNameSyntax identifierName;
        internal readonly TypeBindingSyntax? typeBinding;

        internal TypedIdentifierNameSyntax(SyntaxKind kind, IdentifierNameSyntax identifierName, TypeBindingSyntax? typeBinding, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifierName);
            this.identifierName = identifierName;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        internal TypedIdentifierNameSyntax(SyntaxKind kind, IdentifierNameSyntax identifierName, TypeBindingSyntax? typeBinding)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifierName);
            this.identifierName = identifierName;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        /// <summary>The identifier.</summary>
        public IdentifierNameSyntax IdentifierName => this.identifierName;
        /// <summary>
        /// The type binding containing the type (if any).
        /// </summary>
        public TypeBindingSyntax? TypeBinding => this.typeBinding;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifierName,
                1 => this.typeBinding,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TypedIdentifierNameSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypedIdentifierName(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTypedIdentifierName(this);

        public TypedIdentifierNameSyntax Update(IdentifierNameSyntax identifierName, TypeBindingSyntax typeBinding)
        {
            if (identifierName != this.IdentifierName || typeBinding != this.TypeBinding)
            {
                var newNode = SyntaxFactory.TypedIdentifierName(identifierName, typeBinding);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypedIdentifierNameSyntax(this.Kind, this.identifierName, this.typeBinding, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypedIdentifierNameSyntax(this.Kind, this.identifierName, this.typeBinding, GetDiagnostics(), annotations);

        internal TypedIdentifierNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var identifierName = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(identifierName);
            this.identifierName = identifierName;
            var typeBinding = (TypeBindingSyntax?)reader.ReadValue();
            if (typeBinding != null)
            {
                AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifierName);
            writer.WriteValue(this.typeBinding);
        }

        static TypedIdentifierNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypedIdentifierNameSyntax), r => new TypedIdentifierNameSyntax(r));
        }
    }

    /// <summary>Represents a numeric for statement.</summary>
    internal sealed partial class NumericForStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly TypedIdentifierNameSyntax identifier;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax initialValue;
        internal readonly SyntaxToken finalValueCommaToken;
        internal readonly ExpressionSyntax finalValue;
        internal readonly SyntaxToken? stepValueCommaToken;
        internal readonly ExpressionSyntax? stepValue;
        internal readonly SyntaxToken doKeyword;
        internal readonly StatementListSyntax body;
        internal readonly SyntaxToken endKeyword;
        internal readonly SyntaxToken? semicolonToken;

        internal NumericForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, TypedIdentifierNameSyntax identifier, SyntaxToken equalsToken, ExpressionSyntax initialValue, SyntaxToken finalValueCommaToken, ExpressionSyntax finalValue, SyntaxToken? stepValueCommaToken, ExpressionSyntax? stepValue, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 12;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initialValue);
            this.initialValue = initialValue;
            this.AdjustFlagsAndWidth(finalValueCommaToken);
            this.finalValueCommaToken = finalValueCommaToken;
            this.AdjustFlagsAndWidth(finalValue);
            this.finalValue = finalValue;
            if (stepValueCommaToken != null)
            {
                this.AdjustFlagsAndWidth(stepValueCommaToken);
                this.stepValueCommaToken = stepValueCommaToken;
            }
            if (stepValue != null)
            {
                this.AdjustFlagsAndWidth(stepValue);
                this.stepValue = stepValue;
            }
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal NumericForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, TypedIdentifierNameSyntax identifier, SyntaxToken equalsToken, ExpressionSyntax initialValue, SyntaxToken finalValueCommaToken, ExpressionSyntax finalValue, SyntaxToken? stepValueCommaToken, ExpressionSyntax? stepValue, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 12;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(initialValue);
            this.initialValue = initialValue;
            this.AdjustFlagsAndWidth(finalValueCommaToken);
            this.finalValueCommaToken = finalValueCommaToken;
            this.AdjustFlagsAndWidth(finalValue);
            this.finalValue = finalValue;
            if (stepValueCommaToken != null)
            {
                this.AdjustFlagsAndWidth(stepValueCommaToken);
                this.stepValueCommaToken = stepValueCommaToken;
            }
            if (stepValue != null)
            {
                this.AdjustFlagsAndWidth(stepValue);
                this.stepValue = stepValue;
            }
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'for' keyword.</summary>
        public SyntaxToken ForKeyword => this.forKeyword;
        /// <summary>The loop variable.</summary>
        public TypedIdentifierNameSyntax Identifier => this.identifier;
        /// <summary>The equals token.</summary>
        public SyntaxToken EqualsToken => this.equalsToken;
        /// <summary>The expression defining the initial value of the loop variable.</summary>
        public ExpressionSyntax InitialValue => this.initialValue;
        /// <summary>The comma separating the initial value from the final value.</summary>
        public SyntaxToken FinalValueCommaToken => this.finalValueCommaToken;
        /// <summary>The expression defining the final value of the loop variable.</summary>
        public ExpressionSyntax FinalValue => this.finalValue;
        /// <summary>
        /// The comma separating the final value from the step value.
        /// May be None if there is no step.
        /// </summary>
        public SyntaxToken? StepValueCommaToken => this.stepValueCommaToken;
        /// <summary>
        /// The expression defining the step value of the loop variable.
        /// May be None if there is no step.
        /// </summary>
        public ExpressionSyntax? StepValue => this.stepValue;
        /// <summary>The 'do' keyword.</summary>
        public SyntaxToken DoKeyword => this.doKeyword;
        /// <summary>The loop's body.</summary>
        public StatementListSyntax Body => this.body;
        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => this.endKeyword;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.identifier,
                2 => this.equalsToken,
                3 => this.initialValue,
                4 => this.finalValueCommaToken,
                5 => this.finalValue,
                6 => this.stepValueCommaToken,
                7 => this.stepValue,
                8 => this.doKeyword,
                9 => this.body,
                10 => this.endKeyword,
                11 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.NumericForStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitNumericForStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitNumericForStatement(this);

        public NumericForStatementSyntax Update(SyntaxToken forKeyword, TypedIdentifierNameSyntax identifier, SyntaxToken equalsToken, ExpressionSyntax initialValue, SyntaxToken finalValueCommaToken, ExpressionSyntax finalValue, SyntaxToken stepValueCommaToken, ExpressionSyntax stepValue, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (forKeyword != this.ForKeyword || identifier != this.Identifier || equalsToken != this.EqualsToken || initialValue != this.InitialValue || finalValueCommaToken != this.FinalValueCommaToken || finalValue != this.FinalValue || stepValueCommaToken != this.StepValueCommaToken || stepValue != this.StepValue || doKeyword != this.DoKeyword || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.NumericForStatement(forKeyword, identifier, equalsToken, initialValue, finalValueCommaToken, finalValue, stepValueCommaToken, stepValue, doKeyword, body, endKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NumericForStatementSyntax(this.Kind, this.forKeyword, this.identifier, this.equalsToken, this.initialValue, this.finalValueCommaToken, this.finalValue, this.stepValueCommaToken, this.stepValue, this.doKeyword, this.body, this.endKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NumericForStatementSyntax(this.Kind, this.forKeyword, this.identifier, this.equalsToken, this.initialValue, this.finalValueCommaToken, this.finalValue, this.stepValueCommaToken, this.stepValue, this.doKeyword, this.body, this.endKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal NumericForStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 12;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var identifier = (TypedIdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var initialValue = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(initialValue);
            this.initialValue = initialValue;
            var finalValueCommaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(finalValueCommaToken);
            this.finalValueCommaToken = finalValueCommaToken;
            var finalValue = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(finalValue);
            this.finalValue = finalValue;
            var stepValueCommaToken = (SyntaxToken?)reader.ReadValue();
            if (stepValueCommaToken != null)
            {
                AdjustFlagsAndWidth(stepValueCommaToken);
                this.stepValueCommaToken = stepValueCommaToken;
            }
            var stepValue = (ExpressionSyntax?)reader.ReadValue();
            if (stepValue != null)
            {
                AdjustFlagsAndWidth(stepValue);
                this.stepValue = stepValue;
            }
            var doKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            var body = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
            var endKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.initialValue);
            writer.WriteValue(this.finalValueCommaToken);
            writer.WriteValue(this.finalValue);
            writer.WriteValue(this.stepValueCommaToken);
            writer.WriteValue(this.stepValue);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.body);
            writer.WriteValue(this.endKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static NumericForStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NumericForStatementSyntax), r => new NumericForStatementSyntax(r));
        }
    }

    /// <summary>Represents a generic for loop statement.</summary>
    internal sealed partial class GenericForStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken forKeyword;
        internal readonly GreenNode? identifiers;
        internal readonly SyntaxToken inKeyword;
        internal readonly GreenNode? expressions;
        internal readonly SyntaxToken doKeyword;
        internal readonly StatementListSyntax body;
        internal readonly SyntaxToken endKeyword;
        internal readonly SyntaxToken? semicolonToken;

        internal GenericForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? identifiers, SyntaxToken inKeyword, GreenNode? expressions, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (identifiers != null)
            {
                this.AdjustFlagsAndWidth(identifiers);
                this.identifiers = identifiers;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal GenericForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, GreenNode? identifiers, SyntaxToken inKeyword, GreenNode? expressions, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            if (identifiers != null)
            {
                this.AdjustFlagsAndWidth(identifiers);
                this.identifiers = identifiers;
            }
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'for' keyword.</summary>
        public SyntaxToken ForKeyword => this.forKeyword;
        /// <summary>The list of loop variables.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypedIdentifierNameSyntax> Identifiers => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypedIdentifierNameSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.identifiers));
        /// <summary>The 'in' keyword.</summary>
        public SyntaxToken InKeyword => this.inKeyword;
        /// <summary>The list of expressions.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Expressions => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.expressions));
        /// <summary>The 'do' keyword.</summary>
        public SyntaxToken DoKeyword => this.doKeyword;
        /// <summary>The loop's body.</summary>
        public StatementListSyntax Body => this.body;
        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => this.endKeyword;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.forKeyword,
                1 => this.identifiers,
                2 => this.inKeyword,
                3 => this.expressions,
                4 => this.doKeyword,
                5 => this.body,
                6 => this.endKeyword,
                7 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.GenericForStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitGenericForStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitGenericForStatement(this);

        public GenericForStatementSyntax Update(SyntaxToken forKeyword, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypedIdentifierNameSyntax> identifiers, SyntaxToken inKeyword, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (forKeyword != this.ForKeyword || identifiers != this.Identifiers || inKeyword != this.InKeyword || expressions != this.Expressions || doKeyword != this.DoKeyword || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.GenericForStatement(forKeyword, identifiers, inKeyword, expressions, doKeyword, body, endKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new GenericForStatementSyntax(this.Kind, this.forKeyword, this.identifiers, this.inKeyword, this.expressions, this.doKeyword, this.body, this.endKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new GenericForStatementSyntax(this.Kind, this.forKeyword, this.identifiers, this.inKeyword, this.expressions, this.doKeyword, this.body, this.endKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal GenericForStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var identifiers = (GreenNode?)reader.ReadValue();
            if (identifiers != null)
            {
                AdjustFlagsAndWidth(identifiers);
                this.identifiers = identifiers;
            }
            var inKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            var expressions = (GreenNode?)reader.ReadValue();
            if (expressions != null)
            {
                AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            var doKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            var body = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
            var endKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.identifiers);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.expressions);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.body);
            writer.WriteValue(this.endKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static GenericForStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(GenericForStatementSyntax), r => new GenericForStatementSyntax(r));
        }
    }

    /// <summary>Represents a while statement.</summary>
    internal sealed partial class WhileStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken whileKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken doKeyword;
        internal readonly StatementListSyntax body;
        internal readonly SyntaxToken endKeyword;
        internal readonly SyntaxToken? semicolonToken;

        internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'while' keyword.</summary>
        public SyntaxToken WhileKeyword => this.whileKeyword;
        /// <summary>The while's condition.</summary>
        public ExpressionSyntax Condition => this.condition;
        /// <summary>The 'do' keyword.</summary>
        public SyntaxToken DoKeyword => this.doKeyword;
        /// <summary>The while's body.</summary>
        public StatementListSyntax Body => this.body;
        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => this.endKeyword;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whileKeyword,
                1 => this.condition,
                2 => this.doKeyword,
                3 => this.body,
                4 => this.endKeyword,
                5 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.WhileStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitWhileStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitWhileStatement(this);

        public WhileStatementSyntax Update(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (whileKeyword != this.WhileKeyword || condition != this.Condition || doKeyword != this.DoKeyword || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.WhileStatement(whileKeyword, condition, doKeyword, body, endKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WhileStatementSyntax(this.Kind, this.whileKeyword, this.condition, this.doKeyword, this.body, this.endKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WhileStatementSyntax(this.Kind, this.whileKeyword, this.condition, this.doKeyword, this.body, this.endKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal WhileStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var whileKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var doKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            var body = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
            var endKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whileKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.body);
            writer.WriteValue(this.endKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static WhileStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WhileStatementSyntax), r => new WhileStatementSyntax(r));
        }
    }

    internal sealed partial class RepeatUntilStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken repeatKeyword;
        internal readonly StatementListSyntax body;
        internal readonly SyntaxToken untilKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken? semicolonToken;

        internal RepeatUntilStatementSyntax(SyntaxKind kind, SyntaxToken repeatKeyword, StatementListSyntax body, SyntaxToken untilKeyword, ExpressionSyntax condition, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(repeatKeyword);
            this.repeatKeyword = repeatKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(untilKeyword);
            this.untilKeyword = untilKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal RepeatUntilStatementSyntax(SyntaxKind kind, SyntaxToken repeatKeyword, StatementListSyntax body, SyntaxToken untilKeyword, ExpressionSyntax condition, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(repeatKeyword);
            this.repeatKeyword = repeatKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(untilKeyword);
            this.untilKeyword = untilKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'repeat' until keyword.</summary>
        public SyntaxToken RepeatKeyword => this.repeatKeyword;
        /// <summary>The repeat until's body.</summary>
        public StatementListSyntax Body => this.body;
        /// <summary>The 'until' keyword.</summary>
        public SyntaxToken UntilKeyword => this.untilKeyword;
        /// <summary>The repeat until's condition.</summary>
        public ExpressionSyntax Condition => this.condition;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.repeatKeyword,
                1 => this.body,
                2 => this.untilKeyword,
                3 => this.condition,
                4 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.RepeatUntilStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitRepeatUntilStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitRepeatUntilStatement(this);

        public RepeatUntilStatementSyntax Update(SyntaxToken repeatKeyword, StatementListSyntax body, SyntaxToken untilKeyword, ExpressionSyntax condition, SyntaxToken semicolonToken)
        {
            if (repeatKeyword != this.RepeatKeyword || body != this.Body || untilKeyword != this.UntilKeyword || condition != this.Condition || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.RepeatUntilStatement(repeatKeyword, body, untilKeyword, condition, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RepeatUntilStatementSyntax(this.Kind, this.repeatKeyword, this.body, this.untilKeyword, this.condition, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RepeatUntilStatementSyntax(this.Kind, this.repeatKeyword, this.body, this.untilKeyword, this.condition, this.semicolonToken, GetDiagnostics(), annotations);

        internal RepeatUntilStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var repeatKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(repeatKeyword);
            this.repeatKeyword = repeatKeyword;
            var body = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
            var untilKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(untilKeyword);
            this.untilKeyword = untilKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.repeatKeyword);
            writer.WriteValue(this.body);
            writer.WriteValue(this.untilKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.semicolonToken);
        }

        static RepeatUntilStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(RepeatUntilStatementSyntax), r => new RepeatUntilStatementSyntax(r));
        }
    }

    /// <summary>Represents an if statement.</summary>
    internal sealed partial class IfStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken ifKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken thenKeyword;
        internal readonly StatementListSyntax body;
        internal readonly GreenNode? elseIfClauses;
        internal readonly ElseClauseSyntax? elseClause;
        internal readonly SyntaxToken endKeyword;
        internal readonly SyntaxToken? semicolonToken;

        internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body, GreenNode? elseIfClauses, ElseClauseSyntax? elseClause, SyntaxToken endKeyword, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            if (elseIfClauses != null)
            {
                this.AdjustFlagsAndWidth(elseIfClauses);
                this.elseIfClauses = elseIfClauses;
            }
            if (elseClause != null)
            {
                this.AdjustFlagsAndWidth(elseClause);
                this.elseClause = elseClause;
            }
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body, GreenNode? elseIfClauses, ElseClauseSyntax? elseClause, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            if (elseIfClauses != null)
            {
                this.AdjustFlagsAndWidth(elseIfClauses);
                this.elseIfClauses = elseIfClauses;
            }
            if (elseClause != null)
            {
                this.AdjustFlagsAndWidth(elseClause);
                this.elseClause = elseClause;
            }
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'if' keyword.</summary>
        public SyntaxToken IfKeyword => this.ifKeyword;
        /// <summary>The if's condition.</summary>
        public ExpressionSyntax Condition => this.condition;
        /// <summary>The 'then' keyword.</summary>
        public SyntaxToken ThenKeyword => this.thenKeyword;
        /// <summary>The if's body.</summary>
        public StatementListSyntax Body => this.body;
        /// <summary>The elseif clauses.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax> ElseIfClauses => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax>(this.elseIfClauses);
        /// <summary>The else clause.</summary>
        public ElseClauseSyntax? ElseClause => this.elseClause;
        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => this.endKeyword;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.ifKeyword,
                1 => this.condition,
                2 => this.thenKeyword,
                3 => this.body,
                4 => this.elseIfClauses,
                5 => this.elseClause,
                6 => this.endKeyword,
                7 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.IfStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIfStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitIfStatement(this);

        public IfStatementSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body, Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax> elseIfClauses, ElseClauseSyntax elseClause, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (ifKeyword != this.IfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || body != this.Body || elseIfClauses != this.ElseIfClauses || elseClause != this.ElseClause || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.IfStatement(ifKeyword, condition, thenKeyword, body, elseIfClauses, elseClause, endKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IfStatementSyntax(this.Kind, this.ifKeyword, this.condition, this.thenKeyword, this.body, this.elseIfClauses, this.elseClause, this.endKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IfStatementSyntax(this.Kind, this.ifKeyword, this.condition, this.thenKeyword, this.body, this.elseIfClauses, this.elseClause, this.endKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal IfStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var ifKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var thenKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            var body = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
            var elseIfClauses = (GreenNode?)reader.ReadValue();
            if (elseIfClauses != null)
            {
                AdjustFlagsAndWidth(elseIfClauses);
                this.elseIfClauses = elseIfClauses;
            }
            var elseClause = (ElseClauseSyntax?)reader.ReadValue();
            if (elseClause != null)
            {
                AdjustFlagsAndWidth(elseClause);
                this.elseClause = elseClause;
            }
            var endKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.ifKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.thenKeyword);
            writer.WriteValue(this.body);
            writer.WriteValue(this.elseIfClauses);
            writer.WriteValue(this.elseClause);
            writer.WriteValue(this.endKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static IfStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IfStatementSyntax), r => new IfStatementSyntax(r));
        }
    }

    /// <summary>Represents an elseif clause.</summary>
    internal sealed partial class ElseIfClauseSyntax : LuaSyntaxNode
    {
        internal readonly SyntaxToken elseIfKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken thenKeyword;
        internal readonly StatementListSyntax body;

        internal ElseIfClauseSyntax(SyntaxKind kind, SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(elseIfKeyword);
            this.elseIfKeyword = elseIfKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }

        internal ElseIfClauseSyntax(SyntaxKind kind, SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(elseIfKeyword);
            this.elseIfKeyword = elseIfKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }

        /// <summary>The 'elseif' keyword.</summary>
        public SyntaxToken ElseIfKeyword => this.elseIfKeyword;
        /// <summary>The condition.</summary>
        public ExpressionSyntax Condition => this.condition;
        /// <summary>The 'then' keyword.</summary>
        public SyntaxToken ThenKeyword => this.thenKeyword;
        /// <summary>The elseif body.</summary>
        public StatementListSyntax Body => this.body;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.elseIfKeyword,
                1 => this.condition,
                2 => this.thenKeyword,
                3 => this.body,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ElseIfClauseSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitElseIfClause(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitElseIfClause(this);

        public ElseIfClauseSyntax Update(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body)
        {
            if (elseIfKeyword != this.ElseIfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || body != this.Body)
            {
                var newNode = SyntaxFactory.ElseIfClause(elseIfKeyword, condition, thenKeyword, body);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElseIfClauseSyntax(this.Kind, this.elseIfKeyword, this.condition, this.thenKeyword, this.body, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElseIfClauseSyntax(this.Kind, this.elseIfKeyword, this.condition, this.thenKeyword, this.body, GetDiagnostics(), annotations);

        internal ElseIfClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var elseIfKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(elseIfKeyword);
            this.elseIfKeyword = elseIfKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var thenKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(thenKeyword);
            this.thenKeyword = thenKeyword;
            var body = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.elseIfKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.thenKeyword);
            writer.WriteValue(this.body);
        }

        static ElseIfClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElseIfClauseSyntax), r => new ElseIfClauseSyntax(r));
        }
    }

    /// <summary>Represents an else clause.</summary>
    internal sealed partial class ElseClauseSyntax : LuaSyntaxNode
    {
        internal readonly SyntaxToken elseKeyword;
        internal readonly StatementListSyntax elseBody;

        internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementListSyntax elseBody, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(elseBody);
            this.elseBody = elseBody;
        }

        internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementListSyntax elseBody)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(elseBody);
            this.elseBody = elseBody;
        }

        /// <summary>The 'else' keyword.</summary>
        public SyntaxToken ElseKeyword => this.elseKeyword;
        /// <summary>The else's body.</summary>
        public StatementListSyntax ElseBody => this.elseBody;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.elseKeyword,
                1 => this.elseBody,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ElseClauseSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitElseClause(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitElseClause(this);

        public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementListSyntax elseBody)
        {
            if (elseKeyword != this.ElseKeyword || elseBody != this.ElseBody)
            {
                var newNode = SyntaxFactory.ElseClause(elseKeyword, elseBody);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElseClauseSyntax(this.Kind, this.elseKeyword, this.elseBody, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElseClauseSyntax(this.Kind, this.elseKeyword, this.elseBody, GetDiagnostics(), annotations);

        internal ElseClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var elseKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            var elseBody = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(elseBody);
            this.elseBody = elseBody;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.elseKeyword);
            writer.WriteValue(this.elseBody);
        }

        static ElseClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElseClauseSyntax), r => new ElseClauseSyntax(r));
        }
    }

    /// <summary>Represents a goto statement.</summary>
    internal sealed partial class GotoStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken gotoKeyword;
        internal readonly SyntaxToken labelName;
        internal readonly SyntaxToken? semicolonToken;

        internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken labelName, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            this.AdjustFlagsAndWidth(labelName);
            this.labelName = labelName;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken labelName, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            this.AdjustFlagsAndWidth(labelName);
            this.labelName = labelName;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'goto' keyword.</summary>
        public SyntaxToken GotoKeyword => this.gotoKeyword;
        /// <summary>The name of the label being jumped to.</summary>
        public SyntaxToken LabelName => this.labelName;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.gotoKeyword,
                1 => this.labelName,
                2 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.GotoStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitGotoStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitGotoStatement(this);

        public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken labelName, SyntaxToken semicolonToken)
        {
            if (gotoKeyword != this.GotoKeyword || labelName != this.LabelName || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.GotoStatement(gotoKeyword, labelName, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.labelName, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.labelName, this.semicolonToken, GetDiagnostics(), annotations);

        internal GotoStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var gotoKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            var labelName = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(labelName);
            this.labelName = labelName;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.gotoKeyword);
            writer.WriteValue(this.labelName);
            writer.WriteValue(this.semicolonToken);
        }

        static GotoStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(GotoStatementSyntax), r => new GotoStatementSyntax(r));
        }
    }

    /// <summary>Represents a break statement.</summary>
    internal sealed partial class BreakStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken breakKeyword;
        internal readonly SyntaxToken? semicolonToken;

        internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'break' keyword.</summary>
        public SyntaxToken BreakKeyword => this.breakKeyword;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.breakKeyword,
                1 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.BreakStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitBreakStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitBreakStatement(this);

        public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        {
            if (breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.BreakStatement(breakKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal BreakStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var breakKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.breakKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static BreakStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BreakStatementSyntax), r => new BreakStatementSyntax(r));
        }
    }

    /// <summary>Represents a return statement.</summary>
    internal sealed partial class ReturnStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken returnKeyword;
        internal readonly GreenNode? expressions;
        internal readonly SyntaxToken? semicolonToken;

        internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, GreenNode? expressions, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, GreenNode? expressions, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'return' keyword.</summary>
        public SyntaxToken ReturnKeyword => this.returnKeyword;
        /// <summary>The expressions being returned.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Expressions => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.expressions));
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.returnKeyword,
                1 => this.expressions,
                2 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ReturnStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitReturnStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitReturnStatement(this);

        public ReturnStatementSyntax Update(SyntaxToken returnKeyword, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken semicolonToken)
        {
            if (returnKeyword != this.ReturnKeyword || expressions != this.Expressions || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ReturnStatement(returnKeyword, expressions, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.expressions, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.expressions, this.semicolonToken, GetDiagnostics(), annotations);

        internal ReturnStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var returnKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            var expressions = (GreenNode?)reader.ReadValue();
            if (expressions != null)
            {
                AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.returnKeyword);
            writer.WriteValue(this.expressions);
            writer.WriteValue(this.semicolonToken);
        }

        static ReturnStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ReturnStatementSyntax), r => new ReturnStatementSyntax(r));
        }
    }

    /// <summary>Represents a continue statement.</summary>
    internal sealed partial class ContinueStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken continueKeyword;
        internal readonly SyntaxToken? semicolonToken;

        internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'continue' keyword.</summary>
        public SyntaxToken ContinueKeyword => this.continueKeyword;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.continueKeyword,
                1 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ContinueStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitContinueStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitContinueStatement(this);

        public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        {
            if (continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ContinueStatement(continueKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal ContinueStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var continueKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.continueKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static ContinueStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ContinueStatementSyntax), r => new ContinueStatementSyntax(r));
        }
    }

    /// <summary>Represents a local function declaration statement.</summary>
    internal sealed partial class LocalFunctionDeclarationStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken localKeyword;
        internal readonly SyntaxToken functionKeyword;
        internal readonly IdentifierNameSyntax name;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly ParameterListSyntax parameters;
        internal readonly TypeBindingSyntax? typeBinding;
        internal readonly StatementListSyntax body;
        internal readonly SyntaxToken endKeyword;
        internal readonly SyntaxToken? semicolonToken;

        internal LocalFunctionDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken localKeyword, SyntaxToken functionKeyword, IdentifierNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 9;
            this.AdjustFlagsAndWidth(localKeyword);
            this.localKeyword = localKeyword;
            this.AdjustFlagsAndWidth(functionKeyword);
            this.functionKeyword = functionKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal LocalFunctionDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken localKeyword, SyntaxToken functionKeyword, IdentifierNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 9;
            this.AdjustFlagsAndWidth(localKeyword);
            this.localKeyword = localKeyword;
            this.AdjustFlagsAndWidth(functionKeyword);
            this.functionKeyword = functionKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'local' keyword.</summary>
        public SyntaxToken LocalKeyword => this.localKeyword;
        /// <summary>The 'function' keyword.</summary>
        public SyntaxToken FunctionKeyword => this.functionKeyword;
        /// <summary>The function's name.</summary>
        public IdentifierNameSyntax Name => this.name;
        /// <summary>Gets the type parameter list for this function (if any).</summary>
        public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        /// <summary>The parameter list.</summary>
        public ParameterListSyntax Parameters => this.parameters;
        /// <summary>The function's (optional) return type.</summary>
        public TypeBindingSyntax? TypeBinding => this.typeBinding;
        /// <summary>The function's body.</summary>
        public StatementListSyntax Body => this.body;
        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => this.endKeyword;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.localKeyword,
                1 => this.functionKeyword,
                2 => this.name,
                3 => this.typeParameterList,
                4 => this.parameters,
                5 => this.typeBinding,
                6 => this.body,
                7 => this.endKeyword,
                8 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.LocalFunctionDeclarationStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLocalFunctionDeclarationStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitLocalFunctionDeclarationStatement(this);

        public LocalFunctionDeclarationStatementSyntax Update(SyntaxToken localKeyword, SyntaxToken functionKeyword, IdentifierNameSyntax name, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (localKeyword != this.LocalKeyword || functionKeyword != this.FunctionKeyword || name != this.Name || typeParameterList != this.TypeParameterList || parameters != this.Parameters || typeBinding != this.TypeBinding || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.LocalFunctionDeclarationStatement(localKeyword, functionKeyword, name, typeParameterList, parameters, typeBinding, body, endKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LocalFunctionDeclarationStatementSyntax(this.Kind, this.localKeyword, this.functionKeyword, this.name, this.typeParameterList, this.parameters, this.typeBinding, this.body, this.endKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LocalFunctionDeclarationStatementSyntax(this.Kind, this.localKeyword, this.functionKeyword, this.name, this.typeParameterList, this.parameters, this.typeBinding, this.body, this.endKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal LocalFunctionDeclarationStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 9;
            var localKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(localKeyword);
            this.localKeyword = localKeyword;
            var functionKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(functionKeyword);
            this.functionKeyword = functionKeyword;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var parameters = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
            var typeBinding = (TypeBindingSyntax?)reader.ReadValue();
            if (typeBinding != null)
            {
                AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
            var body = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
            var endKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.localKeyword);
            writer.WriteValue(this.functionKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.typeBinding);
            writer.WriteValue(this.body);
            writer.WriteValue(this.endKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static LocalFunctionDeclarationStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LocalFunctionDeclarationStatementSyntax), r => new LocalFunctionDeclarationStatementSyntax(r));
        }
    }

    /// <summary>Represents a function declaration statement.</summary>
    internal sealed partial class FunctionDeclarationStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken functionKeyword;
        internal readonly FunctionNameSyntax name;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly ParameterListSyntax parameters;
        internal readonly TypeBindingSyntax? typeBinding;
        internal readonly StatementListSyntax body;
        internal readonly SyntaxToken endKeyword;
        internal readonly SyntaxToken? semicolonToken;

        internal FunctionDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken functionKeyword, FunctionNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(functionKeyword);
            this.functionKeyword = functionKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal FunctionDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken functionKeyword, FunctionNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(functionKeyword);
            this.functionKeyword = functionKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
            if (typeBinding != null)
            {
                this.AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'function' keyword.</summary>
        public SyntaxToken FunctionKeyword => this.functionKeyword;
        /// <summary>The function's name.</summary>
        public FunctionNameSyntax Name => this.name;
        /// <summary>Gets the type parameter list for this function (if any).</summary>
        public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        /// <summary>The function's parameters.</summary>
        public ParameterListSyntax Parameters => this.parameters;
        /// <summary>The function's (optional) return type.</summary>
        public TypeBindingSyntax? TypeBinding => this.typeBinding;
        /// <summary>The function's body.</summary>
        public StatementListSyntax Body => this.body;
        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => this.endKeyword;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.functionKeyword,
                1 => this.name,
                2 => this.typeParameterList,
                3 => this.parameters,
                4 => this.typeBinding,
                5 => this.body,
                6 => this.endKeyword,
                7 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.FunctionDeclarationStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitFunctionDeclarationStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitFunctionDeclarationStatement(this);

        public FunctionDeclarationStatementSyntax Update(SyntaxToken functionKeyword, FunctionNameSyntax name, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (functionKeyword != this.FunctionKeyword || name != this.Name || typeParameterList != this.TypeParameterList || parameters != this.Parameters || typeBinding != this.TypeBinding || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.FunctionDeclarationStatement(functionKeyword, name, typeParameterList, parameters, typeBinding, body, endKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FunctionDeclarationStatementSyntax(this.Kind, this.functionKeyword, this.name, this.typeParameterList, this.parameters, this.typeBinding, this.body, this.endKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FunctionDeclarationStatementSyntax(this.Kind, this.functionKeyword, this.name, this.typeParameterList, this.parameters, this.typeBinding, this.body, this.endKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal FunctionDeclarationStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var functionKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(functionKeyword);
            this.functionKeyword = functionKeyword;
            var name = (FunctionNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var parameters = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
            var typeBinding = (TypeBindingSyntax?)reader.ReadValue();
            if (typeBinding != null)
            {
                AdjustFlagsAndWidth(typeBinding);
                this.typeBinding = typeBinding;
            }
            var body = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
            var endKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.functionKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.typeBinding);
            writer.WriteValue(this.body);
            writer.WriteValue(this.endKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static FunctionDeclarationStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FunctionDeclarationStatementSyntax), r => new FunctionDeclarationStatementSyntax(r));
        }
    }

    /// <summary>Represents a do statement.</summary>
    internal sealed partial class DoStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken doKeyword;
        internal readonly StatementListSyntax body;
        internal readonly SyntaxToken endKeyword;
        internal readonly SyntaxToken? semicolonToken;

        internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            this.AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'do' keyword.</summary>
        public SyntaxToken DoKeyword => this.doKeyword;
        /// <summary>The do's body.</summary>
        public StatementListSyntax Body => this.body;
        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => this.endKeyword;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.doKeyword,
                1 => this.body,
                2 => this.endKeyword,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.DoStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitDoStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitDoStatement(this);

        public DoStatementSyntax Update(SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (doKeyword != this.DoKeyword || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.DoStatement(doKeyword, body, endKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DoStatementSyntax(this.Kind, this.doKeyword, this.body, this.endKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DoStatementSyntax(this.Kind, this.doKeyword, this.body, this.endKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal DoStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var doKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            var body = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
            var endKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endKeyword);
            this.endKeyword = endKeyword;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.body);
            writer.WriteValue(this.endKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static DoStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DoStatementSyntax), r => new DoStatementSyntax(r));
        }
    }

    /// <summary>Represents a goto label statement.</summary>
    internal sealed partial class GotoLabelStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken leftDelimiterToken;
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken rightDelimiterToken;
        internal readonly SyntaxToken? semicolonToken;

        internal GotoLabelStatementSyntax(SyntaxKind kind, SyntaxToken leftDelimiterToken, SyntaxToken identifier, SyntaxToken rightDelimiterToken, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(leftDelimiterToken);
            this.leftDelimiterToken = leftDelimiterToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(rightDelimiterToken);
            this.rightDelimiterToken = rightDelimiterToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal GotoLabelStatementSyntax(SyntaxKind kind, SyntaxToken leftDelimiterToken, SyntaxToken identifier, SyntaxToken rightDelimiterToken, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(leftDelimiterToken);
            this.leftDelimiterToken = leftDelimiterToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(rightDelimiterToken);
            this.rightDelimiterToken = rightDelimiterToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The delimiter on the left of the name.</summary>
        public SyntaxToken LeftDelimiterToken => this.leftDelimiterToken;
        /// <summary>The label name.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>The delimiter on the right of the name.</summary>
        public SyntaxToken RightDelimiterToken => this.rightDelimiterToken;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.leftDelimiterToken,
                1 => this.identifier,
                2 => this.rightDelimiterToken,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.GotoLabelStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitGotoLabelStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitGotoLabelStatement(this);

        public GotoLabelStatementSyntax Update(SyntaxToken leftDelimiterToken, SyntaxToken identifier, SyntaxToken rightDelimiterToken, SyntaxToken semicolonToken)
        {
            if (leftDelimiterToken != this.LeftDelimiterToken || identifier != this.Identifier || rightDelimiterToken != this.RightDelimiterToken || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.GotoLabelStatement(leftDelimiterToken, identifier, rightDelimiterToken, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new GotoLabelStatementSyntax(this.Kind, this.leftDelimiterToken, this.identifier, this.rightDelimiterToken, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new GotoLabelStatementSyntax(this.Kind, this.leftDelimiterToken, this.identifier, this.rightDelimiterToken, this.semicolonToken, GetDiagnostics(), annotations);

        internal GotoLabelStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var leftDelimiterToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(leftDelimiterToken);
            this.leftDelimiterToken = leftDelimiterToken;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var rightDelimiterToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(rightDelimiterToken);
            this.rightDelimiterToken = rightDelimiterToken;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.leftDelimiterToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.rightDelimiterToken);
            writer.WriteValue(this.semicolonToken);
        }

        static GotoLabelStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(GotoLabelStatementSyntax), r => new GotoLabelStatementSyntax(r));
        }
    }

    /// <summary>An expression as a statement.</summary>
    internal sealed partial class ExpressionStatementSyntax : StatementSyntax
    {
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken? semicolonToken;

        internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The function call expression.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ExpressionStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitExpressionStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitExpressionStatement(this);

        public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
            if (expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ExpressionStatement(expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal ExpressionStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static ExpressionStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExpressionStatementSyntax), r => new ExpressionStatementSyntax(r));
        }
    }

    /// <summary>An empty statement.</summary>
    internal sealed partial class EmptyStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken? semicolonToken;

        internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 1;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.semicolonToken : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.EmptyStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitEmptyStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitEmptyStatement(this);

        public EmptyStatementSyntax Update(SyntaxToken semicolonToken)
        {
            if (semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.EmptyStatement(semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EmptyStatementSyntax(this.Kind, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EmptyStatementSyntax(this.Kind, this.semicolonToken, GetDiagnostics(), annotations);

        internal EmptyStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.semicolonToken);
        }

        static EmptyStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EmptyStatementSyntax), r => new EmptyStatementSyntax(r));
        }
    }

    /// <summary>Represents a type declaration statement.</summary>
    internal sealed partial class TypeDeclarationStatementSyntax : StatementSyntax
    {
        internal readonly SyntaxToken? exportKeyword;
        internal readonly SyntaxToken typeKeyword;
        internal readonly SyntaxToken name;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly SyntaxToken equalsToken;
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken? semicolonToken;

        internal TypeDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken? exportKeyword, SyntaxToken typeKeyword, SyntaxToken name, TypeParameterListSyntax? typeParameterList, SyntaxToken equalsToken, TypeSyntax type, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 7;
            if (exportKeyword != null)
            {
                this.AdjustFlagsAndWidth(exportKeyword);
                this.exportKeyword = exportKeyword;
            }
            this.AdjustFlagsAndWidth(typeKeyword);
            this.typeKeyword = typeKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal TypeDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken? exportKeyword, SyntaxToken typeKeyword, SyntaxToken name, TypeParameterListSyntax? typeParameterList, SyntaxToken equalsToken, TypeSyntax type, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 7;
            if (exportKeyword != null)
            {
                this.AdjustFlagsAndWidth(exportKeyword);
                this.exportKeyword = exportKeyword;
            }
            this.AdjustFlagsAndWidth(typeKeyword);
            this.typeKeyword = typeKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>The 'export' keyword.</summary>
        public SyntaxToken? ExportKeyword => this.exportKeyword;
        /// <summary>The 'type' keyword.</summary>
        public SyntaxToken TypeKeyword => this.typeKeyword;
        /// <summary>Represents the type's name.</summary>
        public SyntaxToken Name => this.name;
        /// <summary>The type parameter list for this generic type.</summary>
        public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        /// <summary>The equals token of the type.</summary>
        public SyntaxToken EqualsToken => this.equalsToken;
        /// <summary>Represents the declared type.</summary>
        public TypeSyntax Type => this.type;
        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.exportKeyword,
                1 => this.typeKeyword,
                2 => this.name,
                3 => this.typeParameterList,
                4 => this.equalsToken,
                5 => this.type,
                6 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TypeDeclarationStatementSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeDeclarationStatement(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeDeclarationStatement(this);

        public TypeDeclarationStatementSyntax Update(SyntaxToken exportKeyword, SyntaxToken typeKeyword, SyntaxToken name, TypeParameterListSyntax typeParameterList, SyntaxToken equalsToken, TypeSyntax type, SyntaxToken semicolonToken)
        {
            if (exportKeyword != this.ExportKeyword || typeKeyword != this.TypeKeyword || name != this.Name || typeParameterList != this.TypeParameterList || equalsToken != this.EqualsToken || type != this.Type || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.TypeDeclarationStatement(exportKeyword, typeKeyword, name, typeParameterList, equalsToken, type, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeDeclarationStatementSyntax(this.Kind, this.exportKeyword, this.typeKeyword, this.name, this.typeParameterList, this.equalsToken, this.type, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeDeclarationStatementSyntax(this.Kind, this.exportKeyword, this.typeKeyword, this.name, this.typeParameterList, this.equalsToken, this.type, this.semicolonToken, GetDiagnostics(), annotations);

        internal TypeDeclarationStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 7;
            var exportKeyword = (SyntaxToken?)reader.ReadValue();
            if (exportKeyword != null)
            {
                AdjustFlagsAndWidth(exportKeyword);
                this.exportKeyword = exportKeyword;
            }
            var typeKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(typeKeyword);
            this.typeKeyword = typeKeyword;
            var name = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.exportKeyword);
            writer.WriteValue(this.typeKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.semicolonToken);
        }

        static TypeDeclarationStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeDeclarationStatementSyntax), r => new TypeDeclarationStatementSyntax(r));
        }
    }

    /// <summary>The base node for type annotations</summary>
    internal abstract partial class TypeSyntax : LuaSyntaxNode
    {
        internal TypeSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal TypeSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected TypeSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>The node representing a type annotation</summary>
    internal sealed partial class TypeBindingSyntax : LuaSyntaxNode
    {
        internal readonly SyntaxToken colonToken;
        internal readonly TypeSyntax type;

        internal TypeBindingSyntax(SyntaxKind kind, SyntaxToken colonToken, TypeSyntax type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal TypeBindingSyntax(SyntaxKind kind, SyntaxToken colonToken, TypeSyntax type)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        /// <summary>
        /// Gets the <c>:</c> token.
        /// </summary>
        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>Gets the type of the annotation.</summary>
        public TypeSyntax Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.colonToken,
                1 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TypeBindingSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeBinding(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeBinding(this);

        public TypeBindingSyntax Update(SyntaxToken colonToken, TypeSyntax type)
        {
            if (colonToken != this.ColonToken || type != this.Type)
            {
                var newNode = SyntaxFactory.TypeBinding(colonToken, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeBindingSyntax(this.Kind, this.colonToken, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeBindingSyntax(this.Kind, this.colonToken, this.type, GetDiagnostics(), annotations);

        internal TypeBindingSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.type);
        }

        static TypeBindingSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeBindingSyntax), r => new TypeBindingSyntax(r));
        }
    }

    /// <summary>This node represents a type's name.</summary>
    internal abstract partial class TypeNameSyntax : TypeSyntax
    {
        internal TypeNameSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal TypeNameSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected TypeNameSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>The type argument list for this generic type.</summary>
        public abstract TypeArgumentListSyntax? TypeArgumentList { get; }
    }

    /// <summary>This node reperesents a simple name (T).</summary>
    internal sealed partial class SimpleTypeNameSyntax : TypeNameSyntax
    {
        internal readonly SyntaxToken identifierToken;
        internal readonly TypeArgumentListSyntax? typeArgumentList;

        internal SimpleTypeNameSyntax(SyntaxKind kind, SyntaxToken identifierToken, TypeArgumentListSyntax? typeArgumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifierToken);
            this.identifierToken = identifierToken;
            if (typeArgumentList != null)
            {
                this.AdjustFlagsAndWidth(typeArgumentList);
                this.typeArgumentList = typeArgumentList;
            }
        }

        internal SimpleTypeNameSyntax(SyntaxKind kind, SyntaxToken identifierToken, TypeArgumentListSyntax? typeArgumentList)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifierToken);
            this.identifierToken = identifierToken;
            if (typeArgumentList != null)
            {
                this.AdjustFlagsAndWidth(typeArgumentList);
                this.typeArgumentList = typeArgumentList;
            }
        }

        /// <summary>Gets the name of the type.</summary>
        public SyntaxToken IdentifierToken => this.identifierToken;
        /// <summary>The type argument list for this generic type.</summary>
        public override TypeArgumentListSyntax? TypeArgumentList => this.typeArgumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifierToken,
                1 => this.typeArgumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.SimpleTypeNameSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitSimpleTypeName(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitSimpleTypeName(this);

        public SimpleTypeNameSyntax Update(SyntaxToken identifierToken, TypeArgumentListSyntax typeArgumentList)
        {
            if (identifierToken != this.IdentifierToken || typeArgumentList != this.TypeArgumentList)
            {
                var newNode = SyntaxFactory.SimpleTypeName(identifierToken, typeArgumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SimpleTypeNameSyntax(this.Kind, this.identifierToken, this.typeArgumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SimpleTypeNameSyntax(this.Kind, this.identifierToken, this.typeArgumentList, GetDiagnostics(), annotations);

        internal SimpleTypeNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var identifierToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifierToken);
            this.identifierToken = identifierToken;
            var typeArgumentList = (TypeArgumentListSyntax?)reader.ReadValue();
            if (typeArgumentList != null)
            {
                AdjustFlagsAndWidth(typeArgumentList);
                this.typeArgumentList = typeArgumentList;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifierToken);
            writer.WriteValue(this.typeArgumentList);
        }

        static SimpleTypeNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SimpleTypeNameSyntax), r => new SimpleTypeNameSyntax(r));
        }
    }

    /// <summary>This node represents a composite name (.T)</summary>
    internal sealed partial class CompositeTypeNameSyntax : TypeNameSyntax
    {
        internal readonly TypeNameSyntax @base;
        internal readonly SyntaxToken dotToken;
        internal readonly SyntaxToken identifierToken;
        internal readonly TypeArgumentListSyntax? typeArgumentList;

        internal CompositeTypeNameSyntax(SyntaxKind kind, TypeNameSyntax @base, SyntaxToken dotToken, SyntaxToken identifierToken, TypeArgumentListSyntax? typeArgumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(@base);
            this.@base = @base;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(identifierToken);
            this.identifierToken = identifierToken;
            if (typeArgumentList != null)
            {
                this.AdjustFlagsAndWidth(typeArgumentList);
                this.typeArgumentList = typeArgumentList;
            }
        }

        internal CompositeTypeNameSyntax(SyntaxKind kind, TypeNameSyntax @base, SyntaxToken dotToken, SyntaxToken identifierToken, TypeArgumentListSyntax? typeArgumentList)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(@base);
            this.@base = @base;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(identifierToken);
            this.identifierToken = identifierToken;
            if (typeArgumentList != null)
            {
                this.AdjustFlagsAndWidth(typeArgumentList);
                this.typeArgumentList = typeArgumentList;
            }
        }

        /// <summary>Gets the name of the type.</summary>
        public TypeNameSyntax Base => this.@base;
        /// <summary>
        /// Gets the . token.
        /// </summary>
        public SyntaxToken DotToken => this.dotToken;
        /// <summary>Gets the name of the type.</summary>
        public SyntaxToken IdentifierToken => this.identifierToken;
        /// <summary>The type argument list for this generic type.</summary>
        public override TypeArgumentListSyntax? TypeArgumentList => this.typeArgumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.@base,
                1 => this.dotToken,
                2 => this.identifierToken,
                3 => this.typeArgumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.CompositeTypeNameSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitCompositeTypeName(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitCompositeTypeName(this);

        public CompositeTypeNameSyntax Update(TypeNameSyntax @base, SyntaxToken dotToken, SyntaxToken identifierToken, TypeArgumentListSyntax typeArgumentList)
        {
            if (@base != this.Base || dotToken != this.DotToken || identifierToken != this.IdentifierToken || typeArgumentList != this.TypeArgumentList)
            {
                var newNode = SyntaxFactory.CompositeTypeName(@base, dotToken, identifierToken, typeArgumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CompositeTypeNameSyntax(this.Kind, this.@base, this.dotToken, this.identifierToken, this.typeArgumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CompositeTypeNameSyntax(this.Kind, this.@base, this.dotToken, this.identifierToken, this.typeArgumentList, GetDiagnostics(), annotations);

        internal CompositeTypeNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var @base = (TypeNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(@base);
            this.@base = @base;
            var dotToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            var identifierToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifierToken);
            this.identifierToken = identifierToken;
            var typeArgumentList = (TypeArgumentListSyntax?)reader.ReadValue();
            if (typeArgumentList != null)
            {
                AdjustFlagsAndWidth(typeArgumentList);
                this.typeArgumentList = typeArgumentList;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.@base);
            writer.WriteValue(this.dotToken);
            writer.WriteValue(this.identifierToken);
            writer.WriteValue(this.typeArgumentList);
        }

        static CompositeTypeNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CompositeTypeNameSyntax), r => new CompositeTypeNameSyntax(r));
        }
    }

    /// <summary>This node represents a nilable type.</summary>
    internal sealed partial class NilableTypeSyntax : TypeSyntax
    {
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken questionToken;

        internal NilableTypeSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken questionToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
        }

        internal NilableTypeSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken questionToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
        }

        /// <summary>Gets the base type that's being made nilable.</summary>
        public TypeSyntax Type => this.type;
        /// <summary>
        /// Gets the <c>?</c> token.
        /// </summary>
        public SyntaxToken QuestionToken => this.questionToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.type,
                1 => this.questionToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.NilableTypeSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitNilableType(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitNilableType(this);

        public NilableTypeSyntax Update(TypeSyntax type, SyntaxToken questionToken)
        {
            if (type != this.Type || questionToken != this.QuestionToken)
            {
                var newNode = SyntaxFactory.NilableType(type, questionToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NilableTypeSyntax(this.Kind, this.type, this.questionToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NilableTypeSyntax(this.Kind, this.type, this.questionToken, GetDiagnostics(), annotations);

        internal NilableTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var questionToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
            writer.WriteValue(this.questionToken);
        }

        static NilableTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NilableTypeSyntax), r => new NilableTypeSyntax(r));
        }
    }

    /// <summary>This node represents a parenthesized type.</summary>
    internal sealed partial class ParenthesizedTypeSyntax : TypeSyntax
    {
        internal readonly SyntaxToken openParenthesisToken;
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken closeParenthesisToken;

        internal ParenthesizedTypeSyntax(SyntaxKind kind, SyntaxToken openParenthesisToken, TypeSyntax type, SyntaxToken closeParenthesisToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal ParenthesizedTypeSyntax(SyntaxKind kind, SyntaxToken openParenthesisToken, TypeSyntax type, SyntaxToken closeParenthesisToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        /// <summary>
        /// Gets the <c>(</c> token.
        /// </summary>
        public SyntaxToken OpenParenthesisToken => this.openParenthesisToken;
        /// <summary>Gets the type contained within the parenthesis.</summary>
        public TypeSyntax Type => this.type;
        /// <summary>
        /// Gets the <c>)</c> token.
        /// </summary>
        public SyntaxToken CloseParenthesisToken => this.closeParenthesisToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenthesisToken,
                1 => this.type,
                2 => this.closeParenthesisToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ParenthesizedTypeSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitParenthesizedType(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedType(this);

        public ParenthesizedTypeSyntax Update(SyntaxToken openParenthesisToken, TypeSyntax type, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken != this.OpenParenthesisToken || type != this.Type || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.ParenthesizedType(openParenthesisToken, type, closeParenthesisToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParenthesizedTypeSyntax(this.Kind, this.openParenthesisToken, this.type, this.closeParenthesisToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParenthesizedTypeSyntax(this.Kind, this.openParenthesisToken, this.type, this.closeParenthesisToken, GetDiagnostics(), annotations);

        internal ParenthesizedTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var closeParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenthesisToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenthesisToken);
        }

        static ParenthesizedTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParenthesizedTypeSyntax), r => new ParenthesizedTypeSyntax(r));
        }
    }

    /// <summary>This node represents a type pack.</summary>
    internal sealed partial class TypePackSyntax : TypeSyntax
    {
        internal readonly SyntaxToken openParenthesisToken;
        internal readonly GreenNode? types;
        internal readonly SyntaxToken closeParenthesisToken;

        internal TypePackSyntax(SyntaxKind kind, SyntaxToken openParenthesisToken, GreenNode? types, SyntaxToken closeParenthesisToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            if (types != null)
            {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
            }
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal TypePackSyntax(SyntaxKind kind, SyntaxToken openParenthesisToken, GreenNode? types, SyntaxToken closeParenthesisToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            if (types != null)
            {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
            }
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        /// <summary>
        /// Gets the <c>(</c> token.
        /// </summary>
        public SyntaxToken OpenParenthesisToken => this.openParenthesisToken;
        /// <summary>Gets the list of the types of the pack's elements.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> Types => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.types));
        /// <summary>
        /// Gets the <c>)</c> token.
        /// </summary>
        public SyntaxToken CloseParenthesisToken => this.closeParenthesisToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenthesisToken,
                1 => this.types,
                2 => this.closeParenthesisToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TypePackSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypePack(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTypePack(this);

        public TypePackSyntax Update(SyntaxToken openParenthesisToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> types, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken != this.OpenParenthesisToken || types != this.Types || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.TypePack(openParenthesisToken, types, closeParenthesisToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypePackSyntax(this.Kind, this.openParenthesisToken, this.types, this.closeParenthesisToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypePackSyntax(this.Kind, this.openParenthesisToken, this.types, this.closeParenthesisToken, GetDiagnostics(), annotations);

        internal TypePackSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            var types = (GreenNode?)reader.ReadValue();
            if (types != null)
            {
                AdjustFlagsAndWidth(types);
                this.types = types;
            }
            var closeParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenthesisToken);
            writer.WriteValue(this.types);
            writer.WriteValue(this.closeParenthesisToken);
        }

        static TypePackSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypePackSyntax), r => new TypePackSyntax(r));
        }
    }

    /// <summary>This node represents a function type.</summary>
    internal sealed partial class FunctionTypeSyntax : TypeSyntax
    {
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly SyntaxToken openParenthesisToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken closeParenthesisToken;
        internal readonly SyntaxToken minusGreaterThanToken;
        internal readonly TypeSyntax returnType;

        internal FunctionTypeSyntax(SyntaxKind kind, TypeParameterListSyntax? typeParameterList, SyntaxToken openParenthesisToken, GreenNode? parameters, SyntaxToken closeParenthesisToken, SyntaxToken minusGreaterThanToken, TypeSyntax returnType, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
            this.AdjustFlagsAndWidth(minusGreaterThanToken);
            this.minusGreaterThanToken = minusGreaterThanToken;
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
        }

        internal FunctionTypeSyntax(SyntaxKind kind, TypeParameterListSyntax? typeParameterList, SyntaxToken openParenthesisToken, GreenNode? parameters, SyntaxToken closeParenthesisToken, SyntaxToken minusGreaterThanToken, TypeSyntax returnType)
          : base(kind)
        {
            this.SlotCount = 6;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
            this.AdjustFlagsAndWidth(minusGreaterThanToken);
            this.minusGreaterThanToken = minusGreaterThanToken;
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
        }

        /// <summary>Gets the type parameter list for this function (if any).</summary>
        public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        /// <summary>
        /// Gets the <c>(</c> token.
        /// </summary>
        public SyntaxToken OpenParenthesisToken => this.openParenthesisToken;
        /// <summary>Gets the list of the types of the function's parameters.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> Parameters => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.parameters));
        /// <summary>
        /// Gets the <c>)</c> token.
        /// </summary>
        public SyntaxToken CloseParenthesisToken => this.closeParenthesisToken;
        /// <summary>
        /// Gets the <c>-&gt;</c> token.
        /// </summary>
        public SyntaxToken MinusGreaterThanToken => this.minusGreaterThanToken;
        /// <summary>The return type of the function type.</summary>
        public TypeSyntax ReturnType => this.returnType;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.typeParameterList,
                1 => this.openParenthesisToken,
                2 => this.parameters,
                3 => this.closeParenthesisToken,
                4 => this.minusGreaterThanToken,
                5 => this.returnType,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.FunctionTypeSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitFunctionType(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitFunctionType(this);

        public FunctionTypeSyntax Update(TypeParameterListSyntax typeParameterList, SyntaxToken openParenthesisToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> parameters, SyntaxToken closeParenthesisToken, SyntaxToken minusGreaterThanToken, TypeSyntax returnType)
        {
            if (typeParameterList != this.TypeParameterList || openParenthesisToken != this.OpenParenthesisToken || parameters != this.Parameters || closeParenthesisToken != this.CloseParenthesisToken || minusGreaterThanToken != this.MinusGreaterThanToken || returnType != this.ReturnType)
            {
                var newNode = SyntaxFactory.FunctionType(typeParameterList, openParenthesisToken, parameters, closeParenthesisToken, minusGreaterThanToken, returnType);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FunctionTypeSyntax(this.Kind, this.typeParameterList, this.openParenthesisToken, this.parameters, this.closeParenthesisToken, this.minusGreaterThanToken, this.returnType, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FunctionTypeSyntax(this.Kind, this.typeParameterList, this.openParenthesisToken, this.parameters, this.closeParenthesisToken, this.minusGreaterThanToken, this.returnType, GetDiagnostics(), annotations);

        internal FunctionTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var openParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var closeParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
            var minusGreaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(minusGreaterThanToken);
            this.minusGreaterThanToken = minusGreaterThanToken;
            var returnType = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.openParenthesisToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeParenthesisToken);
            writer.WriteValue(this.minusGreaterThanToken);
            writer.WriteValue(this.returnType);
        }

        static FunctionTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FunctionTypeSyntax), r => new FunctionTypeSyntax(r));
        }
    }

    /// <summary>This node represents a table based type.</summary>
    internal abstract partial class TableBasedTypeSyntax : TypeSyntax
    {
        internal TableBasedTypeSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal TableBasedTypeSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected TableBasedTypeSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>This node represents an array type.</summary>
    internal sealed partial class ArrayTypeSyntax : TableBasedTypeSyntax
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken closeBraceToken;

        internal ArrayTypeSyntax(SyntaxKind kind, SyntaxToken openBraceToken, TypeSyntax type, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal ArrayTypeSyntax(SyntaxKind kind, SyntaxToken openBraceToken, TypeSyntax type, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        /// <summary>
        /// Gets the <c>{</c> token.
        /// </summary>
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        /// <summary>Gets the array's type</summary>
        public TypeSyntax Type => this.type;
        /// <summary>
        /// Gets the <c>}</c> token.
        /// </summary>
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.type,
                2 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.ArrayTypeSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitArrayType(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitArrayType(this);

        public ArrayTypeSyntax Update(SyntaxToken openBraceToken, TypeSyntax type, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || type != this.Type || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.ArrayType(openBraceToken, type, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArrayTypeSyntax(this.Kind, this.openBraceToken, this.type, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArrayTypeSyntax(this.Kind, this.openBraceToken, this.type, this.closeBraceToken, GetDiagnostics(), annotations);

        internal ArrayTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeBraceToken);
        }

        static ArrayTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArrayTypeSyntax), r => new ArrayTypeSyntax(r));
        }
    }

    /// <summary>This node represents a type inside of a table type.</summary>
    internal abstract partial class TableTypeElementSyntax : LuaSyntaxNode
    {
        internal TableTypeElementSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal TableTypeElementSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected TableTypeElementSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>This node represents a table type indexer.</summary>
    internal sealed partial class TableTypeIndexerSyntax : TableTypeElementSyntax
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly TypeSyntax indexType;
        internal readonly SyntaxToken closeBracketToken;
        internal readonly SyntaxToken colonToken;
        internal readonly TypeSyntax valueType;

        internal TableTypeIndexerSyntax(SyntaxKind kind, SyntaxToken openBracketToken, TypeSyntax indexType, SyntaxToken closeBracketToken, SyntaxToken colonToken, TypeSyntax valueType, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(indexType);
            this.indexType = indexType;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(valueType);
            this.valueType = valueType;
        }

        internal TableTypeIndexerSyntax(SyntaxKind kind, SyntaxToken openBracketToken, TypeSyntax indexType, SyntaxToken closeBracketToken, SyntaxToken colonToken, TypeSyntax valueType)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(indexType);
            this.indexType = indexType;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(valueType);
            this.valueType = valueType;
        }

        /// <summary>The open bracket token.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        /// <summary>The type's index</summary>
        public TypeSyntax IndexType => this.indexType;
        /// <summary>The close bracket token.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;
        /// <summary>The colon token.</summary>
        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>The type's value</summary>
        public TypeSyntax ValueType => this.valueType;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.indexType,
                2 => this.closeBracketToken,
                3 => this.colonToken,
                4 => this.valueType,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TableTypeIndexerSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTableTypeIndexer(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTableTypeIndexer(this);

        public TableTypeIndexerSyntax Update(SyntaxToken openBracketToken, TypeSyntax indexType, SyntaxToken closeBracketToken, SyntaxToken colonToken, TypeSyntax valueType)
        {
            if (openBracketToken != this.OpenBracketToken || indexType != this.IndexType || closeBracketToken != this.CloseBracketToken || colonToken != this.ColonToken || valueType != this.ValueType)
            {
                var newNode = SyntaxFactory.TableTypeIndexer(openBracketToken, indexType, closeBracketToken, colonToken, valueType);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TableTypeIndexerSyntax(this.Kind, this.openBracketToken, this.indexType, this.closeBracketToken, this.colonToken, this.valueType, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TableTypeIndexerSyntax(this.Kind, this.openBracketToken, this.indexType, this.closeBracketToken, this.colonToken, this.valueType, GetDiagnostics(), annotations);

        internal TableTypeIndexerSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var indexType = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(indexType);
            this.indexType = indexType;
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var valueType = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(valueType);
            this.valueType = valueType;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.indexType);
            writer.WriteValue(this.closeBracketToken);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.valueType);
        }

        static TableTypeIndexerSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TableTypeIndexerSyntax), r => new TableTypeIndexerSyntax(r));
        }
    }

    /// <summary>This node represents a table type property.</summary>
    internal sealed partial class TableTypePropertySyntax : TableTypeElementSyntax
    {
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken colonToken;
        internal readonly TypeSyntax valueType;

        internal TableTypePropertySyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, TypeSyntax valueType, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(valueType);
            this.valueType = valueType;
        }

        internal TableTypePropertySyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, TypeSyntax valueType)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(valueType);
            this.valueType = valueType;
        }

        /// <summary>The type's index</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>The colon token.</summary>
        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>The type's value</summary>
        public TypeSyntax ValueType => this.valueType;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.colonToken,
                2 => this.valueType,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TableTypePropertySyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTableTypeProperty(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTableTypeProperty(this);

        public TableTypePropertySyntax Update(SyntaxToken identifier, SyntaxToken colonToken, TypeSyntax valueType)
        {
            if (identifier != this.Identifier || colonToken != this.ColonToken || valueType != this.ValueType)
            {
                var newNode = SyntaxFactory.TableTypeProperty(identifier, colonToken, valueType);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TableTypePropertySyntax(this.Kind, this.identifier, this.colonToken, this.valueType, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TableTypePropertySyntax(this.Kind, this.identifier, this.colonToken, this.valueType, GetDiagnostics(), annotations);

        internal TableTypePropertySyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var valueType = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(valueType);
            this.valueType = valueType;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.valueType);
        }

        static TableTypePropertySyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TableTypePropertySyntax), r => new TableTypePropertySyntax(r));
        }
    }

    /// <summary>This node represents a table type.</summary>
    internal sealed partial class TableTypeSyntax : TableBasedTypeSyntax
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? elements;
        internal readonly SyntaxToken closeBraceToken;

        internal TableTypeSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? elements, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (elements != null)
            {
                this.AdjustFlagsAndWidth(elements);
                this.elements = elements;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal TableTypeSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? elements, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (elements != null)
            {
                this.AdjustFlagsAndWidth(elements);
                this.elements = elements;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        /// <summary>
        /// Gets the <c>{</c> token.
        /// </summary>
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        /// <summary>Gets the list of table properties and/or a single indexer.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TableTypeElementSyntax> Elements => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TableTypeElementSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.elements));
        /// <summary>
        /// Gets the <c>}</c> token.
        /// </summary>
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.elements,
                2 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TableTypeSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTableType(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTableType(this);

        public TableTypeSyntax Update(SyntaxToken openBraceToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TableTypeElementSyntax> elements, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || elements != this.Elements || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.TableType(openBraceToken, elements, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TableTypeSyntax(this.Kind, this.openBraceToken, this.elements, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TableTypeSyntax(this.Kind, this.openBraceToken, this.elements, this.closeBraceToken, GetDiagnostics(), annotations);

        internal TableTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var elements = (GreenNode?)reader.ReadValue();
            if (elements != null)
            {
                AdjustFlagsAndWidth(elements);
                this.elements = elements;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.elements);
            writer.WriteValue(this.closeBraceToken);
        }

        static TableTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TableTypeSyntax), r => new TableTypeSyntax(r));
        }
    }

    /// <summary>This node represents a type cast expression.</summary>
    internal sealed partial class TypeCastExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken colonColonToken;
        internal readonly TypeSyntax type;

        internal TypeCastExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken colonColonToken, TypeSyntax type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(colonColonToken);
            this.colonColonToken = colonColonToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal TypeCastExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken colonColonToken, TypeSyntax type)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(colonColonToken);
            this.colonColonToken = colonColonToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        /// <summary>Gets the expression being cast to another type.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>
        /// Gets the <c>::</c> operator token.
        /// </summary>
        public SyntaxToken ColonColonToken => this.colonColonToken;
        /// <summary>Gets the type the expression is being cast to.</summary>
        public TypeSyntax Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.colonColonToken,
                2 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TypeCastExpressionSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeCastExpression(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeCastExpression(this);

        public TypeCastExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken colonColonToken, TypeSyntax type)
        {
            if (expression != this.Expression || colonColonToken != this.ColonColonToken || type != this.Type)
            {
                var newNode = SyntaxFactory.TypeCastExpression(expression, colonColonToken, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeCastExpressionSyntax(this.Kind, this.expression, this.colonColonToken, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeCastExpressionSyntax(this.Kind, this.expression, this.colonColonToken, this.type, GetDiagnostics(), annotations);

        internal TypeCastExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var colonColonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonColonToken);
            this.colonColonToken = colonColonToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.colonColonToken);
            writer.WriteValue(this.type);
        }

        static TypeCastExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeCastExpressionSyntax), r => new TypeCastExpressionSyntax(r));
        }
    }

    /// <summary>This node represents a union type.</summary>
    internal sealed partial class UnionTypeSyntax : TypeSyntax
    {
        internal readonly TypeSyntax left;
        internal readonly SyntaxToken pipeToken;
        internal readonly TypeSyntax right;

        internal UnionTypeSyntax(SyntaxKind kind, TypeSyntax left, SyntaxToken pipeToken, TypeSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(pipeToken);
            this.pipeToken = pipeToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal UnionTypeSyntax(SyntaxKind kind, TypeSyntax left, SyntaxToken pipeToken, TypeSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(pipeToken);
            this.pipeToken = pipeToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        /// <summary>Gets the type on the left side of the operator.</summary>
        public TypeSyntax Left => this.left;
        /// <summary>
        /// Gets the <c>|</c> operator token.
        /// </summary>
        public SyntaxToken PipeToken => this.pipeToken;
        /// <summary>Gets the type on the right side of the operator.</summary>
        public TypeSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.pipeToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.UnionTypeSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitUnionType(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitUnionType(this);

        public UnionTypeSyntax Update(TypeSyntax left, SyntaxToken pipeToken, TypeSyntax right)
        {
            if (left != this.Left || pipeToken != this.PipeToken || right != this.Right)
            {
                var newNode = SyntaxFactory.UnionType(left, pipeToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UnionTypeSyntax(this.Kind, this.left, this.pipeToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UnionTypeSyntax(this.Kind, this.left, this.pipeToken, this.right, GetDiagnostics(), annotations);

        internal UnionTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var pipeToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(pipeToken);
            this.pipeToken = pipeToken;
            var right = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.pipeToken);
            writer.WriteValue(this.right);
        }

        static UnionTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UnionTypeSyntax), r => new UnionTypeSyntax(r));
        }
    }

    /// <summary>This node represents an intersection type.</summary>
    internal sealed partial class IntersectionTypeSyntax : TypeSyntax
    {
        internal readonly TypeSyntax left;
        internal readonly SyntaxToken ampersandToken;
        internal readonly TypeSyntax right;

        internal IntersectionTypeSyntax(SyntaxKind kind, TypeSyntax left, SyntaxToken ampersandToken, TypeSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(ampersandToken);
            this.ampersandToken = ampersandToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal IntersectionTypeSyntax(SyntaxKind kind, TypeSyntax left, SyntaxToken ampersandToken, TypeSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(ampersandToken);
            this.ampersandToken = ampersandToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        /// <summary>Gets the type on the left side of the operator.</summary>
        public TypeSyntax Left => this.left;
        /// <summary>
        /// Gets the <c>&amp;</c> operator token.
        /// </summary>
        public SyntaxToken AmpersandToken => this.ampersandToken;
        /// <summary>Gets the type on the right side of the operator.</summary>
        public TypeSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.ampersandToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.IntersectionTypeSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIntersectionType(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitIntersectionType(this);

        public IntersectionTypeSyntax Update(TypeSyntax left, SyntaxToken ampersandToken, TypeSyntax right)
        {
            if (left != this.Left || ampersandToken != this.AmpersandToken || right != this.Right)
            {
                var newNode = SyntaxFactory.IntersectionType(left, ampersandToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IntersectionTypeSyntax(this.Kind, this.left, this.ampersandToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IntersectionTypeSyntax(this.Kind, this.left, this.ampersandToken, this.right, GetDiagnostics(), annotations);

        internal IntersectionTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var ampersandToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(ampersandToken);
            this.ampersandToken = ampersandToken;
            var right = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.ampersandToken);
            writer.WriteValue(this.right);
        }

        static IntersectionTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IntersectionTypeSyntax), r => new IntersectionTypeSyntax(r));
        }
    }

    /// <summary>This node represents the default type value of a type parameter.</summary>
    internal sealed partial class EqualsTypeSyntax : LuaSyntaxNode
    {
        internal readonly SyntaxToken equalsToken;
        internal readonly TypeSyntax type;

        internal EqualsTypeSyntax(SyntaxKind kind, SyntaxToken equalsToken, TypeSyntax type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal EqualsTypeSyntax(SyntaxKind kind, SyntaxToken equalsToken, TypeSyntax type)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        /// <c>=</c>
        public SyntaxToken EqualsToken => this.equalsToken;
        /// <summary>Gets the type value.</summary>
        public TypeSyntax Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.equalsToken,
                1 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.EqualsTypeSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitEqualsType(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitEqualsType(this);

        public EqualsTypeSyntax Update(SyntaxToken equalsToken, TypeSyntax type)
        {
            if (equalsToken != this.EqualsToken || type != this.Type)
            {
                var newNode = SyntaxFactory.EqualsType(equalsToken, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EqualsTypeSyntax(this.Kind, this.equalsToken, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EqualsTypeSyntax(this.Kind, this.equalsToken, this.type, GetDiagnostics(), annotations);

        internal EqualsTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.type);
        }

        static EqualsTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EqualsTypeSyntax), r => new EqualsTypeSyntax(r));
        }
    }

    /// <summary>This node represents a type parameter.</summary>
    internal sealed partial class TypeParameterSyntax : LuaSyntaxNode
    {
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken? dotDotDotToken;
        internal readonly EqualsTypeSyntax? equalsType;

        internal TypeParameterSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken? dotDotDotToken, EqualsTypeSyntax? equalsType, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (dotDotDotToken != null)
            {
                this.AdjustFlagsAndWidth(dotDotDotToken);
                this.dotDotDotToken = dotDotDotToken;
            }
            if (equalsType != null)
            {
                this.AdjustFlagsAndWidth(equalsType);
                this.equalsType = equalsType;
            }
        }

        internal TypeParameterSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken? dotDotDotToken, EqualsTypeSyntax? equalsType)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (dotDotDotToken != null)
            {
                this.AdjustFlagsAndWidth(dotDotDotToken);
                this.dotDotDotToken = dotDotDotToken;
            }
            if (equalsType != null)
            {
                this.AdjustFlagsAndWidth(equalsType);
                this.equalsType = equalsType;
            }
        }

        /// <summary>Gets the type parameter name identifier token.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>
        /// Gets the <c>...</c> token (if this type parameter is a type pack).
        /// </summary>
        public SyntaxToken? DotDotDotToken => this.dotDotDotToken;
        public EqualsTypeSyntax? EqualsType => this.equalsType;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.dotDotDotToken,
                2 => this.equalsType,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TypeParameterSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeParameter(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeParameter(this);

        public TypeParameterSyntax Update(SyntaxToken identifier, SyntaxToken dotDotDotToken, EqualsTypeSyntax equalsType)
        {
            if (identifier != this.Identifier || dotDotDotToken != this.DotDotDotToken || equalsType != this.EqualsType)
            {
                var newNode = SyntaxFactory.TypeParameter(identifier, dotDotDotToken, equalsType);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeParameterSyntax(this.Kind, this.identifier, this.dotDotDotToken, this.equalsType, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeParameterSyntax(this.Kind, this.identifier, this.dotDotDotToken, this.equalsType, GetDiagnostics(), annotations);

        internal TypeParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var dotDotDotToken = (SyntaxToken?)reader.ReadValue();
            if (dotDotDotToken != null)
            {
                AdjustFlagsAndWidth(dotDotDotToken);
                this.dotDotDotToken = dotDotDotToken;
            }
            var equalsType = (EqualsTypeSyntax?)reader.ReadValue();
            if (equalsType != null)
            {
                AdjustFlagsAndWidth(equalsType);
                this.equalsType = equalsType;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.dotDotDotToken);
            writer.WriteValue(this.equalsType);
        }

        static TypeParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeParameterSyntax), r => new TypeParameterSyntax(r));
        }
    }

    /// <summary>This node represents a type parameter list.</summary>
    internal sealed partial class TypeParameterListSyntax : LuaSyntaxNode
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly GreenNode? names;
        internal readonly SyntaxToken greaterThanToken;

        internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? names, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? names, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (names != null)
            {
                this.AdjustFlagsAndWidth(names);
                this.names = names;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        /// <summary>
        /// Gets the <c>&lt;</c> token.
        /// </summary>
        public SyntaxToken LessThanToken => this.lessThanToken;
        /// <summary>A list of types.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> Names => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.names));
        /// <summary>
        /// Gets the <c>&gt;</c> token.
        /// </summary>
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.names,
                2 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TypeParameterListSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeParameterList(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeParameterList(this);

        public TypeParameterListSyntax Update(SyntaxToken lessThanToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> names, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || names != this.Names || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.TypeParameterList(lessThanToken, names, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.names, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.names, this.greaterThanToken, GetDiagnostics(), annotations);

        internal TypeParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var names = (GreenNode?)reader.ReadValue();
            if (names != null)
            {
                AdjustFlagsAndWidth(names);
                this.names = names;
            }
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.names);
            writer.WriteValue(this.greaterThanToken);
        }

        static TypeParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeParameterListSyntax), r => new TypeParameterListSyntax(r));
        }
    }

    /// <summary>This node represents a type argument list.</summary>
    internal sealed partial class TypeArgumentListSyntax : LuaSyntaxNode
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly GreenNode? arguments;
        internal readonly SyntaxToken greaterThanToken;

        internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? arguments, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? arguments, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        /// <summary>
        /// Gets the <c>&lt;</c> token.
        /// </summary>
        public SyntaxToken LessThanToken => this.lessThanToken;
        /// <summary>A list of types.</summary>
        public Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> Arguments => new Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax>(new Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<LuaSyntaxNode>(this.arguments));
        /// <summary>
        /// Gets the <c>&gt;</c> token.
        /// </summary>
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.arguments,
                2 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TypeArgumentListSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeArgumentList(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeArgumentList(this);

        public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, GetDiagnostics(), annotations);

        internal TypeArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var arguments = (GreenNode?)reader.ReadValue();
            if (arguments != null)
            {
                AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.greaterThanToken);
        }

        static TypeArgumentListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeArgumentListSyntax), r => new TypeArgumentListSyntax(r));
        }
    }

    /// <summary>Represents a literal-based singleton type.</summary>
    internal sealed partial class LiteralTypeSyntax : TypeSyntax
    {
        internal readonly SyntaxToken token;

        internal LiteralTypeSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal LiteralTypeSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        /// <summary>The literal token.</summary>
        public SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.LiteralTypeSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLiteralType(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitLiteralType(this);

        public LiteralTypeSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralType(this.Kind, token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LiteralTypeSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LiteralTypeSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal LiteralTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static LiteralTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LiteralTypeSyntax), r => new LiteralTypeSyntax(r));
        }
    }

    /// <summary>This node represents a typeof type.</summary>
    internal sealed partial class TypeofTypeSyntax : TypeSyntax
    {
        internal readonly SyntaxToken typeofKeyword;
        internal readonly SyntaxToken openParenthesisToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeParenthesisToken;

        internal TypeofTypeSyntax(SyntaxKind kind, SyntaxToken typeofKeyword, SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(typeofKeyword);
            this.typeofKeyword = typeofKeyword;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal TypeofTypeSyntax(SyntaxKind kind, SyntaxToken typeofKeyword, SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(typeofKeyword);
            this.typeofKeyword = typeofKeyword;
            this.AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        /// <summary>The typeof keyword.</summary>
        public SyntaxToken TypeofKeyword => this.typeofKeyword;
        /// <summary>The open parenthesis token.</summary>
        public SyntaxToken OpenParenthesisToken => this.openParenthesisToken;
        /// <summary>The typeof call's expression</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>The close parenthesis token.</summary>
        public SyntaxToken CloseParenthesisToken => this.closeParenthesisToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.typeofKeyword,
                1 => this.openParenthesisToken,
                2 => this.expression,
                3 => this.closeParenthesisToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.TypeofTypeSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeofType(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitTypeofType(this);

        public TypeofTypeSyntax Update(SyntaxToken typeofKeyword, SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken)
        {
            if (typeofKeyword != this.TypeofKeyword || openParenthesisToken != this.OpenParenthesisToken || expression != this.Expression || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.TypeofType(typeofKeyword, openParenthesisToken, expression, closeParenthesisToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeofTypeSyntax(this.Kind, this.typeofKeyword, this.openParenthesisToken, this.expression, this.closeParenthesisToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeofTypeSyntax(this.Kind, this.typeofKeyword, this.openParenthesisToken, this.expression, this.closeParenthesisToken, GetDiagnostics(), annotations);

        internal TypeofTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var typeofKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(typeofKeyword);
            this.typeofKeyword = typeofKeyword;
            var openParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenthesisToken);
            this.openParenthesisToken = openParenthesisToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenthesisToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenthesisToken);
            this.closeParenthesisToken = closeParenthesisToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.typeofKeyword);
            writer.WriteValue(this.openParenthesisToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenthesisToken);
        }

        static TypeofTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeofTypeSyntax), r => new TypeofTypeSyntax(r));
        }
    }

    /// <summary>This node represents a variadic type pack.</summary>
    internal sealed partial class VariadicTypePackSyntax : TypeSyntax
    {
        internal readonly SyntaxToken dotDotDotToken;
        internal readonly TypeSyntax type;

        internal VariadicTypePackSyntax(SyntaxKind kind, SyntaxToken dotDotDotToken, TypeSyntax type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(dotDotDotToken);
            this.dotDotDotToken = dotDotDotToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal VariadicTypePackSyntax(SyntaxKind kind, SyntaxToken dotDotDotToken, TypeSyntax type)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(dotDotDotToken);
            this.dotDotDotToken = dotDotDotToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        /// <summary>
        /// The <c>...</c> token.
        /// </summary>
        public SyntaxToken DotDotDotToken => this.dotDotDotToken;
        /// <summary>Gets the type the expression is being cast to.</summary>
        public TypeSyntax Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.dotDotDotToken,
                1 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.VariadicTypePackSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitVariadicTypePack(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitVariadicTypePack(this);

        public VariadicTypePackSyntax Update(SyntaxToken dotDotDotToken, TypeSyntax type)
        {
            if (dotDotDotToken != this.DotDotDotToken || type != this.Type)
            {
                var newNode = SyntaxFactory.VariadicTypePack(dotDotDotToken, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new VariadicTypePackSyntax(this.Kind, this.dotDotDotToken, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new VariadicTypePackSyntax(this.Kind, this.dotDotDotToken, this.type, GetDiagnostics(), annotations);

        internal VariadicTypePackSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var dotDotDotToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(dotDotDotToken);
            this.dotDotDotToken = dotDotDotToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.dotDotDotToken);
            writer.WriteValue(this.type);
        }

        static VariadicTypePackSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(VariadicTypePackSyntax), r => new VariadicTypePackSyntax(r));
        }
    }

    /// <summary>This node represents a generic type pack.</summary>
    internal sealed partial class GenericTypePackSyntax : TypeSyntax
    {
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken dotDotDotToken;

        internal GenericTypePackSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken dotDotDotToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(dotDotDotToken);
            this.dotDotDotToken = dotDotDotToken;
        }

        internal GenericTypePackSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken dotDotDotToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(dotDotDotToken);
            this.dotDotDotToken = dotDotDotToken;
        }

        /// <summary>The identifier token.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>
        /// The <c>...</c> token.
        /// </summary>
        public SyntaxToken DotDotDotToken => this.dotDotDotToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.dotDotDotToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.GenericTypePackSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitGenericTypePack(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitGenericTypePack(this);

        public GenericTypePackSyntax Update(SyntaxToken identifier, SyntaxToken dotDotDotToken)
        {
            if (identifier != this.Identifier || dotDotDotToken != this.DotDotDotToken)
            {
                var newNode = SyntaxFactory.GenericTypePack(identifier, dotDotDotToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new GenericTypePackSyntax(this.Kind, this.identifier, this.dotDotDotToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new GenericTypePackSyntax(this.Kind, this.identifier, this.dotDotDotToken, GetDiagnostics(), annotations);

        internal GenericTypePackSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var dotDotDotToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(dotDotDotToken);
            this.dotDotDotToken = dotDotDotToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.dotDotDotToken);
        }

        static GenericTypePackSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(GenericTypePackSyntax), r => new GenericTypePackSyntax(r));
        }
    }

    /// <summary>The node containing all of the file's contents.</summary>
    internal sealed partial class CompilationUnitSyntax : LuaSyntaxNode
    {
        internal readonly StatementListSyntax statements;
        internal readonly SyntaxToken endOfFileToken;

        internal CompilationUnitSyntax(SyntaxKind kind, StatementListSyntax statements, SyntaxToken endOfFileToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal CompilationUnitSyntax(SyntaxKind kind, StatementListSyntax statements, SyntaxToken endOfFileToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        /// <summary>The statements in the compilation unit.</summary>
        public StatementListSyntax Statements => this.statements;
        /// <summary>The end-of-file token.</summary>
        public SyntaxToken EndOfFileToken => this.endOfFileToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.statements,
                1 => this.endOfFileToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new Lua.Syntax.CompilationUnitSyntax(this, parent, position);

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitCompilationUnit(this);
        public override TResult Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) => visitor.VisitCompilationUnit(this);

        public CompilationUnitSyntax Update(StatementListSyntax statements, SyntaxToken endOfFileToken)
        {
            if (statements != this.Statements || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.CompilationUnit(statements, endOfFileToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CompilationUnitSyntax(this.Kind, this.statements, this.endOfFileToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CompilationUnitSyntax(this.Kind, this.statements, this.endOfFileToken, GetDiagnostics(), annotations);

        internal CompilationUnitSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var statements = (StatementListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statements);
            this.statements = statements;
            var endOfFileToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.statements);
            writer.WriteValue(this.endOfFileToken);
        }

        static CompilationUnitSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CompilationUnitSyntax), r => new CompilationUnitSyntax(r));
        }
    }

    internal partial class LuaSyntaxVisitor<TResult>
    {
        public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitStatementList(StatementListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNamedParameter(NamedParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitVarArgParameter(VarArgParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIdentifierKeyedTableField(IdentifierKeyedTableFieldSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitExpressionKeyedTableField(ExpressionKeyedTableFieldSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUnkeyedTableField(UnkeyedTableFieldSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSimpleFunctionName(SimpleFunctionNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitMemberFunctionName(MemberFunctionNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitMethodFunctionName(MethodFunctionNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitStringFunctionArgument(StringFunctionArgumentSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTableConstructorFunctionArgument(TableConstructorFunctionArgumentSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitExpressionListFunctionArgument(ExpressionListFunctionArgumentSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolation(InterpolationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAnonymousFunctionExpression(AnonymousFunctionExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTableConstructorExpression(TableConstructorExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitVarArgExpression(VarArgExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUnaryExpression(UnaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitElseIfExpressionClause(ElseIfExpressionClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIfExpression(IfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFunctionCallExpression(FunctionCallExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitMethodCallExpression(MethodCallExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitVariableAttribute(VariableAttributeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLocalDeclarationName(LocalDeclarationNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEqualsValuesClause(EqualsValuesClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAssignmentStatement(AssignmentStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCompoundAssignmentStatement(CompoundAssignmentStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLocalVariableDeclarationStatement(LocalVariableDeclarationStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypedIdentifierName(TypedIdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNumericForStatement(NumericForStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitGenericForStatement(GenericForStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitRepeatUntilStatement(RepeatUntilStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitElseIfClause(ElseIfClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitGotoStatement(GotoStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitReturnStatement(ReturnStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitContinueStatement(ContinueStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFunctionDeclarationStatement(FunctionDeclarationStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitGotoLabelStatement(GotoLabelStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeDeclarationStatement(TypeDeclarationStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeBinding(TypeBindingSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSimpleTypeName(SimpleTypeNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCompositeTypeName(CompositeTypeNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNilableType(NilableTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParenthesizedType(ParenthesizedTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypePack(TypePackSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFunctionType(FunctionTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArrayType(ArrayTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTableTypeIndexer(TableTypeIndexerSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTableTypeProperty(TableTypePropertySyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTableType(TableTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeCastExpression(TypeCastExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUnionType(UnionTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIntersectionType(IntersectionTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEqualsType(EqualsTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeParameter(TypeParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLiteralType(LiteralTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeofType(TypeofTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitVariadicTypePack(VariadicTypePackSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitGenericTypePack(GenericTypePackSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node) => this.DefaultVisit(node);
    }

    internal partial class LuaSyntaxVisitor
    {
        public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitStatementList(StatementListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNamedParameter(NamedParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitVarArgParameter(VarArgParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIdentifierKeyedTableField(IdentifierKeyedTableFieldSyntax node) => this.DefaultVisit(node);
        public virtual void VisitExpressionKeyedTableField(ExpressionKeyedTableFieldSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUnkeyedTableField(UnkeyedTableFieldSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSimpleFunctionName(SimpleFunctionNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitMemberFunctionName(MemberFunctionNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitMethodFunctionName(MethodFunctionNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitStringFunctionArgument(StringFunctionArgumentSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTableConstructorFunctionArgument(TableConstructorFunctionArgumentSyntax node) => this.DefaultVisit(node);
        public virtual void VisitExpressionListFunctionArgument(ExpressionListFunctionArgumentSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterpolation(InterpolationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAnonymousFunctionExpression(AnonymousFunctionExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTableConstructorExpression(TableConstructorExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitVarArgExpression(VarArgExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUnaryExpression(UnaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitElseIfExpressionClause(ElseIfExpressionClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIfExpression(IfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFunctionCallExpression(FunctionCallExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitMethodCallExpression(MethodCallExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitVariableAttribute(VariableAttributeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLocalDeclarationName(LocalDeclarationNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEqualsValuesClause(EqualsValuesClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAssignmentStatement(AssignmentStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCompoundAssignmentStatement(CompoundAssignmentStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLocalVariableDeclarationStatement(LocalVariableDeclarationStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypedIdentifierName(TypedIdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNumericForStatement(NumericForStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitGenericForStatement(GenericForStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitRepeatUntilStatement(RepeatUntilStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitElseIfClause(ElseIfClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitGotoStatement(GotoStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitReturnStatement(ReturnStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitContinueStatement(ContinueStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFunctionDeclarationStatement(FunctionDeclarationStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitGotoLabelStatement(GotoLabelStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitExpressionStatement(ExpressionStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEmptyStatement(EmptyStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeDeclarationStatement(TypeDeclarationStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeBinding(TypeBindingSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSimpleTypeName(SimpleTypeNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCompositeTypeName(CompositeTypeNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNilableType(NilableTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParenthesizedType(ParenthesizedTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypePack(TypePackSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFunctionType(FunctionTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArrayType(ArrayTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTableTypeIndexer(TableTypeIndexerSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTableTypeProperty(TableTypePropertySyntax node) => this.DefaultVisit(node);
        public virtual void VisitTableType(TableTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeCastExpression(TypeCastExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUnionType(UnionTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIntersectionType(IntersectionTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEqualsType(EqualsTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeParameter(TypeParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeParameterList(TypeParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLiteralType(LiteralTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeofType(TypeofTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitVariadicTypePack(VariadicTypePackSyntax node) => this.DefaultVisit(node);
        public virtual void VisitGenericTypePack(GenericTypePackSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCompilationUnit(CompilationUnitSyntax node) => this.DefaultVisit(node);
    }

    internal partial class LuaSyntaxRewriter : LuaSyntaxVisitor<LuaSyntaxNode>
    {
        public override LuaSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
            => node.Update(VisitList(node.Tokens));

        public override LuaSyntaxNode VisitStatementList(StatementListSyntax node)
            => node.Update(VisitList(node.Statements));

        public override LuaSyntaxNode VisitNamedParameter(NamedParameterSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (TypeBindingSyntax)Visit(node.TypeBinding));

        public override LuaSyntaxNode VisitVarArgParameter(VarArgParameterSyntax node)
            => node.Update((SyntaxToken)Visit(node.VarArgToken), (TypeBindingSyntax)Visit(node.TypeBinding));

        public override LuaSyntaxNode VisitParameterList(ParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenthesisToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.CloseParenthesisToken));

        public override LuaSyntaxNode VisitIdentifierKeyedTableField(IdentifierKeyedTableFieldSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.Value));

        public override LuaSyntaxNode VisitExpressionKeyedTableField(ExpressionKeyedTableFieldSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), (ExpressionSyntax)Visit(node.Key), (SyntaxToken)Visit(node.CloseBracketToken), (SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.Value));

        public override LuaSyntaxNode VisitUnkeyedTableField(UnkeyedTableFieldSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Value));

        public override LuaSyntaxNode VisitSimpleFunctionName(SimpleFunctionNameSyntax node)
            => node.Update((SyntaxToken)Visit(node.Name));

        public override LuaSyntaxNode VisitMemberFunctionName(MemberFunctionNameSyntax node)
            => node.Update((FunctionNameSyntax)Visit(node.BaseName), (SyntaxToken)Visit(node.DotToken), (SyntaxToken)Visit(node.Name));

        public override LuaSyntaxNode VisitMethodFunctionName(MethodFunctionNameSyntax node)
            => node.Update((FunctionNameSyntax)Visit(node.BaseName), (SyntaxToken)Visit(node.ColonToken), (SyntaxToken)Visit(node.Name));

        public override LuaSyntaxNode VisitStringFunctionArgument(StringFunctionArgumentSyntax node)
            => node.Update((LiteralExpressionSyntax)Visit(node.Expression));

        public override LuaSyntaxNode VisitTableConstructorFunctionArgument(TableConstructorFunctionArgumentSyntax node)
            => node.Update((TableConstructorExpressionSyntax)Visit(node.TableConstructor));

        public override LuaSyntaxNode VisitExpressionListFunctionArgument(ExpressionListFunctionArgumentSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenthesisToken), VisitList(node.Expressions), (SyntaxToken)Visit(node.CloseParenthesisToken));

        public override LuaSyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
            => node.Update((SyntaxToken)Visit(node.TextToken));

        public override LuaSyntaxNode VisitInterpolation(InterpolationSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseBraceToken));

        public override LuaSyntaxNode VisitAnonymousFunctionExpression(AnonymousFunctionExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.FunctionKeyword), (TypeParameterListSyntax)Visit(node.TypeParameterList), (ParameterListSyntax)Visit(node.Parameters), (TypeBindingSyntax)Visit(node.TypeBinding), (StatementListSyntax)Visit(node.Body), (SyntaxToken)Visit(node.EndKeyword));

        public override LuaSyntaxNode VisitTableConstructorExpression(TableConstructorExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Fields), (SyntaxToken)Visit(node.CloseBraceToken));

        public override LuaSyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override LuaSyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.StringStartToken), VisitList(node.Contents), (SyntaxToken)Visit(node.StringEndToken));

        public override LuaSyntaxNode VisitVarArgExpression(VarArgExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.VarArgToken));

        public override LuaSyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier));

        public override LuaSyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
            => node.Update((PrefixExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.DotSeparator), (SyntaxToken)Visit(node.MemberName));

        public override LuaSyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)
            => node.Update((PrefixExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.OpenBracketToken), (ExpressionSyntax)Visit(node.KeyExpression), (SyntaxToken)Visit(node.CloseBracketToken));

        public override LuaSyntaxNode VisitUnaryExpression(UnaryExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OperatorToken), (ExpressionSyntax)Visit(node.Operand));

        public override LuaSyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Left), (SyntaxToken)Visit(node.OperatorToken), (ExpressionSyntax)Visit(node.Right));

        public override LuaSyntaxNode VisitElseIfExpressionClause(ElseIfExpressionClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ElseIfKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.ThenKeyword), (ExpressionSyntax)Visit(node.Value));

        public override LuaSyntaxNode VisitIfExpression(IfExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.IfKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.ThenKeyword), (ExpressionSyntax)Visit(node.TrueValue), VisitList(node.ElseIfClauses), (SyntaxToken)Visit(node.ElseKeyword), (ExpressionSyntax)Visit(node.FalseValue));

        public override LuaSyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenthesisToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenthesisToken));

        public override LuaSyntaxNode VisitFunctionCallExpression(FunctionCallExpressionSyntax node)
            => node.Update((PrefixExpressionSyntax)Visit(node.Expression), (FunctionArgumentSyntax)Visit(node.Argument));

        public override LuaSyntaxNode VisitMethodCallExpression(MethodCallExpressionSyntax node)
            => node.Update((PrefixExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.ColonToken), (SyntaxToken)Visit(node.Identifier), (FunctionArgumentSyntax)Visit(node.Argument));

        public override LuaSyntaxNode VisitVariableAttribute(VariableAttributeSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.GreaterThanToken));

        public override LuaSyntaxNode VisitLocalDeclarationName(LocalDeclarationNameSyntax node)
            => node.Update((IdentifierNameSyntax)Visit(node.IdentifierName), (VariableAttributeSyntax)Visit(node.Attribute), (TypeBindingSyntax)Visit(node.TypeBinding));

        public override LuaSyntaxNode VisitEqualsValuesClause(EqualsValuesClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.EqualsToken), VisitList(node.Values));

        public override LuaSyntaxNode VisitAssignmentStatement(AssignmentStatementSyntax node)
            => node.Update(VisitList(node.Variables), (EqualsValuesClauseSyntax)Visit(node.EqualsValues), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitCompoundAssignmentStatement(CompoundAssignmentStatementSyntax node)
            => node.Update((PrefixExpressionSyntax)Visit(node.Variable), (SyntaxToken)Visit(node.AssignmentOperatorToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitLocalVariableDeclarationStatement(LocalVariableDeclarationStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.LocalKeyword), VisitList(node.Names), (EqualsValuesClauseSyntax)Visit(node.EqualsValues), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitTypedIdentifierName(TypedIdentifierNameSyntax node)
            => node.Update((IdentifierNameSyntax)Visit(node.IdentifierName), (TypeBindingSyntax)Visit(node.TypeBinding));

        public override LuaSyntaxNode VisitNumericForStatement(NumericForStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), (TypedIdentifierNameSyntax)Visit(node.Identifier), (SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.InitialValue), (SyntaxToken)Visit(node.FinalValueCommaToken), (ExpressionSyntax)Visit(node.FinalValue), (SyntaxToken)Visit(node.StepValueCommaToken), (ExpressionSyntax)Visit(node.StepValue), (SyntaxToken)Visit(node.DoKeyword), (StatementListSyntax)Visit(node.Body), (SyntaxToken)Visit(node.EndKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitGenericForStatement(GenericForStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.ForKeyword), VisitList(node.Identifiers), (SyntaxToken)Visit(node.InKeyword), VisitList(node.Expressions), (SyntaxToken)Visit(node.DoKeyword), (StatementListSyntax)Visit(node.Body), (SyntaxToken)Visit(node.EndKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitWhileStatement(WhileStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.WhileKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.DoKeyword), (StatementListSyntax)Visit(node.Body), (SyntaxToken)Visit(node.EndKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitRepeatUntilStatement(RepeatUntilStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.RepeatKeyword), (StatementListSyntax)Visit(node.Body), (SyntaxToken)Visit(node.UntilKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitIfStatement(IfStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.IfKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.ThenKeyword), (StatementListSyntax)Visit(node.Body), VisitList(node.ElseIfClauses), (ElseClauseSyntax)Visit(node.ElseClause), (SyntaxToken)Visit(node.EndKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitElseIfClause(ElseIfClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ElseIfKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.ThenKeyword), (StatementListSyntax)Visit(node.Body));

        public override LuaSyntaxNode VisitElseClause(ElseClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ElseKeyword), (StatementListSyntax)Visit(node.ElseBody));

        public override LuaSyntaxNode VisitGotoStatement(GotoStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.GotoKeyword), (SyntaxToken)Visit(node.LabelName), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitBreakStatement(BreakStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.BreakKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.ReturnKeyword), VisitList(node.Expressions), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.ContinueKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.LocalKeyword), (SyntaxToken)Visit(node.FunctionKeyword), (IdentifierNameSyntax)Visit(node.Name), (TypeParameterListSyntax)Visit(node.TypeParameterList), (ParameterListSyntax)Visit(node.Parameters), (TypeBindingSyntax)Visit(node.TypeBinding), (StatementListSyntax)Visit(node.Body), (SyntaxToken)Visit(node.EndKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitFunctionDeclarationStatement(FunctionDeclarationStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.FunctionKeyword), (FunctionNameSyntax)Visit(node.Name), (TypeParameterListSyntax)Visit(node.TypeParameterList), (ParameterListSyntax)Visit(node.Parameters), (TypeBindingSyntax)Visit(node.TypeBinding), (StatementListSyntax)Visit(node.Body), (SyntaxToken)Visit(node.EndKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitDoStatement(DoStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.DoKeyword), (StatementListSyntax)Visit(node.Body), (SyntaxToken)Visit(node.EndKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitGotoLabelStatement(GotoLabelStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.LeftDelimiterToken), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.RightDelimiterToken), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitEmptyStatement(EmptyStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitTypeDeclarationStatement(TypeDeclarationStatementSyntax node)
            => node.Update((SyntaxToken)Visit(node.ExportKeyword), (SyntaxToken)Visit(node.TypeKeyword), (SyntaxToken)Visit(node.Name), (TypeParameterListSyntax)Visit(node.TypeParameterList), (SyntaxToken)Visit(node.EqualsToken), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.SemicolonToken));

        public override LuaSyntaxNode VisitTypeBinding(TypeBindingSyntax node)
            => node.Update((SyntaxToken)Visit(node.ColonToken), (TypeSyntax)Visit(node.Type));

        public override LuaSyntaxNode VisitSimpleTypeName(SimpleTypeNameSyntax node)
            => node.Update((SyntaxToken)Visit(node.IdentifierToken), (TypeArgumentListSyntax)Visit(node.TypeArgumentList));

        public override LuaSyntaxNode VisitCompositeTypeName(CompositeTypeNameSyntax node)
            => node.Update((TypeNameSyntax)Visit(node.Base), (SyntaxToken)Visit(node.DotToken), (SyntaxToken)Visit(node.IdentifierToken), (TypeArgumentListSyntax)Visit(node.TypeArgumentList));

        public override LuaSyntaxNode VisitNilableType(NilableTypeSyntax node)
            => node.Update((TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.QuestionToken));

        public override LuaSyntaxNode VisitParenthesizedType(ParenthesizedTypeSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenthesisToken), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.CloseParenthesisToken));

        public override LuaSyntaxNode VisitTypePack(TypePackSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenthesisToken), VisitList(node.Types), (SyntaxToken)Visit(node.CloseParenthesisToken));

        public override LuaSyntaxNode VisitFunctionType(FunctionTypeSyntax node)
            => node.Update((TypeParameterListSyntax)Visit(node.TypeParameterList), (SyntaxToken)Visit(node.OpenParenthesisToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.CloseParenthesisToken), (SyntaxToken)Visit(node.MinusGreaterThanToken), (TypeSyntax)Visit(node.ReturnType));

        public override LuaSyntaxNode VisitArrayType(ArrayTypeSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.CloseBraceToken));

        public override LuaSyntaxNode VisitTableTypeIndexer(TableTypeIndexerSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), (TypeSyntax)Visit(node.IndexType), (SyntaxToken)Visit(node.CloseBracketToken), (SyntaxToken)Visit(node.ColonToken), (TypeSyntax)Visit(node.ValueType));

        public override LuaSyntaxNode VisitTableTypeProperty(TableTypePropertySyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.ColonToken), (TypeSyntax)Visit(node.ValueType));

        public override LuaSyntaxNode VisitTableType(TableTypeSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Elements), (SyntaxToken)Visit(node.CloseBraceToken));

        public override LuaSyntaxNode VisitTypeCastExpression(TypeCastExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.ColonColonToken), (TypeSyntax)Visit(node.Type));

        public override LuaSyntaxNode VisitUnionType(UnionTypeSyntax node)
            => node.Update((TypeSyntax)Visit(node.Left), (SyntaxToken)Visit(node.PipeToken), (TypeSyntax)Visit(node.Right));

        public override LuaSyntaxNode VisitIntersectionType(IntersectionTypeSyntax node)
            => node.Update((TypeSyntax)Visit(node.Left), (SyntaxToken)Visit(node.AmpersandToken), (TypeSyntax)Visit(node.Right));

        public override LuaSyntaxNode VisitEqualsType(EqualsTypeSyntax node)
            => node.Update((SyntaxToken)Visit(node.EqualsToken), (TypeSyntax)Visit(node.Type));

        public override LuaSyntaxNode VisitTypeParameter(TypeParameterSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.DotDotDotToken), (EqualsTypeSyntax)Visit(node.EqualsType));

        public override LuaSyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), VisitList(node.Names), (SyntaxToken)Visit(node.GreaterThanToken));

        public override LuaSyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), VisitList(node.Arguments), (SyntaxToken)Visit(node.GreaterThanToken));

        public override LuaSyntaxNode VisitLiteralType(LiteralTypeSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override LuaSyntaxNode VisitTypeofType(TypeofTypeSyntax node)
            => node.Update((SyntaxToken)Visit(node.TypeofKeyword), (SyntaxToken)Visit(node.OpenParenthesisToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenthesisToken));

        public override LuaSyntaxNode VisitVariadicTypePack(VariadicTypePackSyntax node)
            => node.Update((SyntaxToken)Visit(node.DotDotDotToken), (TypeSyntax)Visit(node.Type));

        public override LuaSyntaxNode VisitGenericTypePack(GenericTypePackSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.DotDotDotToken));

        public override LuaSyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)
            => node.Update((StatementListSyntax)Visit(node.Statements), (SyntaxToken)Visit(node.EndOfFileToken));
    }

    internal static partial class SyntaxFactory
    {

        public static SkippedTokensTriviaSyntax SkippedTokensTrivia(Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
#if DEBUG
#endif

            return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node);
        }

        public static StatementListSyntax StatementList(Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.StatementList, statements.Node, out hash);
            if (cached != null) return (StatementListSyntax)cached;

            var result = new StatementListSyntax(SyntaxKind.StatementList, statements.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static NamedParameterSyntax NamedParameter(SyntaxToken identifier, TypeBindingSyntax? typeBinding)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind}.", nameof(identifier));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NamedParameter, identifier, typeBinding, out hash);
            if (cached != null) return (NamedParameterSyntax)cached;

            var result = new NamedParameterSyntax(SyntaxKind.NamedParameter, identifier, typeBinding);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static VarArgParameterSyntax VarArgParameter(SyntaxToken varArgToken, TypeBindingSyntax? typeBinding)
        {
#if DEBUG
            if (varArgToken == null) throw new ArgumentNullException(nameof(varArgToken));
            if (varArgToken.Kind != SyntaxKind.DotDotDotToken) throw new ArgumentException($"Invalid kind provided. Expected DotDotDotToken but got {varArgToken.Kind}.", nameof(varArgToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VarArgParameter, varArgToken, typeBinding, out hash);
            if (cached != null) return (VarArgParameterSyntax)cached;

            var result = new VarArgParameterSyntax(SyntaxKind.VarArgParameter, varArgToken, typeBinding);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParameterListSyntax ParameterList(SyntaxToken openParenthesisToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenthesisToken)
        {
#if DEBUG
            if (openParenthesisToken == null) throw new ArgumentNullException(nameof(openParenthesisToken));
            if (openParenthesisToken.Kind != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind}.", nameof(openParenthesisToken));
            if (closeParenthesisToken == null) throw new ArgumentNullException(nameof(closeParenthesisToken));
            if (closeParenthesisToken.Kind != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind}.", nameof(closeParenthesisToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParameterList, openParenthesisToken, parameters.Node, closeParenthesisToken, out hash);
            if (cached != null) return (ParameterListSyntax)cached;

            var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenthesisToken, parameters.Node, closeParenthesisToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static IdentifierKeyedTableFieldSyntax IdentifierKeyedTableField(SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax value)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind}.", nameof(identifier));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind}.", nameof(equalsToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierKeyedTableField, identifier, equalsToken, value, out hash);
            if (cached != null) return (IdentifierKeyedTableFieldSyntax)cached;

            var result = new IdentifierKeyedTableFieldSyntax(SyntaxKind.IdentifierKeyedTableField, identifier, equalsToken, value);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ExpressionKeyedTableFieldSyntax ExpressionKeyedTableField(SyntaxToken openBracketToken, ExpressionSyntax key, SyntaxToken closeBracketToken, SyntaxToken equalsToken, ExpressionSyntax value)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBracketToken but got {openBracketToken.Kind}.", nameof(openBracketToken));
            if (key == null) throw new ArgumentNullException(nameof(key));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBracketToken but got {closeBracketToken.Kind}.", nameof(closeBracketToken));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind}.", nameof(equalsToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            return new ExpressionKeyedTableFieldSyntax(SyntaxKind.ExpressionKeyedTableField, openBracketToken, key, closeBracketToken, equalsToken, value);
        }

        public static UnkeyedTableFieldSyntax UnkeyedTableField(ExpressionSyntax value)
        {
#if DEBUG
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.UnkeyedTableField, value, out hash);
            if (cached != null) return (UnkeyedTableFieldSyntax)cached;

            var result = new UnkeyedTableFieldSyntax(SyntaxKind.UnkeyedTableField, value);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SimpleFunctionNameSyntax SimpleFunctionName(SyntaxToken name)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (name.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {name.Kind}.", nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleFunctionName, name, out hash);
            if (cached != null) return (SimpleFunctionNameSyntax)cached;

            var result = new SimpleFunctionNameSyntax(SyntaxKind.SimpleFunctionName, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static MemberFunctionNameSyntax MemberFunctionName(FunctionNameSyntax baseName, SyntaxToken dotToken, SyntaxToken name)
        {
#if DEBUG
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException($"Invalid kind provided. Expected DotToken but got {dotToken.Kind}.", nameof(dotToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (name.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {name.Kind}.", nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberFunctionName, baseName, dotToken, name, out hash);
            if (cached != null) return (MemberFunctionNameSyntax)cached;

            var result = new MemberFunctionNameSyntax(SyntaxKind.MemberFunctionName, baseName, dotToken, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static MethodFunctionNameSyntax MethodFunctionName(FunctionNameSyntax baseName, SyntaxToken colonToken, SyntaxToken name)
        {
#if DEBUG
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonToken but got {colonToken.Kind}.", nameof(colonToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (name.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {name.Kind}.", nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.MethodFunctionName, baseName, colonToken, name, out hash);
            if (cached != null) return (MethodFunctionNameSyntax)cached;

            var result = new MethodFunctionNameSyntax(SyntaxKind.MethodFunctionName, baseName, colonToken, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static StringFunctionArgumentSyntax StringFunctionArgument(LiteralExpressionSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.StringFunctionArgument, expression, out hash);
            if (cached != null) return (StringFunctionArgumentSyntax)cached;

            var result = new StringFunctionArgumentSyntax(SyntaxKind.StringFunctionArgument, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TableConstructorFunctionArgumentSyntax TableConstructorFunctionArgument(TableConstructorExpressionSyntax tableConstructor)
        {
#if DEBUG
            if (tableConstructor == null) throw new ArgumentNullException(nameof(tableConstructor));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TableConstructorFunctionArgument, tableConstructor, out hash);
            if (cached != null) return (TableConstructorFunctionArgumentSyntax)cached;

            var result = new TableConstructorFunctionArgumentSyntax(SyntaxKind.TableConstructorFunctionArgument, tableConstructor);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ExpressionListFunctionArgumentSyntax ExpressionListFunctionArgument(SyntaxToken openParenthesisToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeParenthesisToken)
        {
#if DEBUG
            if (openParenthesisToken == null) throw new ArgumentNullException(nameof(openParenthesisToken));
            if (openParenthesisToken.Kind != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind}.", nameof(openParenthesisToken));
            if (closeParenthesisToken == null) throw new ArgumentNullException(nameof(closeParenthesisToken));
            if (closeParenthesisToken.Kind != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind}.", nameof(closeParenthesisToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionListFunctionArgument, openParenthesisToken, expressions.Node, closeParenthesisToken, out hash);
            if (cached != null) return (ExpressionListFunctionArgumentSyntax)cached;

            var result = new ExpressionListFunctionArgumentSyntax(SyntaxKind.ExpressionListFunctionArgument, openParenthesisToken, expressions.Node, closeParenthesisToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
        {
#if DEBUG
            if (textToken == null) throw new ArgumentNullException(nameof(textToken));
            if (textToken.Kind != SyntaxKind.InterpolatedStringTextToken) throw new ArgumentException($"Invalid kind provided. Expected InterpolatedStringTextToken but got {textToken.Kind}.", nameof(textToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringText, textToken, out hash);
            if (cached != null) return (InterpolatedStringTextSyntax)cached;

            var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBraceToken but got {openBraceToken.Kind}.", nameof(openBraceToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBraceToken but got {closeBraceToken.Kind}.", nameof(closeBraceToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Interpolation, openBraceToken, expression, closeBraceToken, out hash);
            if (cached != null) return (InterpolationSyntax)cached;

            var result = new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, closeBraceToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AnonymousFunctionExpressionSyntax AnonymousFunctionExpression(SyntaxToken functionKeyword, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword)
        {
#if DEBUG
            if (functionKeyword == null) throw new ArgumentNullException(nameof(functionKeyword));
            if (functionKeyword.Kind != SyntaxKind.FunctionKeyword) throw new ArgumentException($"Invalid kind provided. Expected FunctionKeyword but got {functionKeyword.Kind}.", nameof(functionKeyword));
            if (parameters == null) throw new ArgumentNullException(nameof(parameters));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword == null) throw new ArgumentNullException(nameof(endKeyword));
            if (endKeyword.Kind != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind}.", nameof(endKeyword));
#endif

            return new AnonymousFunctionExpressionSyntax(SyntaxKind.AnonymousFunctionExpression, functionKeyword, typeParameterList, parameters, typeBinding, body, endKeyword);
        }

        public static TableConstructorExpressionSyntax TableConstructorExpression(SyntaxToken openBraceToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TableFieldSyntax> fields, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBraceToken but got {openBraceToken.Kind}.", nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBraceToken but got {closeBraceToken.Kind}.", nameof(closeBraceToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TableConstructorExpression, openBraceToken, fields.Node, closeBraceToken, out hash);
            if (cached != null) return (TableConstructorExpressionSyntax)cached;

            var result = new TableConstructorExpressionSyntax(SyntaxKind.TableConstructorExpression, openBraceToken, fields.Node, closeBraceToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.NumericalLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.NilLiteralExpression:
                case SyntaxKind.HashStringLiteralExpression: break;
                default: throw new ArgumentException("Invalid kind provided.", nameof(kind));
            }
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            switch (token.Kind)
            {
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NilKeyword:
                case SyntaxKind.HashStringLiteralToken: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(token));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, token, out hash);
            if (cached != null) return (LiteralExpressionSyntax)cached;

            var result = new LiteralExpressionSyntax(kind, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
        {
#if DEBUG
            if (stringStartToken == null) throw new ArgumentNullException(nameof(stringStartToken));
            if (stringStartToken.Kind != SyntaxKind.BacktickToken) throw new ArgumentException($"Invalid kind provided. Expected BacktickToken but got {stringStartToken.Kind}.", nameof(stringStartToken));
            if (stringEndToken == null) throw new ArgumentNullException(nameof(stringEndToken));
            if (stringEndToken.Kind != SyntaxKind.BacktickToken) throw new ArgumentException($"Invalid kind provided. Expected BacktickToken but got {stringEndToken.Kind}.", nameof(stringEndToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, out hash);
            if (cached != null) return (InterpolatedStringExpressionSyntax)cached;

            var result = new InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static VarArgExpressionSyntax VarArgExpression(SyntaxToken varArgToken)
        {
#if DEBUG
            if (varArgToken == null) throw new ArgumentNullException(nameof(varArgToken));
            if (varArgToken.Kind != SyntaxKind.DotDotDotToken) throw new ArgumentException($"Invalid kind provided. Expected DotDotDotToken but got {varArgToken.Kind}.", nameof(varArgToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VarArgExpression, varArgToken, out hash);
            if (cached != null) return (VarArgExpressionSyntax)cached;

            var result = new VarArgExpressionSyntax(SyntaxKind.VarArgExpression, varArgToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind}.", nameof(identifier));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, out hash);
            if (cached != null) return (IdentifierNameSyntax)cached;

            var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static MemberAccessExpressionSyntax MemberAccessExpression(PrefixExpressionSyntax expression, SyntaxToken dotSeparator, SyntaxToken memberName)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (dotSeparator == null) throw new ArgumentNullException(nameof(dotSeparator));
            if (dotSeparator.Kind != SyntaxKind.DotToken) throw new ArgumentException($"Invalid kind provided. Expected DotToken but got {dotSeparator.Kind}.", nameof(dotSeparator));
            if (memberName == null) throw new ArgumentNullException(nameof(memberName));
            if (memberName.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {memberName.Kind}.", nameof(memberName));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberAccessExpression, expression, dotSeparator, memberName, out hash);
            if (cached != null) return (MemberAccessExpressionSyntax)cached;

            var result = new MemberAccessExpressionSyntax(SyntaxKind.MemberAccessExpression, expression, dotSeparator, memberName);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ElementAccessExpressionSyntax ElementAccessExpression(PrefixExpressionSyntax expression, SyntaxToken openBracketToken, ExpressionSyntax keyExpression, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBracketToken but got {openBracketToken.Kind}.", nameof(openBracketToken));
            if (keyExpression == null) throw new ArgumentNullException(nameof(keyExpression));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBracketToken but got {closeBracketToken.Kind}.", nameof(closeBracketToken));
#endif

            return new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, openBracketToken, keyExpression, closeBracketToken);
        }

        public static UnaryExpressionSyntax UnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            switch (kind)
            {
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.LengthExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.UnaryMinusExpression: break;
                default: throw new ArgumentException("Invalid kind provided.", nameof(kind));
            }
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.BangToken:
                case SyntaxKind.HashToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.NotKeyword:
                case SyntaxKind.TildeToken: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(operatorToken));
            }
            if (operand == null) throw new ArgumentNullException(nameof(operand));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, out hash);
            if (cached != null) return (UnaryExpressionSyntax)cached;

            var result = new UnaryExpressionSyntax(kind, operatorToken, operand);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.AddExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.ConcatExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.ExclusiveOrExpression:
                case SyntaxKind.ExponentiateExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.LogicalAndExpression:
                case SyntaxKind.LogicalOrExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.NotEqualsExpression:
                case SyntaxKind.RightShiftExpression:
                case SyntaxKind.SubtractExpression:
                case SyntaxKind.FloorDivideExpression: break;
                default: throw new ArgumentException("Invalid kind provided.", nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.AmpersandAmpersandToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AndKeyword:
                case SyntaxKind.BangEqualsToken:
                case SyntaxKind.DotDotToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.HatToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.OrKeyword:
                case SyntaxKind.PercentToken:
                case SyntaxKind.PipePipeToken:
                case SyntaxKind.PipeToken:
                case SyntaxKind.PlusToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.StarToken:
                case SyntaxKind.TildeEqualsToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.SlashSlashToken: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
            if (cached != null) return (BinaryExpressionSyntax)cached;

            var result = new BinaryExpressionSyntax(kind, left, operatorToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ElseIfExpressionClauseSyntax ElseIfExpressionClause(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax value)
        {
#if DEBUG
            if (elseIfKeyword == null) throw new ArgumentNullException(nameof(elseIfKeyword));
            if (elseIfKeyword.Kind != SyntaxKind.ElseIfKeyword) throw new ArgumentException($"Invalid kind provided. Expected ElseIfKeyword but got {elseIfKeyword.Kind}.", nameof(elseIfKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword == null) throw new ArgumentNullException(nameof(thenKeyword));
            if (thenKeyword.Kind != SyntaxKind.ThenKeyword) throw new ArgumentException($"Invalid kind provided. Expected ThenKeyword but got {thenKeyword.Kind}.", nameof(thenKeyword));
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            return new ElseIfExpressionClauseSyntax(SyntaxKind.ElseIfExpressionClause, elseIfKeyword, condition, thenKeyword, value);
        }

        public static IfExpressionSyntax IfExpression(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax trueValue, Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfExpressionClauseSyntax> elseIfClauses, SyntaxToken elseKeyword, ExpressionSyntax falseValue)
        {
#if DEBUG
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException($"Invalid kind provided. Expected IfKeyword but got {ifKeyword.Kind}.", nameof(ifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword == null) throw new ArgumentNullException(nameof(thenKeyword));
            if (thenKeyword.Kind != SyntaxKind.ThenKeyword) throw new ArgumentException($"Invalid kind provided. Expected ThenKeyword but got {thenKeyword.Kind}.", nameof(thenKeyword));
            if (trueValue == null) throw new ArgumentNullException(nameof(trueValue));
            if (elseKeyword == null) throw new ArgumentNullException(nameof(elseKeyword));
            if (elseKeyword.Kind != SyntaxKind.ElseKeyword) throw new ArgumentException($"Invalid kind provided. Expected ElseKeyword but got {elseKeyword.Kind}.", nameof(elseKeyword));
            if (falseValue == null) throw new ArgumentNullException(nameof(falseValue));
#endif

            return new IfExpressionSyntax(SyntaxKind.IfExpression, ifKeyword, condition, thenKeyword, trueValue, elseIfClauses.Node, elseKeyword, falseValue);
        }

        public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken)
        {
#if DEBUG
            if (openParenthesisToken == null) throw new ArgumentNullException(nameof(openParenthesisToken));
            if (openParenthesisToken.Kind != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind}.", nameof(openParenthesisToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenthesisToken == null) throw new ArgumentNullException(nameof(closeParenthesisToken));
            if (closeParenthesisToken.Kind != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind}.", nameof(closeParenthesisToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenthesisToken, expression, closeParenthesisToken, out hash);
            if (cached != null) return (ParenthesizedExpressionSyntax)cached;

            var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenthesisToken, expression, closeParenthesisToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static FunctionCallExpressionSyntax FunctionCallExpression(PrefixExpressionSyntax expression, FunctionArgumentSyntax argument)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (argument == null) throw new ArgumentNullException(nameof(argument));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionCallExpression, expression, argument, out hash);
            if (cached != null) return (FunctionCallExpressionSyntax)cached;

            var result = new FunctionCallExpressionSyntax(SyntaxKind.FunctionCallExpression, expression, argument);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static MethodCallExpressionSyntax MethodCallExpression(PrefixExpressionSyntax expression, SyntaxToken colonToken, SyntaxToken identifier, FunctionArgumentSyntax argument)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonToken but got {colonToken.Kind}.", nameof(colonToken));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind}.", nameof(identifier));
            if (argument == null) throw new ArgumentNullException(nameof(argument));
#endif

            return new MethodCallExpressionSyntax(SyntaxKind.MethodCallExpression, expression, colonToken, identifier, argument);
        }

        public static VariableAttributeSyntax VariableAttribute(SyntaxToken lessThanToken, SyntaxToken identifier, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException($"Invalid kind provided. Expected LessThanToken but got {lessThanToken.Kind}.", nameof(lessThanToken));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind}.", nameof(identifier));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException($"Invalid kind provided. Expected GreaterThanToken but got {greaterThanToken.Kind}.", nameof(greaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableAttribute, lessThanToken, identifier, greaterThanToken, out hash);
            if (cached != null) return (VariableAttributeSyntax)cached;

            var result = new VariableAttributeSyntax(SyntaxKind.VariableAttribute, lessThanToken, identifier, greaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LocalDeclarationNameSyntax LocalDeclarationName(IdentifierNameSyntax identifierName, VariableAttributeSyntax? attribute, TypeBindingSyntax? typeBinding)
        {
#if DEBUG
            if (identifierName == null) throw new ArgumentNullException(nameof(identifierName));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.LocalDeclarationName, identifierName, attribute, typeBinding, out hash);
            if (cached != null) return (LocalDeclarationNameSyntax)cached;

            var result = new LocalDeclarationNameSyntax(SyntaxKind.LocalDeclarationName, identifierName, attribute, typeBinding);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static EqualsValuesClauseSyntax EqualsValuesClause(SyntaxToken equalsToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> values)
        {
#if DEBUG
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind}.", nameof(equalsToken));
            if (values.Count < 1) throw new ArgumentException($"'{nameof(values)}' does not have at least 1 elements.", nameof(values));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsValuesClause, equalsToken, values.Node, out hash);
            if (cached != null) return (EqualsValuesClauseSyntax)cached;

            var result = new EqualsValuesClauseSyntax(SyntaxKind.EqualsValuesClause, equalsToken, values.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AssignmentStatementSyntax AssignmentStatement(Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<PrefixExpressionSyntax> variables, EqualsValuesClauseSyntax equalsValues, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (variables.Count < 1) throw new ArgumentException($"'{nameof(variables)}' does not have at least 1 elements.", nameof(variables));
            if (equalsValues == null) throw new ArgumentNullException(nameof(equalsValues));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AssignmentStatement, variables.Node, equalsValues, semicolonToken, out hash);
            if (cached != null) return (AssignmentStatementSyntax)cached;

            var result = new AssignmentStatementSyntax(SyntaxKind.AssignmentStatement, variables.Node, equalsValues, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CompoundAssignmentStatementSyntax CompoundAssignmentStatement(SyntaxKind kind, PrefixExpressionSyntax variable, SyntaxToken assignmentOperatorToken, ExpressionSyntax expression, SyntaxToken? semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.AddAssignmentStatement:
                case SyntaxKind.SubtractAssignmentStatement:
                case SyntaxKind.MultiplyAssignmentStatement:
                case SyntaxKind.DivideAssignmentStatement:
                case SyntaxKind.ModuloAssignmentStatement:
                case SyntaxKind.ConcatAssignmentStatement:
                case SyntaxKind.ExponentiateAssignmentStatement: break;
                default: throw new ArgumentException("Invalid kind provided.", nameof(kind));
            }
#if DEBUG
            if (variable == null) throw new ArgumentNullException(nameof(variable));
            if (assignmentOperatorToken == null) throw new ArgumentNullException(nameof(assignmentOperatorToken));
            switch (assignmentOperatorToken.Kind)
            {
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.StarEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.PercentEqualsToken:
                case SyntaxKind.DotDotEqualsToken:
                case SyntaxKind.HatEqualsToken: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(assignmentOperatorToken));
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new CompoundAssignmentStatementSyntax(kind, variable, assignmentOperatorToken, expression, semicolonToken);
        }

        public static LocalVariableDeclarationStatementSyntax LocalVariableDeclarationStatement(SyntaxToken localKeyword, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<LocalDeclarationNameSyntax> names, EqualsValuesClauseSyntax? equalsValues, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (localKeyword == null) throw new ArgumentNullException(nameof(localKeyword));
            if (localKeyword.Kind != SyntaxKind.LocalKeyword) throw new ArgumentException($"Invalid kind provided. Expected LocalKeyword but got {localKeyword.Kind}.", nameof(localKeyword));
            if (names.Count < 1) throw new ArgumentException($"'{nameof(names)}' does not have at least 1 elements.", nameof(names));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new LocalVariableDeclarationStatementSyntax(SyntaxKind.LocalVariableDeclarationStatement, localKeyword, names.Node, equalsValues, semicolonToken);
        }

        public static TypedIdentifierNameSyntax TypedIdentifierName(IdentifierNameSyntax identifierName, TypeBindingSyntax? typeBinding)
        {
#if DEBUG
            if (identifierName == null) throw new ArgumentNullException(nameof(identifierName));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypedIdentifierName, identifierName, typeBinding, out hash);
            if (cached != null) return (TypedIdentifierNameSyntax)cached;

            var result = new TypedIdentifierNameSyntax(SyntaxKind.TypedIdentifierName, identifierName, typeBinding);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static NumericForStatementSyntax NumericForStatement(SyntaxToken forKeyword, TypedIdentifierNameSyntax identifier, SyntaxToken equalsToken, ExpressionSyntax initialValue, SyntaxToken finalValueCommaToken, ExpressionSyntax finalValue, SyntaxToken? stepValueCommaToken, ExpressionSyntax? stepValue, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException($"Invalid kind provided. Expected ForKeyword but got {forKeyword.Kind}.", nameof(forKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind}.", nameof(equalsToken));
            if (initialValue == null) throw new ArgumentNullException(nameof(initialValue));
            if (finalValueCommaToken == null) throw new ArgumentNullException(nameof(finalValueCommaToken));
            if (finalValueCommaToken.Kind != SyntaxKind.CommaToken) throw new ArgumentException($"Invalid kind provided. Expected CommaToken but got {finalValueCommaToken.Kind}.", nameof(finalValueCommaToken));
            if (finalValue == null) throw new ArgumentNullException(nameof(finalValue));
            if (stepValueCommaToken != null)
            {
                switch (stepValueCommaToken.Kind)
                {
                    case SyntaxKind.CommaToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(stepValueCommaToken));
                }
            }
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException($"Invalid kind provided. Expected DoKeyword but got {doKeyword.Kind}.", nameof(doKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword == null) throw new ArgumentNullException(nameof(endKeyword));
            if (endKeyword.Kind != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind}.", nameof(endKeyword));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new NumericForStatementSyntax(SyntaxKind.NumericForStatement, forKeyword, identifier, equalsToken, initialValue, finalValueCommaToken, finalValue, stepValueCommaToken, stepValue, doKeyword, body, endKeyword, semicolonToken);
        }

        public static GenericForStatementSyntax GenericForStatement(SyntaxToken forKeyword, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypedIdentifierNameSyntax> identifiers, SyntaxToken inKeyword, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException($"Invalid kind provided. Expected ForKeyword but got {forKeyword.Kind}.", nameof(forKeyword));
            if (identifiers.Count < 1) throw new ArgumentException($"'{nameof(identifiers)}' does not have at least 1 elements.", nameof(identifiers));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException($"Invalid kind provided. Expected InKeyword but got {inKeyword.Kind}.", nameof(inKeyword));
            if (expressions.Count < 1) throw new ArgumentException($"'{nameof(expressions)}' does not have at least 1 elements.", nameof(expressions));
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException($"Invalid kind provided. Expected DoKeyword but got {doKeyword.Kind}.", nameof(doKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword == null) throw new ArgumentNullException(nameof(endKeyword));
            if (endKeyword.Kind != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind}.", nameof(endKeyword));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new GenericForStatementSyntax(SyntaxKind.GenericForStatement, forKeyword, identifiers.Node, inKeyword, expressions.Node, doKeyword, body, endKeyword, semicolonToken);
        }

        public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException($"Invalid kind provided. Expected WhileKeyword but got {whileKeyword.Kind}.", nameof(whileKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException($"Invalid kind provided. Expected DoKeyword but got {doKeyword.Kind}.", nameof(doKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword == null) throw new ArgumentNullException(nameof(endKeyword));
            if (endKeyword.Kind != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind}.", nameof(endKeyword));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, condition, doKeyword, body, endKeyword, semicolonToken);
        }

        public static RepeatUntilStatementSyntax RepeatUntilStatement(SyntaxToken repeatKeyword, StatementListSyntax body, SyntaxToken untilKeyword, ExpressionSyntax condition, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (repeatKeyword == null) throw new ArgumentNullException(nameof(repeatKeyword));
            if (repeatKeyword.Kind != SyntaxKind.RepeatKeyword) throw new ArgumentException($"Invalid kind provided. Expected RepeatKeyword but got {repeatKeyword.Kind}.", nameof(repeatKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (untilKeyword == null) throw new ArgumentNullException(nameof(untilKeyword));
            if (untilKeyword.Kind != SyntaxKind.UntilKeyword) throw new ArgumentException($"Invalid kind provided. Expected UntilKeyword but got {untilKeyword.Kind}.", nameof(untilKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new RepeatUntilStatementSyntax(SyntaxKind.RepeatUntilStatement, repeatKeyword, body, untilKeyword, condition, semicolonToken);
        }

        public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body, Loretta.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ElseIfClauseSyntax> elseIfClauses, ElseClauseSyntax? elseClause, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException($"Invalid kind provided. Expected IfKeyword but got {ifKeyword.Kind}.", nameof(ifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword == null) throw new ArgumentNullException(nameof(thenKeyword));
            if (thenKeyword.Kind != SyntaxKind.ThenKeyword) throw new ArgumentException($"Invalid kind provided. Expected ThenKeyword but got {thenKeyword.Kind}.", nameof(thenKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword == null) throw new ArgumentNullException(nameof(endKeyword));
            if (endKeyword.Kind != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind}.", nameof(endKeyword));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, condition, thenKeyword, body, elseIfClauses.Node, elseClause, endKeyword, semicolonToken);
        }

        public static ElseIfClauseSyntax ElseIfClause(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body)
        {
#if DEBUG
            if (elseIfKeyword == null) throw new ArgumentNullException(nameof(elseIfKeyword));
            if (elseIfKeyword.Kind != SyntaxKind.ElseIfKeyword) throw new ArgumentException($"Invalid kind provided. Expected ElseIfKeyword but got {elseIfKeyword.Kind}.", nameof(elseIfKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword == null) throw new ArgumentNullException(nameof(thenKeyword));
            if (thenKeyword.Kind != SyntaxKind.ThenKeyword) throw new ArgumentException($"Invalid kind provided. Expected ThenKeyword but got {thenKeyword.Kind}.", nameof(thenKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
#endif

            return new ElseIfClauseSyntax(SyntaxKind.ElseIfClause, elseIfKeyword, condition, thenKeyword, body);
        }

        public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementListSyntax elseBody)
        {
#if DEBUG
            if (elseKeyword == null) throw new ArgumentNullException(nameof(elseKeyword));
            if (elseKeyword.Kind != SyntaxKind.ElseKeyword) throw new ArgumentException($"Invalid kind provided. Expected ElseKeyword but got {elseKeyword.Kind}.", nameof(elseKeyword));
            if (elseBody == null) throw new ArgumentNullException(nameof(elseBody));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, elseBody, out hash);
            if (cached != null) return (ElseClauseSyntax)cached;

            var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, elseBody);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static GotoStatementSyntax GotoStatement(SyntaxToken gotoKeyword, SyntaxToken labelName, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (gotoKeyword == null) throw new ArgumentNullException(nameof(gotoKeyword));
            if (gotoKeyword.Kind != SyntaxKind.GotoKeyword) throw new ArgumentException($"Invalid kind provided. Expected GotoKeyword but got {gotoKeyword.Kind}.", nameof(gotoKeyword));
            if (labelName == null) throw new ArgumentNullException(nameof(labelName));
            if (labelName.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {labelName.Kind}.", nameof(labelName));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GotoStatement, gotoKeyword, labelName, semicolonToken, out hash);
            if (cached != null) return (GotoStatementSyntax)cached;

            var result = new GotoStatementSyntax(SyntaxKind.GotoStatement, gotoKeyword, labelName, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (breakKeyword == null) throw new ArgumentNullException(nameof(breakKeyword));
            if (breakKeyword.Kind != SyntaxKind.BreakKeyword) throw new ArgumentException($"Invalid kind provided. Expected BreakKeyword but got {breakKeyword.Kind}.", nameof(breakKeyword));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, breakKeyword, semicolonToken, out hash);
            if (cached != null) return (BreakStatementSyntax)cached;

            var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (returnKeyword == null) throw new ArgumentNullException(nameof(returnKeyword));
            if (returnKeyword.Kind != SyntaxKind.ReturnKeyword) throw new ArgumentException($"Invalid kind provided. Expected ReturnKeyword but got {returnKeyword.Kind}.", nameof(returnKeyword));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ReturnStatement, returnKeyword, expressions.Node, semicolonToken, out hash);
            if (cached != null) return (ReturnStatementSyntax)cached;

            var result = new ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, expressions.Node, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (continueKeyword == null) throw new ArgumentNullException(nameof(continueKeyword));
            if (continueKeyword.Kind != SyntaxKind.ContinueKeyword) throw new ArgumentException($"Invalid kind provided. Expected ContinueKeyword but got {continueKeyword.Kind}.", nameof(continueKeyword));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, out hash);
            if (cached != null) return (ContinueStatementSyntax)cached;

            var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LocalFunctionDeclarationStatementSyntax LocalFunctionDeclarationStatement(SyntaxToken localKeyword, SyntaxToken functionKeyword, IdentifierNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (localKeyword == null) throw new ArgumentNullException(nameof(localKeyword));
            if (localKeyword.Kind != SyntaxKind.LocalKeyword) throw new ArgumentException($"Invalid kind provided. Expected LocalKeyword but got {localKeyword.Kind}.", nameof(localKeyword));
            if (functionKeyword == null) throw new ArgumentNullException(nameof(functionKeyword));
            if (functionKeyword.Kind != SyntaxKind.FunctionKeyword) throw new ArgumentException($"Invalid kind provided. Expected FunctionKeyword but got {functionKeyword.Kind}.", nameof(functionKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (parameters == null) throw new ArgumentNullException(nameof(parameters));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword == null) throw new ArgumentNullException(nameof(endKeyword));
            if (endKeyword.Kind != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind}.", nameof(endKeyword));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new LocalFunctionDeclarationStatementSyntax(SyntaxKind.LocalFunctionDeclarationStatement, localKeyword, functionKeyword, name, typeParameterList, parameters, typeBinding, body, endKeyword, semicolonToken);
        }

        public static FunctionDeclarationStatementSyntax FunctionDeclarationStatement(SyntaxToken functionKeyword, FunctionNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (functionKeyword == null) throw new ArgumentNullException(nameof(functionKeyword));
            if (functionKeyword.Kind != SyntaxKind.FunctionKeyword) throw new ArgumentException($"Invalid kind provided. Expected FunctionKeyword but got {functionKeyword.Kind}.", nameof(functionKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (parameters == null) throw new ArgumentNullException(nameof(parameters));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword == null) throw new ArgumentNullException(nameof(endKeyword));
            if (endKeyword.Kind != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind}.", nameof(endKeyword));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new FunctionDeclarationStatementSyntax(SyntaxKind.FunctionDeclarationStatement, functionKeyword, name, typeParameterList, parameters, typeBinding, body, endKeyword, semicolonToken);
        }

        public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException($"Invalid kind provided. Expected DoKeyword but got {doKeyword.Kind}.", nameof(doKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword == null) throw new ArgumentNullException(nameof(endKeyword));
            if (endKeyword.Kind != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind}.", nameof(endKeyword));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, body, endKeyword, semicolonToken);
        }

        public static GotoLabelStatementSyntax GotoLabelStatement(SyntaxToken leftDelimiterToken, SyntaxToken identifier, SyntaxToken rightDelimiterToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (leftDelimiterToken == null) throw new ArgumentNullException(nameof(leftDelimiterToken));
            if (leftDelimiterToken.Kind != SyntaxKind.ColonColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonColonToken but got {leftDelimiterToken.Kind}.", nameof(leftDelimiterToken));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind}.", nameof(identifier));
            if (rightDelimiterToken == null) throw new ArgumentNullException(nameof(rightDelimiterToken));
            if (rightDelimiterToken.Kind != SyntaxKind.ColonColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonColonToken but got {rightDelimiterToken.Kind}.", nameof(rightDelimiterToken));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new GotoLabelStatementSyntax(SyntaxKind.GotoLabelStatement, leftDelimiterToken, identifier, rightDelimiterToken, semicolonToken);
        }

        public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, expression, semicolonToken, out hash);
            if (cached != null) return (ExpressionStatementSyntax)cached;

            var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static EmptyStatementSyntax EmptyStatement(SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EmptyStatement, semicolonToken, out hash);
            if (cached != null) return (EmptyStatementSyntax)cached;

            var result = new EmptyStatementSyntax(SyntaxKind.EmptyStatement, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeDeclarationStatementSyntax TypeDeclarationStatement(SyntaxToken? exportKeyword, SyntaxToken typeKeyword, SyntaxToken name, TypeParameterListSyntax? typeParameterList, SyntaxToken equalsToken, TypeSyntax type, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (exportKeyword != null)
            {
                switch (exportKeyword.Kind)
                {
                    case SyntaxKind.ExportKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(exportKeyword));
                }
            }
            if (typeKeyword == null) throw new ArgumentNullException(nameof(typeKeyword));
            if (typeKeyword.Kind != SyntaxKind.TypeKeyword) throw new ArgumentException($"Invalid kind provided. Expected TypeKeyword but got {typeKeyword.Kind}.", nameof(typeKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (name.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {name.Kind}.", nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind}.", nameof(equalsToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
                }
            }
#endif

            return new TypeDeclarationStatementSyntax(SyntaxKind.TypeDeclarationStatement, exportKeyword, typeKeyword, name, typeParameterList, equalsToken, type, semicolonToken);
        }

        public static TypeBindingSyntax TypeBinding(SyntaxToken colonToken, TypeSyntax type)
        {
#if DEBUG
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonToken but got {colonToken.Kind}.", nameof(colonToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeBinding, colonToken, type, out hash);
            if (cached != null) return (TypeBindingSyntax)cached;

            var result = new TypeBindingSyntax(SyntaxKind.TypeBinding, colonToken, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SimpleTypeNameSyntax SimpleTypeName(SyntaxToken identifierToken, TypeArgumentListSyntax? typeArgumentList)
        {
#if DEBUG
            if (identifierToken == null) throw new ArgumentNullException(nameof(identifierToken));
            if (identifierToken.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifierToken.Kind}.", nameof(identifierToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleTypeName, identifierToken, typeArgumentList, out hash);
            if (cached != null) return (SimpleTypeNameSyntax)cached;

            var result = new SimpleTypeNameSyntax(SyntaxKind.SimpleTypeName, identifierToken, typeArgumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CompositeTypeNameSyntax CompositeTypeName(TypeNameSyntax @base, SyntaxToken dotToken, SyntaxToken identifierToken, TypeArgumentListSyntax? typeArgumentList)
        {
#if DEBUG
            if (@base == null) throw new ArgumentNullException(nameof(@base));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException($"Invalid kind provided. Expected DotToken but got {dotToken.Kind}.", nameof(dotToken));
            if (identifierToken == null) throw new ArgumentNullException(nameof(identifierToken));
            if (identifierToken.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifierToken.Kind}.", nameof(identifierToken));
#endif

            return new CompositeTypeNameSyntax(SyntaxKind.CompositeTypeName, @base, dotToken, identifierToken, typeArgumentList);
        }

        public static NilableTypeSyntax NilableType(TypeSyntax type, SyntaxToken questionToken)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (questionToken == null) throw new ArgumentNullException(nameof(questionToken));
            if (questionToken.Kind != SyntaxKind.QuestionToken) throw new ArgumentException($"Invalid kind provided. Expected QuestionToken but got {questionToken.Kind}.", nameof(questionToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NilableType, type, questionToken, out hash);
            if (cached != null) return (NilableTypeSyntax)cached;

            var result = new NilableTypeSyntax(SyntaxKind.NilableType, type, questionToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParenthesizedTypeSyntax ParenthesizedType(SyntaxToken openParenthesisToken, TypeSyntax type, SyntaxToken closeParenthesisToken)
        {
#if DEBUG
            if (openParenthesisToken == null) throw new ArgumentNullException(nameof(openParenthesisToken));
            if (openParenthesisToken.Kind != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind}.", nameof(openParenthesisToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenthesisToken == null) throw new ArgumentNullException(nameof(closeParenthesisToken));
            if (closeParenthesisToken.Kind != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind}.", nameof(closeParenthesisToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedType, openParenthesisToken, type, closeParenthesisToken, out hash);
            if (cached != null) return (ParenthesizedTypeSyntax)cached;

            var result = new ParenthesizedTypeSyntax(SyntaxKind.ParenthesizedType, openParenthesisToken, type, closeParenthesisToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypePackSyntax TypePack(SyntaxToken openParenthesisToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> types, SyntaxToken closeParenthesisToken)
        {
#if DEBUG
            if (openParenthesisToken == null) throw new ArgumentNullException(nameof(openParenthesisToken));
            if (openParenthesisToken.Kind != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind}.", nameof(openParenthesisToken));
            if (closeParenthesisToken == null) throw new ArgumentNullException(nameof(closeParenthesisToken));
            if (closeParenthesisToken.Kind != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind}.", nameof(closeParenthesisToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypePack, openParenthesisToken, types.Node, closeParenthesisToken, out hash);
            if (cached != null) return (TypePackSyntax)cached;

            var result = new TypePackSyntax(SyntaxKind.TypePack, openParenthesisToken, types.Node, closeParenthesisToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static FunctionTypeSyntax FunctionType(TypeParameterListSyntax? typeParameterList, SyntaxToken openParenthesisToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> parameters, SyntaxToken closeParenthesisToken, SyntaxToken minusGreaterThanToken, TypeSyntax returnType)
        {
#if DEBUG
            if (openParenthesisToken == null) throw new ArgumentNullException(nameof(openParenthesisToken));
            if (openParenthesisToken.Kind != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind}.", nameof(openParenthesisToken));
            if (closeParenthesisToken == null) throw new ArgumentNullException(nameof(closeParenthesisToken));
            if (closeParenthesisToken.Kind != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind}.", nameof(closeParenthesisToken));
            if (minusGreaterThanToken == null) throw new ArgumentNullException(nameof(minusGreaterThanToken));
            if (minusGreaterThanToken.Kind != SyntaxKind.MinusGreaterThanToken) throw new ArgumentException($"Invalid kind provided. Expected MinusGreaterThanToken but got {minusGreaterThanToken.Kind}.", nameof(minusGreaterThanToken));
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
#endif

            return new FunctionTypeSyntax(SyntaxKind.FunctionType, typeParameterList, openParenthesisToken, parameters.Node, closeParenthesisToken, minusGreaterThanToken, returnType);
        }

        public static ArrayTypeSyntax ArrayType(SyntaxToken openBraceToken, TypeSyntax type, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBraceToken but got {openBraceToken.Kind}.", nameof(openBraceToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBraceToken but got {closeBraceToken.Kind}.", nameof(closeBraceToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayType, openBraceToken, type, closeBraceToken, out hash);
            if (cached != null) return (ArrayTypeSyntax)cached;

            var result = new ArrayTypeSyntax(SyntaxKind.ArrayType, openBraceToken, type, closeBraceToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TableTypeIndexerSyntax TableTypeIndexer(SyntaxToken openBracketToken, TypeSyntax indexType, SyntaxToken closeBracketToken, SyntaxToken colonToken, TypeSyntax valueType)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBracketToken but got {openBracketToken.Kind}.", nameof(openBracketToken));
            if (indexType == null) throw new ArgumentNullException(nameof(indexType));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBracketToken but got {closeBracketToken.Kind}.", nameof(closeBracketToken));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonToken but got {colonToken.Kind}.", nameof(colonToken));
            if (valueType == null) throw new ArgumentNullException(nameof(valueType));
#endif

            return new TableTypeIndexerSyntax(SyntaxKind.TableTypeIndexer, openBracketToken, indexType, closeBracketToken, colonToken, valueType);
        }

        public static TableTypePropertySyntax TableTypeProperty(SyntaxToken identifier, SyntaxToken colonToken, TypeSyntax valueType)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind}.", nameof(identifier));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonToken but got {colonToken.Kind}.", nameof(colonToken));
            if (valueType == null) throw new ArgumentNullException(nameof(valueType));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TableTypeProperty, identifier, colonToken, valueType, out hash);
            if (cached != null) return (TableTypePropertySyntax)cached;

            var result = new TableTypePropertySyntax(SyntaxKind.TableTypeProperty, identifier, colonToken, valueType);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TableTypeSyntax TableType(SyntaxToken openBraceToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TableTypeElementSyntax> elements, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBraceToken but got {openBraceToken.Kind}.", nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBraceToken but got {closeBraceToken.Kind}.", nameof(closeBraceToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TableType, openBraceToken, elements.Node, closeBraceToken, out hash);
            if (cached != null) return (TableTypeSyntax)cached;

            var result = new TableTypeSyntax(SyntaxKind.TableType, openBraceToken, elements.Node, closeBraceToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeCastExpressionSyntax TypeCastExpression(ExpressionSyntax expression, SyntaxToken colonColonToken, TypeSyntax type)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (colonColonToken == null) throw new ArgumentNullException(nameof(colonColonToken));
            if (colonColonToken.Kind != SyntaxKind.ColonColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonColonToken but got {colonColonToken.Kind}.", nameof(colonColonToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeCastExpression, expression, colonColonToken, type, out hash);
            if (cached != null) return (TypeCastExpressionSyntax)cached;

            var result = new TypeCastExpressionSyntax(SyntaxKind.TypeCastExpression, expression, colonColonToken, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static UnionTypeSyntax UnionType(TypeSyntax left, SyntaxToken pipeToken, TypeSyntax right)
        {
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (pipeToken == null) throw new ArgumentNullException(nameof(pipeToken));
            if (pipeToken.Kind != SyntaxKind.PipeToken) throw new ArgumentException($"Invalid kind provided. Expected PipeToken but got {pipeToken.Kind}.", nameof(pipeToken));
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.UnionType, left, pipeToken, right, out hash);
            if (cached != null) return (UnionTypeSyntax)cached;

            var result = new UnionTypeSyntax(SyntaxKind.UnionType, left, pipeToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static IntersectionTypeSyntax IntersectionType(TypeSyntax left, SyntaxToken ampersandToken, TypeSyntax right)
        {
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (ampersandToken == null) throw new ArgumentNullException(nameof(ampersandToken));
            if (ampersandToken.Kind != SyntaxKind.AmpersandToken) throw new ArgumentException($"Invalid kind provided. Expected AmpersandToken but got {ampersandToken.Kind}.", nameof(ampersandToken));
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IntersectionType, left, ampersandToken, right, out hash);
            if (cached != null) return (IntersectionTypeSyntax)cached;

            var result = new IntersectionTypeSyntax(SyntaxKind.IntersectionType, left, ampersandToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static EqualsTypeSyntax EqualsType(SyntaxToken equalsToken, TypeSyntax type)
        {
#if DEBUG
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind}.", nameof(equalsToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsType, equalsToken, type, out hash);
            if (cached != null) return (EqualsTypeSyntax)cached;

            var result = new EqualsTypeSyntax(SyntaxKind.EqualsType, equalsToken, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeParameterSyntax TypeParameter(SyntaxToken identifier, SyntaxToken? dotDotDotToken, EqualsTypeSyntax? equalsType)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind}.", nameof(identifier));
            if (dotDotDotToken != null)
            {
                switch (dotDotDotToken.Kind)
                {
                    case SyntaxKind.DotDotDotToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(dotDotDotToken));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameter, identifier, dotDotDotToken, equalsType, out hash);
            if (cached != null) return (TypeParameterSyntax)cached;

            var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, identifier, dotDotDotToken, equalsType);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> names, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException($"Invalid kind provided. Expected LessThanToken but got {lessThanToken.Kind}.", nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException($"Invalid kind provided. Expected GreaterThanToken but got {greaterThanToken.Kind}.", nameof(greaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameterList, lessThanToken, names.Node, greaterThanToken, out hash);
            if (cached != null) return (TypeParameterListSyntax)cached;

            var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, names.Node, greaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, Loretta.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException($"Invalid kind provided. Expected LessThanToken but got {lessThanToken.Kind}.", nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException($"Invalid kind provided. Expected GreaterThanToken but got {greaterThanToken.Kind}.", nameof(greaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, out hash);
            if (cached != null) return (TypeArgumentListSyntax)cached;

            var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LiteralTypeSyntax LiteralType(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.StringType:
                case SyntaxKind.TrueType:
                case SyntaxKind.FalseType:
                case SyntaxKind.NilType: break;
                default: throw new ArgumentException("Invalid kind provided.", nameof(kind));
            }
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            switch (token.Kind)
            {
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NilKeyword: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(token));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, token, out hash);
            if (cached != null) return (LiteralTypeSyntax)cached;

            var result = new LiteralTypeSyntax(kind, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeofTypeSyntax TypeofType(SyntaxToken typeofKeyword, SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken)
        {
#if DEBUG
            if (typeofKeyword == null) throw new ArgumentNullException(nameof(typeofKeyword));
            if (typeofKeyword.Kind != SyntaxKind.TypeofKeyword) throw new ArgumentException($"Invalid kind provided. Expected TypeofKeyword but got {typeofKeyword.Kind}.", nameof(typeofKeyword));
            if (openParenthesisToken == null) throw new ArgumentNullException(nameof(openParenthesisToken));
            if (openParenthesisToken.Kind != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind}.", nameof(openParenthesisToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenthesisToken == null) throw new ArgumentNullException(nameof(closeParenthesisToken));
            if (closeParenthesisToken.Kind != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind}.", nameof(closeParenthesisToken));
#endif

            return new TypeofTypeSyntax(SyntaxKind.TypeofType, typeofKeyword, openParenthesisToken, expression, closeParenthesisToken);
        }

        public static VariadicTypePackSyntax VariadicTypePack(SyntaxToken dotDotDotToken, TypeSyntax type)
        {
#if DEBUG
            if (dotDotDotToken == null) throw new ArgumentNullException(nameof(dotDotDotToken));
            if (dotDotDotToken.Kind != SyntaxKind.DotDotDotToken) throw new ArgumentException($"Invalid kind provided. Expected DotDotDotToken but got {dotDotDotToken.Kind}.", nameof(dotDotDotToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariadicTypePack, dotDotDotToken, type, out hash);
            if (cached != null) return (VariadicTypePackSyntax)cached;

            var result = new VariadicTypePackSyntax(SyntaxKind.VariadicTypePack, dotDotDotToken, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static GenericTypePackSyntax GenericTypePack(SyntaxToken identifier, SyntaxToken dotDotDotToken)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind}.", nameof(identifier));
            if (dotDotDotToken == null) throw new ArgumentNullException(nameof(dotDotDotToken));
            if (dotDotDotToken.Kind != SyntaxKind.DotDotDotToken) throw new ArgumentException($"Invalid kind provided. Expected DotDotDotToken but got {dotDotDotToken.Kind}.", nameof(dotDotDotToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GenericTypePack, identifier, dotDotDotToken, out hash);
            if (cached != null) return (GenericTypePackSyntax)cached;

            var result = new GenericTypePackSyntax(SyntaxKind.GenericTypePack, identifier, dotDotDotToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CompilationUnitSyntax CompilationUnit(StatementListSyntax statements, SyntaxToken endOfFileToken)
        {
#if DEBUG
            if (statements == null) throw new ArgumentNullException(nameof(statements));
            if (endOfFileToken == null) throw new ArgumentNullException(nameof(endOfFileToken));
            if (endOfFileToken.Kind != SyntaxKind.EndOfFileToken) throw new ArgumentException($"Invalid kind provided. Expected EndOfFileToken but got {endOfFileToken.Kind}.", nameof(endOfFileToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CompilationUnit, statements, endOfFileToken, out hash);
            if (cached != null) return (CompilationUnitSyntax)cached;

            var result = new CompilationUnitSyntax(SyntaxKind.CompilationUnit, statements, endOfFileToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        internal static IEnumerable<Type> GetNodeTypes()
            => new Type[]
            {
                typeof(SkippedTokensTriviaSyntax),
                typeof(StatementListSyntax),
                typeof(NamedParameterSyntax),
                typeof(VarArgParameterSyntax),
                typeof(ParameterListSyntax),
                typeof(IdentifierKeyedTableFieldSyntax),
                typeof(ExpressionKeyedTableFieldSyntax),
                typeof(UnkeyedTableFieldSyntax),
                typeof(SimpleFunctionNameSyntax),
                typeof(MemberFunctionNameSyntax),
                typeof(MethodFunctionNameSyntax),
                typeof(StringFunctionArgumentSyntax),
                typeof(TableConstructorFunctionArgumentSyntax),
                typeof(ExpressionListFunctionArgumentSyntax),
                typeof(InterpolatedStringTextSyntax),
                typeof(InterpolationSyntax),
                typeof(AnonymousFunctionExpressionSyntax),
                typeof(TableConstructorExpressionSyntax),
                typeof(LiteralExpressionSyntax),
                typeof(InterpolatedStringExpressionSyntax),
                typeof(VarArgExpressionSyntax),
                typeof(IdentifierNameSyntax),
                typeof(MemberAccessExpressionSyntax),
                typeof(ElementAccessExpressionSyntax),
                typeof(UnaryExpressionSyntax),
                typeof(BinaryExpressionSyntax),
                typeof(ElseIfExpressionClauseSyntax),
                typeof(IfExpressionSyntax),
                typeof(ParenthesizedExpressionSyntax),
                typeof(FunctionCallExpressionSyntax),
                typeof(MethodCallExpressionSyntax),
                typeof(VariableAttributeSyntax),
                typeof(LocalDeclarationNameSyntax),
                typeof(EqualsValuesClauseSyntax),
                typeof(AssignmentStatementSyntax),
                typeof(CompoundAssignmentStatementSyntax),
                typeof(LocalVariableDeclarationStatementSyntax),
                typeof(TypedIdentifierNameSyntax),
                typeof(NumericForStatementSyntax),
                typeof(GenericForStatementSyntax),
                typeof(WhileStatementSyntax),
                typeof(RepeatUntilStatementSyntax),
                typeof(IfStatementSyntax),
                typeof(ElseIfClauseSyntax),
                typeof(ElseClauseSyntax),
                typeof(GotoStatementSyntax),
                typeof(BreakStatementSyntax),
                typeof(ReturnStatementSyntax),
                typeof(ContinueStatementSyntax),
                typeof(LocalFunctionDeclarationStatementSyntax),
                typeof(FunctionDeclarationStatementSyntax),
                typeof(DoStatementSyntax),
                typeof(GotoLabelStatementSyntax),
                typeof(ExpressionStatementSyntax),
                typeof(EmptyStatementSyntax),
                typeof(TypeDeclarationStatementSyntax),
                typeof(TypeBindingSyntax),
                typeof(SimpleTypeNameSyntax),
                typeof(CompositeTypeNameSyntax),
                typeof(NilableTypeSyntax),
                typeof(ParenthesizedTypeSyntax),
                typeof(TypePackSyntax),
                typeof(FunctionTypeSyntax),
                typeof(ArrayTypeSyntax),
                typeof(TableTypeIndexerSyntax),
                typeof(TableTypePropertySyntax),
                typeof(TableTypeSyntax),
                typeof(TypeCastExpressionSyntax),
                typeof(UnionTypeSyntax),
                typeof(IntersectionTypeSyntax),
                typeof(EqualsTypeSyntax),
                typeof(TypeParameterSyntax),
                typeof(TypeParameterListSyntax),
                typeof(TypeArgumentListSyntax),
                typeof(LiteralTypeSyntax),
                typeof(TypeofTypeSyntax),
                typeof(VariadicTypePackSyntax),
                typeof(GenericTypePackSyntax),
                typeof(CompilationUnitSyntax),
            };
    }
}
