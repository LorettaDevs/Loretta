// <auto-generated />

#pragma warning disable CS1591
#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Loretta.CodeAnalysis.Syntax.InternalSyntax;
using Loretta.Utilities;

namespace Loretta.CodeAnalysis.Lua
{
    using System.Diagnostics.CodeAnalysis;
    using Loretta.CodeAnalysis.Lua.Syntax;

    public partial class LuaSyntaxVisitor<TResult>
    {
        /// <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        public virtual TResult? VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a StatementListSyntax node.</summary>
        public virtual TResult? VisitStatementList(StatementListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a NamedParameterSyntax node.</summary>
        public virtual TResult? VisitNamedParameter(NamedParameterSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a VarArgParameterSyntax node.</summary>
        public virtual TResult? VisitVarArgParameter(VarArgParameterSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        public virtual TResult? VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IdentifierKeyedTableFieldSyntax node.</summary>
        public virtual TResult? VisitIdentifierKeyedTableField(IdentifierKeyedTableFieldSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ExpressionKeyedTableFieldSyntax node.</summary>
        public virtual TResult? VisitExpressionKeyedTableField(ExpressionKeyedTableFieldSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a UnkeyedTableFieldSyntax node.</summary>
        public virtual TResult? VisitUnkeyedTableField(UnkeyedTableFieldSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SimpleFunctionNameSyntax node.</summary>
        public virtual TResult? VisitSimpleFunctionName(SimpleFunctionNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a MemberFunctionNameSyntax node.</summary>
        public virtual TResult? VisitMemberFunctionName(MemberFunctionNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a MethodFunctionNameSyntax node.</summary>
        public virtual TResult? VisitMethodFunctionName(MethodFunctionNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a StringFunctionArgumentSyntax node.</summary>
        public virtual TResult? VisitStringFunctionArgument(StringFunctionArgumentSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableConstructorFunctionArgumentSyntax node.</summary>
        public virtual TResult? VisitTableConstructorFunctionArgument(TableConstructorFunctionArgumentSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ExpressionListFunctionArgumentSyntax node.</summary>
        public virtual TResult? VisitExpressionListFunctionArgument(ExpressionListFunctionArgumentSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a InterpolatedStringTextSyntax node.</summary>
        public virtual TResult? VisitInterpolatedStringText(InterpolatedStringTextSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a InterpolationSyntax node.</summary>
        public virtual TResult? VisitInterpolation(InterpolationSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a AnonymousFunctionExpressionSyntax node.</summary>
        public virtual TResult? VisitAnonymousFunctionExpression(AnonymousFunctionExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableConstructorExpressionSyntax node.</summary>
        public virtual TResult? VisitTableConstructorExpression(TableConstructorExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        public virtual TResult? VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a InterpolatedStringExpressionSyntax node.</summary>
        public virtual TResult? VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a VarArgExpressionSyntax node.</summary>
        public virtual TResult? VisitVarArgExpression(VarArgExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        public virtual TResult? VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
        public virtual TResult? VisitMemberAccessExpression(MemberAccessExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
        public virtual TResult? VisitElementAccessExpression(ElementAccessExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a UnaryExpressionSyntax node.</summary>
        public virtual TResult? VisitUnaryExpression(UnaryExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        public virtual TResult? VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElseIfExpressionClauseSyntax node.</summary>
        public virtual TResult? VisitElseIfExpressionClause(ElseIfExpressionClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IfExpressionSyntax node.</summary>
        public virtual TResult? VisitIfExpression(IfExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        public virtual TResult? VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FunctionCallExpressionSyntax node.</summary>
        public virtual TResult? VisitFunctionCallExpression(FunctionCallExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a MethodCallExpressionSyntax node.</summary>
        public virtual TResult? VisitMethodCallExpression(MethodCallExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a VariableAttributeSyntax node.</summary>
        public virtual TResult? VisitVariableAttribute(VariableAttributeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LocalDeclarationNameSyntax node.</summary>
        public virtual TResult? VisitLocalDeclarationName(LocalDeclarationNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a EqualsValuesClauseSyntax node.</summary>
        public virtual TResult? VisitEqualsValuesClause(EqualsValuesClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a AssignmentStatementSyntax node.</summary>
        public virtual TResult? VisitAssignmentStatement(AssignmentStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a CompoundAssignmentStatementSyntax node.</summary>
        public virtual TResult? VisitCompoundAssignmentStatement(CompoundAssignmentStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LocalVariableDeclarationStatementSyntax node.</summary>
        public virtual TResult? VisitLocalVariableDeclarationStatement(LocalVariableDeclarationStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypedIdentifierNameSyntax node.</summary>
        public virtual TResult? VisitTypedIdentifierName(TypedIdentifierNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a NumericForStatementSyntax node.</summary>
        public virtual TResult? VisitNumericForStatement(NumericForStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a GenericForStatementSyntax node.</summary>
        public virtual TResult? VisitGenericForStatement(GenericForStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        public virtual TResult? VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a RepeatUntilStatementSyntax node.</summary>
        public virtual TResult? VisitRepeatUntilStatement(RepeatUntilStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        public virtual TResult? VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElseIfClauseSyntax node.</summary>
        public virtual TResult? VisitElseIfClause(ElseIfClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        public virtual TResult? VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        public virtual TResult? VisitGotoStatement(GotoStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        public virtual TResult? VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        public virtual TResult? VisitReturnStatement(ReturnStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
        public virtual TResult? VisitContinueStatement(ContinueStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LocalFunctionDeclarationStatementSyntax node.</summary>
        public virtual TResult? VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FunctionDeclarationStatementSyntax node.</summary>
        public virtual TResult? VisitFunctionDeclarationStatement(FunctionDeclarationStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        public virtual TResult? VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a GotoLabelStatementSyntax node.</summary>
        public virtual TResult? VisitGotoLabelStatement(GotoLabelStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
        public virtual TResult? VisitExpressionStatement(ExpressionStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        public virtual TResult? VisitEmptyStatement(EmptyStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeDeclarationStatementSyntax node.</summary>
        public virtual TResult? VisitTypeDeclarationStatement(TypeDeclarationStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeBindingSyntax node.</summary>
        public virtual TResult? VisitTypeBinding(TypeBindingSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SimpleTypeNameSyntax node.</summary>
        public virtual TResult? VisitSimpleTypeName(SimpleTypeNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a CompositeTypeNameSyntax node.</summary>
        public virtual TResult? VisitCompositeTypeName(CompositeTypeNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a NilableTypeSyntax node.</summary>
        public virtual TResult? VisitNilableType(NilableTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParenthesizedTypeSyntax node.</summary>
        public virtual TResult? VisitParenthesizedType(ParenthesizedTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypePackSyntax node.</summary>
        public virtual TResult? VisitTypePack(TypePackSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FunctionTypeSyntax node.</summary>
        public virtual TResult? VisitFunctionType(FunctionTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
        public virtual TResult? VisitArrayType(ArrayTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableTypeIndexerSyntax node.</summary>
        public virtual TResult? VisitTableTypeIndexer(TableTypeIndexerSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableTypePropertySyntax node.</summary>
        public virtual TResult? VisitTableTypeProperty(TableTypePropertySyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableTypeSyntax node.</summary>
        public virtual TResult? VisitTableType(TableTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeCastExpressionSyntax node.</summary>
        public virtual TResult? VisitTypeCastExpression(TypeCastExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a UnionTypeSyntax node.</summary>
        public virtual TResult? VisitUnionType(UnionTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IntersectionTypeSyntax node.</summary>
        public virtual TResult? VisitIntersectionType(IntersectionTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a EqualsTypeSyntax node.</summary>
        public virtual TResult? VisitEqualsType(EqualsTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
        public virtual TResult? VisitTypeParameter(TypeParameterSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
        public virtual TResult? VisitTypeParameterList(TypeParameterListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
        public virtual TResult? VisitTypeArgumentList(TypeArgumentListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LiteralTypeSyntax node.</summary>
        public virtual TResult? VisitLiteralType(LiteralTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeofTypeSyntax node.</summary>
        public virtual TResult? VisitTypeofType(TypeofTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a VariadicTypePackSyntax node.</summary>
        public virtual TResult? VisitVariadicTypePack(VariadicTypePackSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a GenericTypePackSyntax node.</summary>
        public virtual TResult? VisitGenericTypePack(GenericTypePackSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
        public virtual TResult? VisitCompilationUnit(CompilationUnitSyntax node) => this.DefaultVisit(node);
    }

    public partial class LuaSyntaxVisitor
    {
        /// <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a StatementListSyntax node.</summary>
        public virtual void VisitStatementList(StatementListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a NamedParameterSyntax node.</summary>
        public virtual void VisitNamedParameter(NamedParameterSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a VarArgParameterSyntax node.</summary>
        public virtual void VisitVarArgParameter(VarArgParameterSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        public virtual void VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IdentifierKeyedTableFieldSyntax node.</summary>
        public virtual void VisitIdentifierKeyedTableField(IdentifierKeyedTableFieldSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ExpressionKeyedTableFieldSyntax node.</summary>
        public virtual void VisitExpressionKeyedTableField(ExpressionKeyedTableFieldSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a UnkeyedTableFieldSyntax node.</summary>
        public virtual void VisitUnkeyedTableField(UnkeyedTableFieldSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SimpleFunctionNameSyntax node.</summary>
        public virtual void VisitSimpleFunctionName(SimpleFunctionNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a MemberFunctionNameSyntax node.</summary>
        public virtual void VisitMemberFunctionName(MemberFunctionNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a MethodFunctionNameSyntax node.</summary>
        public virtual void VisitMethodFunctionName(MethodFunctionNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a StringFunctionArgumentSyntax node.</summary>
        public virtual void VisitStringFunctionArgument(StringFunctionArgumentSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableConstructorFunctionArgumentSyntax node.</summary>
        public virtual void VisitTableConstructorFunctionArgument(TableConstructorFunctionArgumentSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ExpressionListFunctionArgumentSyntax node.</summary>
        public virtual void VisitExpressionListFunctionArgument(ExpressionListFunctionArgumentSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a InterpolatedStringTextSyntax node.</summary>
        public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a InterpolationSyntax node.</summary>
        public virtual void VisitInterpolation(InterpolationSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a AnonymousFunctionExpressionSyntax node.</summary>
        public virtual void VisitAnonymousFunctionExpression(AnonymousFunctionExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableConstructorExpressionSyntax node.</summary>
        public virtual void VisitTableConstructorExpression(TableConstructorExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        public virtual void VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a InterpolatedStringExpressionSyntax node.</summary>
        public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a VarArgExpressionSyntax node.</summary>
        public virtual void VisitVarArgExpression(VarArgExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        public virtual void VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
        public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
        public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a UnaryExpressionSyntax node.</summary>
        public virtual void VisitUnaryExpression(UnaryExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        public virtual void VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElseIfExpressionClauseSyntax node.</summary>
        public virtual void VisitElseIfExpressionClause(ElseIfExpressionClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IfExpressionSyntax node.</summary>
        public virtual void VisitIfExpression(IfExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FunctionCallExpressionSyntax node.</summary>
        public virtual void VisitFunctionCallExpression(FunctionCallExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a MethodCallExpressionSyntax node.</summary>
        public virtual void VisitMethodCallExpression(MethodCallExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a VariableAttributeSyntax node.</summary>
        public virtual void VisitVariableAttribute(VariableAttributeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LocalDeclarationNameSyntax node.</summary>
        public virtual void VisitLocalDeclarationName(LocalDeclarationNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a EqualsValuesClauseSyntax node.</summary>
        public virtual void VisitEqualsValuesClause(EqualsValuesClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a AssignmentStatementSyntax node.</summary>
        public virtual void VisitAssignmentStatement(AssignmentStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a CompoundAssignmentStatementSyntax node.</summary>
        public virtual void VisitCompoundAssignmentStatement(CompoundAssignmentStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LocalVariableDeclarationStatementSyntax node.</summary>
        public virtual void VisitLocalVariableDeclarationStatement(LocalVariableDeclarationStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypedIdentifierNameSyntax node.</summary>
        public virtual void VisitTypedIdentifierName(TypedIdentifierNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a NumericForStatementSyntax node.</summary>
        public virtual void VisitNumericForStatement(NumericForStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a GenericForStatementSyntax node.</summary>
        public virtual void VisitGenericForStatement(GenericForStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        public virtual void VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a RepeatUntilStatementSyntax node.</summary>
        public virtual void VisitRepeatUntilStatement(RepeatUntilStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        public virtual void VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElseIfClauseSyntax node.</summary>
        public virtual void VisitElseIfClause(ElseIfClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        public virtual void VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        public virtual void VisitGotoStatement(GotoStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        public virtual void VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        public virtual void VisitReturnStatement(ReturnStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
        public virtual void VisitContinueStatement(ContinueStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LocalFunctionDeclarationStatementSyntax node.</summary>
        public virtual void VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FunctionDeclarationStatementSyntax node.</summary>
        public virtual void VisitFunctionDeclarationStatement(FunctionDeclarationStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        public virtual void VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a GotoLabelStatementSyntax node.</summary>
        public virtual void VisitGotoLabelStatement(GotoLabelStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
        public virtual void VisitExpressionStatement(ExpressionStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        public virtual void VisitEmptyStatement(EmptyStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeDeclarationStatementSyntax node.</summary>
        public virtual void VisitTypeDeclarationStatement(TypeDeclarationStatementSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeBindingSyntax node.</summary>
        public virtual void VisitTypeBinding(TypeBindingSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a SimpleTypeNameSyntax node.</summary>
        public virtual void VisitSimpleTypeName(SimpleTypeNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a CompositeTypeNameSyntax node.</summary>
        public virtual void VisitCompositeTypeName(CompositeTypeNameSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a NilableTypeSyntax node.</summary>
        public virtual void VisitNilableType(NilableTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ParenthesizedTypeSyntax node.</summary>
        public virtual void VisitParenthesizedType(ParenthesizedTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypePackSyntax node.</summary>
        public virtual void VisitTypePack(TypePackSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a FunctionTypeSyntax node.</summary>
        public virtual void VisitFunctionType(FunctionTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
        public virtual void VisitArrayType(ArrayTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableTypeIndexerSyntax node.</summary>
        public virtual void VisitTableTypeIndexer(TableTypeIndexerSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableTypePropertySyntax node.</summary>
        public virtual void VisitTableTypeProperty(TableTypePropertySyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TableTypeSyntax node.</summary>
        public virtual void VisitTableType(TableTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeCastExpressionSyntax node.</summary>
        public virtual void VisitTypeCastExpression(TypeCastExpressionSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a UnionTypeSyntax node.</summary>
        public virtual void VisitUnionType(UnionTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a IntersectionTypeSyntax node.</summary>
        public virtual void VisitIntersectionType(IntersectionTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a EqualsTypeSyntax node.</summary>
        public virtual void VisitEqualsType(EqualsTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
        public virtual void VisitTypeParameter(TypeParameterSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
        public virtual void VisitTypeParameterList(TypeParameterListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
        public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a LiteralTypeSyntax node.</summary>
        public virtual void VisitLiteralType(LiteralTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a TypeofTypeSyntax node.</summary>
        public virtual void VisitTypeofType(TypeofTypeSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a VariadicTypePackSyntax node.</summary>
        public virtual void VisitVariadicTypePack(VariadicTypePackSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a GenericTypePackSyntax node.</summary>
        public virtual void VisitGenericTypePack(GenericTypePackSyntax node) => this.DefaultVisit(node);

        /// <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
        public virtual void VisitCompilationUnit(CompilationUnitSyntax node) => this.DefaultVisit(node);
    }

    public partial class LuaSyntaxRewriter : LuaSyntaxVisitor<SyntaxNode?>
    {
        public override SyntaxNode? VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
            => node.Update(VisitList(node.Tokens));

        public override SyntaxNode? VisitStatementList(StatementListSyntax node)
            => node.Update(VisitList(node.Statements));

        public override SyntaxNode? VisitNamedParameter(NamedParameterSyntax node)
            => node.Update(VisitToken(node.Identifier), (TypeBindingSyntax?)Visit(node.TypeBinding));

        public override SyntaxNode? VisitVarArgParameter(VarArgParameterSyntax node)
            => node.Update(VisitToken(node.VarArgToken), (TypeBindingSyntax?)Visit(node.TypeBinding));

        public override SyntaxNode? VisitParameterList(ParameterListSyntax node)
            => node.Update(VisitToken(node.OpenParenthesisToken), VisitList(node.Parameters), VisitToken(node.CloseParenthesisToken));

        public override SyntaxNode? VisitIdentifierKeyedTableField(IdentifierKeyedTableFieldSyntax node)
            => node.Update(VisitToken(node.Identifier), VisitToken(node.EqualsToken), (ExpressionSyntax?)Visit(node.Value) ?? throw new ArgumentNullException("value"));

        public override SyntaxNode? VisitExpressionKeyedTableField(ExpressionKeyedTableFieldSyntax node)
            => node.Update(VisitToken(node.OpenBracketToken), (ExpressionSyntax?)Visit(node.Key) ?? throw new ArgumentNullException("key"), VisitToken(node.CloseBracketToken), VisitToken(node.EqualsToken), (ExpressionSyntax?)Visit(node.Value) ?? throw new ArgumentNullException("value"));

        public override SyntaxNode? VisitUnkeyedTableField(UnkeyedTableFieldSyntax node)
            => node.Update((ExpressionSyntax?)Visit(node.Value) ?? throw new ArgumentNullException("value"));

        public override SyntaxNode? VisitSimpleFunctionName(SimpleFunctionNameSyntax node)
            => node.Update(VisitToken(node.Name));

        public override SyntaxNode? VisitMemberFunctionName(MemberFunctionNameSyntax node)
            => node.Update((FunctionNameSyntax?)Visit(node.BaseName) ?? throw new ArgumentNullException("baseName"), VisitToken(node.DotToken), VisitToken(node.Name));

        public override SyntaxNode? VisitMethodFunctionName(MethodFunctionNameSyntax node)
            => node.Update((FunctionNameSyntax?)Visit(node.BaseName) ?? throw new ArgumentNullException("baseName"), VisitToken(node.ColonToken), VisitToken(node.Name));

        public override SyntaxNode? VisitStringFunctionArgument(StringFunctionArgumentSyntax node)
            => node.Update((LiteralExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"));

        public override SyntaxNode? VisitTableConstructorFunctionArgument(TableConstructorFunctionArgumentSyntax node)
            => node.Update((TableConstructorExpressionSyntax?)Visit(node.TableConstructor) ?? throw new ArgumentNullException("tableConstructor"));

        public override SyntaxNode? VisitExpressionListFunctionArgument(ExpressionListFunctionArgumentSyntax node)
            => node.Update(VisitToken(node.OpenParenthesisToken), VisitList(node.Expressions), VisitToken(node.CloseParenthesisToken));

        public override SyntaxNode? VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
            => node.Update(VisitToken(node.TextToken));

        public override SyntaxNode? VisitInterpolation(InterpolationSyntax node)
            => node.Update(VisitToken(node.OpenBraceToken), (ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.CloseBraceToken));

        public override SyntaxNode? VisitAnonymousFunctionExpression(AnonymousFunctionExpressionSyntax node)
            => node.Update(VisitToken(node.FunctionKeyword), (TypeParameterListSyntax?)Visit(node.TypeParameterList), (ParameterListSyntax?)Visit(node.Parameters) ?? throw new ArgumentNullException("parameters"), (TypeBindingSyntax?)Visit(node.TypeBinding), (StatementListSyntax?)Visit(node.Body) ?? throw new ArgumentNullException("body"), VisitToken(node.EndKeyword));

        public override SyntaxNode? VisitTableConstructorExpression(TableConstructorExpressionSyntax node)
            => node.Update(VisitToken(node.OpenBraceToken), VisitList(node.Fields), VisitToken(node.CloseBraceToken));

        public override SyntaxNode? VisitLiteralExpression(LiteralExpressionSyntax node)
            => node.Update(VisitToken(node.Token));

        public override SyntaxNode? VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
            => node.Update(VisitToken(node.StringStartToken), VisitList(node.Contents), VisitToken(node.StringEndToken));

        public override SyntaxNode? VisitVarArgExpression(VarArgExpressionSyntax node)
            => node.Update(VisitToken(node.VarArgToken));

        public override SyntaxNode? VisitIdentifierName(IdentifierNameSyntax node)
            => node.Update(VisitToken(node.Identifier));

        public override SyntaxNode? VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
            => node.Update((PrefixExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.DotSeparator), VisitToken(node.MemberName));

        public override SyntaxNode? VisitElementAccessExpression(ElementAccessExpressionSyntax node)
            => node.Update((PrefixExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.OpenBracketToken), (ExpressionSyntax?)Visit(node.KeyExpression) ?? throw new ArgumentNullException("keyExpression"), VisitToken(node.CloseBracketToken));

        public override SyntaxNode? VisitUnaryExpression(UnaryExpressionSyntax node)
            => node.Update(VisitToken(node.OperatorToken), (ExpressionSyntax?)Visit(node.Operand) ?? throw new ArgumentNullException("operand"));

        public override SyntaxNode? VisitBinaryExpression(BinaryExpressionSyntax node)
            => node.Update((ExpressionSyntax?)Visit(node.Left) ?? throw new ArgumentNullException("left"), VisitToken(node.OperatorToken), (ExpressionSyntax?)Visit(node.Right) ?? throw new ArgumentNullException("right"));

        public override SyntaxNode? VisitElseIfExpressionClause(ElseIfExpressionClauseSyntax node)
            => node.Update(VisitToken(node.ElseIfKeyword), (ExpressionSyntax?)Visit(node.Condition) ?? throw new ArgumentNullException("condition"), VisitToken(node.ThenKeyword), (ExpressionSyntax?)Visit(node.Value) ?? throw new ArgumentNullException("value"));

        public override SyntaxNode? VisitIfExpression(IfExpressionSyntax node)
            => node.Update(VisitToken(node.IfKeyword), (ExpressionSyntax?)Visit(node.Condition) ?? throw new ArgumentNullException("condition"), VisitToken(node.ThenKeyword), (ExpressionSyntax?)Visit(node.TrueValue) ?? throw new ArgumentNullException("trueValue"), VisitList(node.ElseIfClauses), VisitToken(node.ElseKeyword), (ExpressionSyntax?)Visit(node.FalseValue) ?? throw new ArgumentNullException("falseValue"));

        public override SyntaxNode? VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
            => node.Update(VisitToken(node.OpenParenthesisToken), (ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.CloseParenthesisToken));

        public override SyntaxNode? VisitFunctionCallExpression(FunctionCallExpressionSyntax node)
            => node.Update((PrefixExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), (FunctionArgumentSyntax?)Visit(node.Argument) ?? throw new ArgumentNullException("argument"));

        public override SyntaxNode? VisitMethodCallExpression(MethodCallExpressionSyntax node)
            => node.Update((PrefixExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.ColonToken), VisitToken(node.Identifier), (FunctionArgumentSyntax?)Visit(node.Argument) ?? throw new ArgumentNullException("argument"));

        public override SyntaxNode? VisitVariableAttribute(VariableAttributeSyntax node)
            => node.Update(VisitToken(node.LessThanToken), VisitToken(node.Identifier), VisitToken(node.GreaterThanToken));

        public override SyntaxNode? VisitLocalDeclarationName(LocalDeclarationNameSyntax node)
            => node.Update((IdentifierNameSyntax?)Visit(node.IdentifierName) ?? throw new ArgumentNullException("identifierName"), (VariableAttributeSyntax?)Visit(node.Attribute), (TypeBindingSyntax?)Visit(node.TypeBinding));

        public override SyntaxNode? VisitEqualsValuesClause(EqualsValuesClauseSyntax node)
            => node.Update(VisitToken(node.EqualsToken), VisitList(node.Values));

        public override SyntaxNode? VisitAssignmentStatement(AssignmentStatementSyntax node)
            => node.Update(VisitList(node.Variables), (EqualsValuesClauseSyntax?)Visit(node.EqualsValues) ?? throw new ArgumentNullException("equalsValues"), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitCompoundAssignmentStatement(CompoundAssignmentStatementSyntax node)
            => node.Update((PrefixExpressionSyntax?)Visit(node.Variable) ?? throw new ArgumentNullException("variable"), VisitToken(node.AssignmentOperatorToken), (ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitLocalVariableDeclarationStatement(LocalVariableDeclarationStatementSyntax node)
            => node.Update(VisitToken(node.LocalKeyword), VisitList(node.Names), (EqualsValuesClauseSyntax?)Visit(node.EqualsValues), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitTypedIdentifierName(TypedIdentifierNameSyntax node)
            => node.Update((IdentifierNameSyntax?)Visit(node.IdentifierName) ?? throw new ArgumentNullException("identifierName"), (TypeBindingSyntax?)Visit(node.TypeBinding));

        public override SyntaxNode? VisitNumericForStatement(NumericForStatementSyntax node)
            => node.Update(VisitToken(node.ForKeyword), (TypedIdentifierNameSyntax?)Visit(node.Identifier) ?? throw new ArgumentNullException("identifier"), VisitToken(node.EqualsToken), (ExpressionSyntax?)Visit(node.InitialValue) ?? throw new ArgumentNullException("initialValue"), VisitToken(node.FinalValueCommaToken), (ExpressionSyntax?)Visit(node.FinalValue) ?? throw new ArgumentNullException("finalValue"), VisitToken(node.StepValueCommaToken), (ExpressionSyntax?)Visit(node.StepValue), VisitToken(node.DoKeyword), (StatementListSyntax?)Visit(node.Body) ?? throw new ArgumentNullException("body"), VisitToken(node.EndKeyword), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitGenericForStatement(GenericForStatementSyntax node)
            => node.Update(VisitToken(node.ForKeyword), VisitList(node.Identifiers), VisitToken(node.InKeyword), VisitList(node.Expressions), VisitToken(node.DoKeyword), (StatementListSyntax?)Visit(node.Body) ?? throw new ArgumentNullException("body"), VisitToken(node.EndKeyword), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitWhileStatement(WhileStatementSyntax node)
            => node.Update(VisitToken(node.WhileKeyword), (ExpressionSyntax?)Visit(node.Condition) ?? throw new ArgumentNullException("condition"), VisitToken(node.DoKeyword), (StatementListSyntax?)Visit(node.Body) ?? throw new ArgumentNullException("body"), VisitToken(node.EndKeyword), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitRepeatUntilStatement(RepeatUntilStatementSyntax node)
            => node.Update(VisitToken(node.RepeatKeyword), (StatementListSyntax?)Visit(node.Body) ?? throw new ArgumentNullException("body"), VisitToken(node.UntilKeyword), (ExpressionSyntax?)Visit(node.Condition) ?? throw new ArgumentNullException("condition"), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitIfStatement(IfStatementSyntax node)
            => node.Update(VisitToken(node.IfKeyword), (ExpressionSyntax?)Visit(node.Condition) ?? throw new ArgumentNullException("condition"), VisitToken(node.ThenKeyword), (StatementListSyntax?)Visit(node.Body) ?? throw new ArgumentNullException("body"), VisitList(node.ElseIfClauses), (ElseClauseSyntax?)Visit(node.ElseClause), VisitToken(node.EndKeyword), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitElseIfClause(ElseIfClauseSyntax node)
            => node.Update(VisitToken(node.ElseIfKeyword), (ExpressionSyntax?)Visit(node.Condition) ?? throw new ArgumentNullException("condition"), VisitToken(node.ThenKeyword), (StatementListSyntax?)Visit(node.Body) ?? throw new ArgumentNullException("body"));

        public override SyntaxNode? VisitElseClause(ElseClauseSyntax node)
            => node.Update(VisitToken(node.ElseKeyword), (StatementListSyntax?)Visit(node.ElseBody) ?? throw new ArgumentNullException("elseBody"));

        public override SyntaxNode? VisitGotoStatement(GotoStatementSyntax node)
            => node.Update(VisitToken(node.GotoKeyword), VisitToken(node.LabelName), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitBreakStatement(BreakStatementSyntax node)
            => node.Update(VisitToken(node.BreakKeyword), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitReturnStatement(ReturnStatementSyntax node)
            => node.Update(VisitToken(node.ReturnKeyword), VisitList(node.Expressions), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitContinueStatement(ContinueStatementSyntax node)
            => node.Update(VisitToken(node.ContinueKeyword), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatementSyntax node)
            => node.Update(VisitToken(node.LocalKeyword), VisitToken(node.FunctionKeyword), (IdentifierNameSyntax?)Visit(node.Name) ?? throw new ArgumentNullException("name"), (TypeParameterListSyntax?)Visit(node.TypeParameterList), (ParameterListSyntax?)Visit(node.Parameters) ?? throw new ArgumentNullException("parameters"), (TypeBindingSyntax?)Visit(node.TypeBinding), (StatementListSyntax?)Visit(node.Body) ?? throw new ArgumentNullException("body"), VisitToken(node.EndKeyword), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitFunctionDeclarationStatement(FunctionDeclarationStatementSyntax node)
            => node.Update(VisitToken(node.FunctionKeyword), (FunctionNameSyntax?)Visit(node.Name) ?? throw new ArgumentNullException("name"), (TypeParameterListSyntax?)Visit(node.TypeParameterList), (ParameterListSyntax?)Visit(node.Parameters) ?? throw new ArgumentNullException("parameters"), (TypeBindingSyntax?)Visit(node.TypeBinding), (StatementListSyntax?)Visit(node.Body) ?? throw new ArgumentNullException("body"), VisitToken(node.EndKeyword), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitDoStatement(DoStatementSyntax node)
            => node.Update(VisitToken(node.DoKeyword), (StatementListSyntax?)Visit(node.Body) ?? throw new ArgumentNullException("body"), VisitToken(node.EndKeyword), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitGotoLabelStatement(GotoLabelStatementSyntax node)
            => node.Update(VisitToken(node.LeftDelimiterToken), VisitToken(node.Identifier), VisitToken(node.RightDelimiterToken), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitExpressionStatement(ExpressionStatementSyntax node)
            => node.Update((ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitEmptyStatement(EmptyStatementSyntax node)
            => node.Update(VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitTypeDeclarationStatement(TypeDeclarationStatementSyntax node)
            => node.Update(VisitToken(node.ExportKeyword), VisitToken(node.TypeKeyword), VisitToken(node.Name), (TypeParameterListSyntax?)Visit(node.TypeParameterList), VisitToken(node.EqualsToken), (TypeSyntax?)Visit(node.Type) ?? throw new ArgumentNullException("type"), VisitToken(node.SemicolonToken));

        public override SyntaxNode? VisitTypeBinding(TypeBindingSyntax node)
            => node.Update(VisitToken(node.ColonToken), (TypeSyntax?)Visit(node.Type) ?? throw new ArgumentNullException("type"));

        public override SyntaxNode? VisitSimpleTypeName(SimpleTypeNameSyntax node)
            => node.Update(VisitToken(node.IdentifierToken), (TypeArgumentListSyntax?)Visit(node.TypeArgumentList));

        public override SyntaxNode? VisitCompositeTypeName(CompositeTypeNameSyntax node)
            => node.Update((TypeNameSyntax?)Visit(node.Base) ?? throw new ArgumentNullException("@base"), VisitToken(node.DotToken), VisitToken(node.IdentifierToken), (TypeArgumentListSyntax?)Visit(node.TypeArgumentList));

        public override SyntaxNode? VisitNilableType(NilableTypeSyntax node)
            => node.Update((TypeSyntax?)Visit(node.Type) ?? throw new ArgumentNullException("type"), VisitToken(node.QuestionToken));

        public override SyntaxNode? VisitParenthesizedType(ParenthesizedTypeSyntax node)
            => node.Update(VisitToken(node.OpenParenthesisToken), (TypeSyntax?)Visit(node.Type) ?? throw new ArgumentNullException("type"), VisitToken(node.CloseParenthesisToken));

        public override SyntaxNode? VisitTypePack(TypePackSyntax node)
            => node.Update(VisitToken(node.OpenParenthesisToken), VisitList(node.Types), VisitToken(node.CloseParenthesisToken));

        public override SyntaxNode? VisitFunctionType(FunctionTypeSyntax node)
            => node.Update((TypeParameterListSyntax?)Visit(node.TypeParameterList), VisitToken(node.OpenParenthesisToken), VisitList(node.Parameters), VisitToken(node.CloseParenthesisToken), VisitToken(node.MinusGreaterThanToken), (TypeSyntax?)Visit(node.ReturnType) ?? throw new ArgumentNullException("returnType"));

        public override SyntaxNode? VisitArrayType(ArrayTypeSyntax node)
            => node.Update(VisitToken(node.OpenBraceToken), (TypeSyntax?)Visit(node.Type) ?? throw new ArgumentNullException("type"), VisitToken(node.CloseBraceToken));

        public override SyntaxNode? VisitTableTypeIndexer(TableTypeIndexerSyntax node)
            => node.Update(VisitToken(node.OpenBracketToken), (TypeSyntax?)Visit(node.IndexType) ?? throw new ArgumentNullException("indexType"), VisitToken(node.CloseBracketToken), VisitToken(node.ColonToken), (TypeSyntax?)Visit(node.ValueType) ?? throw new ArgumentNullException("valueType"));

        public override SyntaxNode? VisitTableTypeProperty(TableTypePropertySyntax node)
            => node.Update(VisitToken(node.Identifier), VisitToken(node.ColonToken), (TypeSyntax?)Visit(node.ValueType) ?? throw new ArgumentNullException("valueType"));

        public override SyntaxNode? VisitTableType(TableTypeSyntax node)
            => node.Update(VisitToken(node.OpenBraceToken), VisitList(node.Elements), VisitToken(node.CloseBraceToken));

        public override SyntaxNode? VisitTypeCastExpression(TypeCastExpressionSyntax node)
            => node.Update((ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.ColonColonToken), (TypeSyntax?)Visit(node.Type) ?? throw new ArgumentNullException("type"));

        public override SyntaxNode? VisitUnionType(UnionTypeSyntax node)
            => node.Update((TypeSyntax?)Visit(node.Left) ?? throw new ArgumentNullException("left"), VisitToken(node.PipeToken), (TypeSyntax?)Visit(node.Right) ?? throw new ArgumentNullException("right"));

        public override SyntaxNode? VisitIntersectionType(IntersectionTypeSyntax node)
            => node.Update((TypeSyntax?)Visit(node.Left) ?? throw new ArgumentNullException("left"), VisitToken(node.AmpersandToken), (TypeSyntax?)Visit(node.Right) ?? throw new ArgumentNullException("right"));

        public override SyntaxNode? VisitEqualsType(EqualsTypeSyntax node)
            => node.Update(VisitToken(node.EqualsToken), (TypeSyntax?)Visit(node.Type) ?? throw new ArgumentNullException("type"));

        public override SyntaxNode? VisitTypeParameter(TypeParameterSyntax node)
            => node.Update(VisitToken(node.Identifier), VisitToken(node.DotDotDotToken), (EqualsTypeSyntax?)Visit(node.EqualsType));

        public override SyntaxNode? VisitTypeParameterList(TypeParameterListSyntax node)
            => node.Update(VisitToken(node.LessThanToken), VisitList(node.Names), VisitToken(node.GreaterThanToken));

        public override SyntaxNode? VisitTypeArgumentList(TypeArgumentListSyntax node)
            => node.Update(VisitToken(node.LessThanToken), VisitList(node.Arguments), VisitToken(node.GreaterThanToken));

        public override SyntaxNode? VisitLiteralType(LiteralTypeSyntax node)
            => node.Update(VisitToken(node.Token));

        public override SyntaxNode? VisitTypeofType(TypeofTypeSyntax node)
            => node.Update(VisitToken(node.TypeofKeyword), VisitToken(node.OpenParenthesisToken), (ExpressionSyntax?)Visit(node.Expression) ?? throw new ArgumentNullException("expression"), VisitToken(node.CloseParenthesisToken));

        public override SyntaxNode? VisitVariadicTypePack(VariadicTypePackSyntax node)
            => node.Update(VisitToken(node.DotDotDotToken), (TypeSyntax?)Visit(node.Type) ?? throw new ArgumentNullException("type"));

        public override SyntaxNode? VisitGenericTypePack(GenericTypePackSyntax node)
            => node.Update(VisitToken(node.Identifier), VisitToken(node.DotDotDotToken));

        public override SyntaxNode? VisitCompilationUnit(CompilationUnitSyntax node)
            => node.Update((StatementListSyntax?)Visit(node.Statements) ?? throw new ArgumentNullException("statements"), VisitToken(node.EndOfFileToken));
    }

    public static partial class SyntaxFactory
    {

        public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens)
        {
            return (SkippedTokensTriviaSyntax)Syntax.InternalSyntax.SyntaxFactory.SkippedTokensTrivia(tokens.Node.ToGreenList<Syntax.InternalSyntax.SyntaxToken>()).CreateRed();
        }

        /// <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
        public static SkippedTokensTriviaSyntax SkippedTokensTrivia()
            => SyntaxFactory.SkippedTokensTrivia(default(SyntaxTokenList));

        /// <summary>
        /// Creates a new
        /// <see cref="StatementListSyntax" />
        /// node.
        /// </summary>
        public static StatementListSyntax StatementList(SyntaxList<StatementSyntax> statements)
        {
            return (StatementListSyntax)Syntax.InternalSyntax.SyntaxFactory.StatementList(statements.Node.ToGreenList<Syntax.InternalSyntax.StatementSyntax>()).CreateRed();
        }

        /// <summary>Creates a new StatementListSyntax instance.</summary>
        public static StatementListSyntax StatementList()
            => SyntaxFactory.StatementList(default(SyntaxList<StatementSyntax>));

        /// <summary>
        /// Creates a new
        /// <see cref="NamedParameterSyntax" />
        /// node.
        /// </summary>
        public static NamedParameterSyntax NamedParameter(SyntaxToken identifier, TypeBindingSyntax? typeBinding)
        {
            if (identifier.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind()}.", nameof(identifier));
            return (NamedParameterSyntax)Syntax.InternalSyntax.SyntaxFactory.NamedParameter((Syntax.InternalSyntax.SyntaxToken)identifier.Node!, typeBinding == null ? null : (Syntax.InternalSyntax.TypeBindingSyntax)typeBinding.Green).CreateRed();
        }

        /// <summary>Creates a new NamedParameterSyntax instance.</summary>
        public static NamedParameterSyntax NamedParameter(SyntaxToken identifier)
            => SyntaxFactory.NamedParameter(identifier, default(TypeBindingSyntax?));

        /// <summary>Creates a new NamedParameterSyntax instance.</summary>
        public static NamedParameterSyntax NamedParameter(string identifier)
            => SyntaxFactory.NamedParameter(SyntaxFactory.Identifier(identifier), default(TypeBindingSyntax?));

        /// <summary>
        /// Creates a new
        /// <see cref="VarArgParameterSyntax" />
        /// node.
        /// </summary>
        public static VarArgParameterSyntax VarArgParameter(SyntaxToken varArgToken, TypeBindingSyntax? typeBinding)
        {
            if (varArgToken.Kind() != SyntaxKind.DotDotDotToken) throw new ArgumentException($"Invalid kind provided. Expected DotDotDotToken but got {varArgToken.Kind()}.", nameof(varArgToken));
            return (VarArgParameterSyntax)Syntax.InternalSyntax.SyntaxFactory.VarArgParameter((Syntax.InternalSyntax.SyntaxToken)varArgToken.Node!, typeBinding == null ? null : (Syntax.InternalSyntax.TypeBindingSyntax)typeBinding.Green).CreateRed();
        }

        /// <summary>Creates a new VarArgParameterSyntax instance.</summary>
        public static VarArgParameterSyntax VarArgParameter(TypeBindingSyntax? typeBinding = default)
            => SyntaxFactory.VarArgParameter(SyntaxFactory.Token(SyntaxKind.DotDotDotToken), typeBinding);

        /// <summary>
        /// Creates a new
        /// <see cref="ParameterListSyntax" />
        /// node.
        /// </summary>
        public static ParameterListSyntax ParameterList(SyntaxToken openParenthesisToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken.Kind() != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind()}.", nameof(openParenthesisToken));
            if (closeParenthesisToken.Kind() != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind()}.", nameof(closeParenthesisToken));
            return (ParameterListSyntax)Syntax.InternalSyntax.SyntaxFactory.ParameterList((Syntax.InternalSyntax.SyntaxToken)openParenthesisToken.Node!, parameters.Node.ToGreenSeparatedList<Syntax.InternalSyntax.ParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenthesisToken.Node!).CreateRed();
        }

        /// <summary>Creates a new ParameterListSyntax instance.</summary>
        public static ParameterListSyntax ParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default)
            => SyntaxFactory.ParameterList(SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), parameters, SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        /// <summary>
        /// Creates a new
        /// <see cref="IdentifierKeyedTableFieldSyntax" />
        /// node.
        /// </summary>
        public static IdentifierKeyedTableFieldSyntax IdentifierKeyedTableField(SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax value)
        {
            if (identifier.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind()}.", nameof(identifier));
            if (equalsToken.Kind() != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind()}.", nameof(equalsToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
            return (IdentifierKeyedTableFieldSyntax)Syntax.InternalSyntax.SyntaxFactory.IdentifierKeyedTableField((Syntax.InternalSyntax.SyntaxToken)identifier.Node!, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)value.Green).CreateRed();
        }

        /// <summary>Creates a new IdentifierKeyedTableFieldSyntax instance.</summary>
        public static IdentifierKeyedTableFieldSyntax IdentifierKeyedTableField(SyntaxToken identifier, ExpressionSyntax value)
            => SyntaxFactory.IdentifierKeyedTableField(identifier, SyntaxFactory.Token(SyntaxKind.EqualsToken), value);

        /// <summary>Creates a new IdentifierKeyedTableFieldSyntax instance.</summary>
        public static IdentifierKeyedTableFieldSyntax IdentifierKeyedTableField(string identifier, ExpressionSyntax value)
            => SyntaxFactory.IdentifierKeyedTableField(SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.EqualsToken), value);

        /// <summary>
        /// Creates a new
        /// <see cref="ExpressionKeyedTableFieldSyntax" />
        /// node.
        /// </summary>
        public static ExpressionKeyedTableFieldSyntax ExpressionKeyedTableField(SyntaxToken openBracketToken, ExpressionSyntax key, SyntaxToken closeBracketToken, SyntaxToken equalsToken, ExpressionSyntax value)
        {
            if (openBracketToken.Kind() != SyntaxKind.OpenBracketToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBracketToken but got {openBracketToken.Kind()}.", nameof(openBracketToken));
            if (key == null) throw new ArgumentNullException(nameof(key));
            if (closeBracketToken.Kind() != SyntaxKind.CloseBracketToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBracketToken but got {closeBracketToken.Kind()}.", nameof(closeBracketToken));
            if (equalsToken.Kind() != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind()}.", nameof(equalsToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
            return (ExpressionKeyedTableFieldSyntax)Syntax.InternalSyntax.SyntaxFactory.ExpressionKeyedTableField((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)key.Green, (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node!, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)value.Green).CreateRed();
        }

        /// <summary>Creates a new ExpressionKeyedTableFieldSyntax instance.</summary>
        public static ExpressionKeyedTableFieldSyntax ExpressionKeyedTableField(ExpressionSyntax key, ExpressionSyntax value)
            => SyntaxFactory.ExpressionKeyedTableField(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), key, SyntaxFactory.Token(SyntaxKind.CloseBracketToken), SyntaxFactory.Token(SyntaxKind.EqualsToken), value);

        /// <summary>
        /// Creates a new
        /// <see cref="UnkeyedTableFieldSyntax" />
        /// node.
        /// </summary>
        public static UnkeyedTableFieldSyntax UnkeyedTableField(ExpressionSyntax value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            return (UnkeyedTableFieldSyntax)Syntax.InternalSyntax.SyntaxFactory.UnkeyedTableField((Syntax.InternalSyntax.ExpressionSyntax)value.Green).CreateRed();
        }

        /// <summary>
        /// Creates a new
        /// <see cref="SimpleFunctionNameSyntax" />
        /// node.
        /// </summary>
        public static SimpleFunctionNameSyntax SimpleFunctionName(SyntaxToken name)
        {
            if (name.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {name.Kind()}.", nameof(name));
            return (SimpleFunctionNameSyntax)Syntax.InternalSyntax.SyntaxFactory.SimpleFunctionName((Syntax.InternalSyntax.SyntaxToken)name.Node!).CreateRed();
        }

        /// <summary>
        /// Creates a new
        /// <see cref="MemberFunctionNameSyntax" />
        /// node.
        /// </summary>
        public static MemberFunctionNameSyntax MemberFunctionName(FunctionNameSyntax baseName, SyntaxToken dotToken, SyntaxToken name)
        {
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
            if (dotToken.Kind() != SyntaxKind.DotToken) throw new ArgumentException($"Invalid kind provided. Expected DotToken but got {dotToken.Kind()}.", nameof(dotToken));
            if (name.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {name.Kind()}.", nameof(name));
            return (MemberFunctionNameSyntax)Syntax.InternalSyntax.SyntaxFactory.MemberFunctionName((Syntax.InternalSyntax.FunctionNameSyntax)baseName.Green, (Syntax.InternalSyntax.SyntaxToken)dotToken.Node!, (Syntax.InternalSyntax.SyntaxToken)name.Node!).CreateRed();
        }

        /// <summary>Creates a new MemberFunctionNameSyntax instance.</summary>
        public static MemberFunctionNameSyntax MemberFunctionName(FunctionNameSyntax baseName, SyntaxToken name)
            => SyntaxFactory.MemberFunctionName(baseName, SyntaxFactory.Token(SyntaxKind.DotToken), name);

        /// <summary>Creates a new MemberFunctionNameSyntax instance.</summary>
        public static MemberFunctionNameSyntax MemberFunctionName(FunctionNameSyntax baseName, string name)
            => SyntaxFactory.MemberFunctionName(baseName, SyntaxFactory.Token(SyntaxKind.DotToken), SyntaxFactory.Identifier(name));

        /// <summary>
        /// Creates a new
        /// <see cref="MethodFunctionNameSyntax" />
        /// node.
        /// </summary>
        public static MethodFunctionNameSyntax MethodFunctionName(FunctionNameSyntax baseName, SyntaxToken colonToken, SyntaxToken name)
        {
            if (baseName == null) throw new ArgumentNullException(nameof(baseName));
            if (colonToken.Kind() != SyntaxKind.ColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonToken but got {colonToken.Kind()}.", nameof(colonToken));
            if (name.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {name.Kind()}.", nameof(name));
            return (MethodFunctionNameSyntax)Syntax.InternalSyntax.SyntaxFactory.MethodFunctionName((Syntax.InternalSyntax.FunctionNameSyntax)baseName.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node!, (Syntax.InternalSyntax.SyntaxToken)name.Node!).CreateRed();
        }

        /// <summary>Creates a new MethodFunctionNameSyntax instance.</summary>
        public static MethodFunctionNameSyntax MethodFunctionName(FunctionNameSyntax baseName, SyntaxToken name)
            => SyntaxFactory.MethodFunctionName(baseName, SyntaxFactory.Token(SyntaxKind.ColonToken), name);

        /// <summary>Creates a new MethodFunctionNameSyntax instance.</summary>
        public static MethodFunctionNameSyntax MethodFunctionName(FunctionNameSyntax baseName, string name)
            => SyntaxFactory.MethodFunctionName(baseName, SyntaxFactory.Token(SyntaxKind.ColonToken), SyntaxFactory.Identifier(name));

        /// <summary>
        /// Creates a new
        /// <see cref="StringFunctionArgumentSyntax" />
        /// node.
        /// </summary>
        public static StringFunctionArgumentSyntax StringFunctionArgument(LiteralExpressionSyntax expression)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            return (StringFunctionArgumentSyntax)Syntax.InternalSyntax.SyntaxFactory.StringFunctionArgument((Syntax.InternalSyntax.LiteralExpressionSyntax)expression.Green).CreateRed();
        }

        /// <summary>
        /// Creates a new
        /// <see cref="TableConstructorFunctionArgumentSyntax" />
        /// node.
        /// </summary>
        public static TableConstructorFunctionArgumentSyntax TableConstructorFunctionArgument(TableConstructorExpressionSyntax tableConstructor)
        {
            if (tableConstructor == null) throw new ArgumentNullException(nameof(tableConstructor));
            return (TableConstructorFunctionArgumentSyntax)Syntax.InternalSyntax.SyntaxFactory.TableConstructorFunctionArgument((Syntax.InternalSyntax.TableConstructorExpressionSyntax)tableConstructor.Green).CreateRed();
        }

        /// <summary>
        /// Creates a new
        /// <see cref="ExpressionListFunctionArgumentSyntax" />
        /// node.
        /// </summary>
        public static ExpressionListFunctionArgumentSyntax ExpressionListFunctionArgument(SyntaxToken openParenthesisToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken.Kind() != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind()}.", nameof(openParenthesisToken));
            if (closeParenthesisToken.Kind() != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind()}.", nameof(closeParenthesisToken));
            return (ExpressionListFunctionArgumentSyntax)Syntax.InternalSyntax.SyntaxFactory.ExpressionListFunctionArgument((Syntax.InternalSyntax.SyntaxToken)openParenthesisToken.Node!, expressions.Node.ToGreenSeparatedList<Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenthesisToken.Node!).CreateRed();
        }

        /// <summary>Creates a new ExpressionListFunctionArgumentSyntax instance.</summary>
        public static ExpressionListFunctionArgumentSyntax ExpressionListFunctionArgument(SeparatedSyntaxList<ExpressionSyntax> expressions = default)
            => SyntaxFactory.ExpressionListFunctionArgument(SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), expressions, SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
        {
            if (textToken.Kind() != SyntaxKind.InterpolatedStringTextToken) throw new ArgumentException($"Invalid kind provided. Expected InterpolatedStringTextToken but got {textToken.Kind()}.", nameof(textToken));
            return (InterpolatedStringTextSyntax)Syntax.InternalSyntax.SyntaxFactory.InterpolatedStringText((Syntax.InternalSyntax.SyntaxToken)textToken.Node!).CreateRed();
        }

        /// <summary>Creates a new InterpolatedStringTextSyntax instance.</summary>
        public static InterpolatedStringTextSyntax InterpolatedStringText()
            => SyntaxFactory.InterpolatedStringText(SyntaxFactory.Token(SyntaxKind.InterpolatedStringTextToken));

        public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, SyntaxToken closeBraceToken)
        {
            if (openBraceToken.Kind() != SyntaxKind.OpenBraceToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBraceToken but got {openBraceToken.Kind()}.", nameof(openBraceToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeBraceToken.Kind() != SyntaxKind.CloseBraceToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBraceToken but got {closeBraceToken.Kind()}.", nameof(closeBraceToken));
            return (InterpolationSyntax)Syntax.InternalSyntax.SyntaxFactory.Interpolation((Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node!).CreateRed();
        }

        /// <summary>Creates a new InterpolationSyntax instance.</summary>
        public static InterpolationSyntax Interpolation(ExpressionSyntax expression)
            => SyntaxFactory.Interpolation(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), expression, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));

        /// <summary>
        /// Creates a new
        /// <see cref="AnonymousFunctionExpressionSyntax" />
        /// node.
        /// </summary>
        public static AnonymousFunctionExpressionSyntax AnonymousFunctionExpression(SyntaxToken functionKeyword, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword)
        {
            if (functionKeyword.Kind() != SyntaxKind.FunctionKeyword) throw new ArgumentException($"Invalid kind provided. Expected FunctionKeyword but got {functionKeyword.Kind()}.", nameof(functionKeyword));
            if (parameters == null) throw new ArgumentNullException(nameof(parameters));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind()}.", nameof(endKeyword));
            return (AnonymousFunctionExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.AnonymousFunctionExpression((Syntax.InternalSyntax.SyntaxToken)functionKeyword.Node!, typeParameterList == null ? null : (Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, (Syntax.InternalSyntax.ParameterListSyntax)parameters.Green, typeBinding == null ? null : (Syntax.InternalSyntax.TypeBindingSyntax)typeBinding.Green, (Syntax.InternalSyntax.StatementListSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!).CreateRed();
        }

        /// <summary>Creates a new AnonymousFunctionExpressionSyntax instance.</summary>
        public static AnonymousFunctionExpressionSyntax AnonymousFunctionExpression(TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body)
            => SyntaxFactory.AnonymousFunctionExpression(SyntaxFactory.Token(SyntaxKind.FunctionKeyword), typeParameterList, parameters, typeBinding, body, SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>Creates a new AnonymousFunctionExpressionSyntax instance.</summary>
        public static AnonymousFunctionExpressionSyntax AnonymousFunctionExpression(ParameterListSyntax parameters, StatementListSyntax body)
            => SyntaxFactory.AnonymousFunctionExpression(SyntaxFactory.Token(SyntaxKind.FunctionKeyword), default(TypeParameterListSyntax?), parameters, default(TypeBindingSyntax?), body, SyntaxFactory.Token(SyntaxKind.EndKeyword));

        /// <summary>
        /// Creates a new
        /// <see cref="TableConstructorExpressionSyntax" />
        /// node.
        /// </summary>
        public static TableConstructorExpressionSyntax TableConstructorExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<TableFieldSyntax> fields, SyntaxToken closeBraceToken)
        {
            if (openBraceToken.Kind() != SyntaxKind.OpenBraceToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBraceToken but got {openBraceToken.Kind()}.", nameof(openBraceToken));
            if (closeBraceToken.Kind() != SyntaxKind.CloseBraceToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBraceToken but got {closeBraceToken.Kind()}.", nameof(closeBraceToken));
            return (TableConstructorExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.TableConstructorExpression((Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node!, fields.Node.ToGreenSeparatedList<Syntax.InternalSyntax.TableFieldSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node!).CreateRed();
        }

        /// <summary>Creates a new TableConstructorExpressionSyntax instance.</summary>
        public static TableConstructorExpressionSyntax TableConstructorExpression(SeparatedSyntaxList<TableFieldSyntax> fields = default)
            => SyntaxFactory.TableConstructorExpression(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), fields, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));

        /// <summary>
        /// Creates a new
        /// <see cref="LiteralExpressionSyntax" />
        /// node.
        /// </summary>
        public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.NumericalLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.NilLiteralExpression:
                case SyntaxKind.HashStringLiteralExpression: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(kind));
            }
            switch (token.Kind())
            {
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NilKeyword:
                case SyntaxKind.HashStringLiteralToken: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(token));
            }
            return (LiteralExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.LiteralExpression(kind, (Syntax.InternalSyntax.SyntaxToken)token.Node!).CreateRed();
        }

        /// <summary>Creates a new LiteralExpressionSyntax instance.</summary>
        public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind)
            => SyntaxFactory.LiteralExpression(kind, SyntaxFactory.Token(GetLiteralExpressionTokenKind(kind)));

        private static SyntaxKind GetLiteralExpressionTokenKind(SyntaxKind kind)
            => kind switch
            {
                SyntaxKind.NumericalLiteralExpression => SyntaxKind.NumericLiteralToken,
                SyntaxKind.StringLiteralExpression => SyntaxKind.StringLiteralToken,
                SyntaxKind.TrueLiteralExpression => SyntaxKind.TrueKeyword,
                SyntaxKind.FalseLiteralExpression => SyntaxKind.FalseKeyword,
                SyntaxKind.NilLiteralExpression => SyntaxKind.NilKeyword,
                SyntaxKind.HashStringLiteralExpression => SyntaxKind.HashStringLiteralToken,
                _ => throw new ArgumentOutOfRangeException(),
            };

        public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
        {
            if (stringStartToken.Kind() != SyntaxKind.BacktickToken) throw new ArgumentException($"Invalid kind provided. Expected BacktickToken but got {stringStartToken.Kind()}.", nameof(stringStartToken));
            if (stringEndToken.Kind() != SyntaxKind.BacktickToken) throw new ArgumentException($"Invalid kind provided. Expected BacktickToken but got {stringEndToken.Kind()}.", nameof(stringEndToken));
            return (InterpolatedStringExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.InterpolatedStringExpression((Syntax.InternalSyntax.SyntaxToken)stringStartToken.Node!, contents.Node.ToGreenList<Syntax.InternalSyntax.InterpolatedStringContentSyntax>(), (Syntax.InternalSyntax.SyntaxToken)stringEndToken.Node!).CreateRed();
        }

        /// <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
        public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxList<InterpolatedStringContentSyntax> contents = default)
            => SyntaxFactory.InterpolatedStringExpression(SyntaxFactory.Token(SyntaxKind.BacktickToken), contents, SyntaxFactory.Token(SyntaxKind.BacktickToken));

        /// <summary>
        /// Creates a new
        /// <see cref="VarArgExpressionSyntax" />
        /// node.
        /// </summary>
        public static VarArgExpressionSyntax VarArgExpression(SyntaxToken varArgToken)
        {
            if (varArgToken.Kind() != SyntaxKind.DotDotDotToken) throw new ArgumentException($"Invalid kind provided. Expected DotDotDotToken but got {varArgToken.Kind()}.", nameof(varArgToken));
            return (VarArgExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.VarArgExpression((Syntax.InternalSyntax.SyntaxToken)varArgToken.Node!).CreateRed();
        }

        /// <summary>Creates a new VarArgExpressionSyntax instance.</summary>
        public static VarArgExpressionSyntax VarArgExpression()
            => SyntaxFactory.VarArgExpression(SyntaxFactory.Token(SyntaxKind.DotDotDotToken));

        /// <summary>
        /// Creates a new
        /// <see cref="IdentifierNameSyntax" />
        /// node.
        /// </summary>
        public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
        {
            if (identifier.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind()}.", nameof(identifier));
            return (IdentifierNameSyntax)Syntax.InternalSyntax.SyntaxFactory.IdentifierName((Syntax.InternalSyntax.SyntaxToken)identifier.Node!).CreateRed();
        }

        /// <summary>
        /// Creates a new
        /// <see cref="MemberAccessExpressionSyntax" />
        /// node.
        /// </summary>
        public static MemberAccessExpressionSyntax MemberAccessExpression(PrefixExpressionSyntax expression, SyntaxToken dotSeparator, SyntaxToken memberName)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (dotSeparator.Kind() != SyntaxKind.DotToken) throw new ArgumentException($"Invalid kind provided. Expected DotToken but got {dotSeparator.Kind()}.", nameof(dotSeparator));
            if (memberName.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {memberName.Kind()}.", nameof(memberName));
            return (MemberAccessExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.MemberAccessExpression((Syntax.InternalSyntax.PrefixExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)dotSeparator.Node!, (Syntax.InternalSyntax.SyntaxToken)memberName.Node!).CreateRed();
        }

        /// <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
        public static MemberAccessExpressionSyntax MemberAccessExpression(PrefixExpressionSyntax expression, SyntaxToken memberName)
            => SyntaxFactory.MemberAccessExpression(expression, SyntaxFactory.Token(SyntaxKind.DotToken), memberName);

        /// <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
        public static MemberAccessExpressionSyntax MemberAccessExpression(PrefixExpressionSyntax expression, string memberName)
            => SyntaxFactory.MemberAccessExpression(expression, SyntaxFactory.Token(SyntaxKind.DotToken), SyntaxFactory.Identifier(memberName));

        /// <summary>
        /// Creates a new
        /// <see cref="ElementAccessExpressionSyntax" />
        /// node.
        /// </summary>
        public static ElementAccessExpressionSyntax ElementAccessExpression(PrefixExpressionSyntax expression, SyntaxToken openBracketToken, ExpressionSyntax keyExpression, SyntaxToken closeBracketToken)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (openBracketToken.Kind() != SyntaxKind.OpenBracketToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBracketToken but got {openBracketToken.Kind()}.", nameof(openBracketToken));
            if (keyExpression == null) throw new ArgumentNullException(nameof(keyExpression));
            if (closeBracketToken.Kind() != SyntaxKind.CloseBracketToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBracketToken but got {closeBracketToken.Kind()}.", nameof(closeBracketToken));
            return (ElementAccessExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.ElementAccessExpression((Syntax.InternalSyntax.PrefixExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)keyExpression.Green, (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node!).CreateRed();
        }

        /// <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
        public static ElementAccessExpressionSyntax ElementAccessExpression(PrefixExpressionSyntax expression, ExpressionSyntax keyExpression)
            => SyntaxFactory.ElementAccessExpression(expression, SyntaxFactory.Token(SyntaxKind.OpenBracketToken), keyExpression, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));

        /// <summary>
        /// Creates a new
        /// <see cref="UnaryExpressionSyntax" />
        /// node.
        /// </summary>
        public static UnaryExpressionSyntax UnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            switch (kind)
            {
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.LengthExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.UnaryMinusExpression: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(kind));
            }
            switch (operatorToken.Kind())
            {
                case SyntaxKind.BangToken:
                case SyntaxKind.HashToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.NotKeyword:
                case SyntaxKind.TildeToken: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(operatorToken));
            }
            if (operand == null) throw new ArgumentNullException(nameof(operand));
            return (UnaryExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.UnaryExpression(kind, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)operand.Green).CreateRed();
        }

        /// <summary>
        /// Creates a new
        /// <see cref="BinaryExpressionSyntax" />
        /// node.
        /// </summary>
        public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.AddExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.ConcatExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.ExclusiveOrExpression:
                case SyntaxKind.ExponentiateExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.LogicalAndExpression:
                case SyntaxKind.LogicalOrExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.NotEqualsExpression:
                case SyntaxKind.RightShiftExpression:
                case SyntaxKind.SubtractExpression:
                case SyntaxKind.FloorDivideExpression: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(kind));
            }
            if (left == null) throw new ArgumentNullException(nameof(left));
            switch (operatorToken.Kind())
            {
                case SyntaxKind.AmpersandAmpersandToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AndKeyword:
                case SyntaxKind.BangEqualsToken:
                case SyntaxKind.DotDotToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.HatToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.OrKeyword:
                case SyntaxKind.PercentToken:
                case SyntaxKind.PipePipeToken:
                case SyntaxKind.PipeToken:
                case SyntaxKind.PlusToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.StarToken:
                case SyntaxKind.TildeEqualsToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.SlashSlashToken: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
            return (BinaryExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.BinaryExpression(kind, (Syntax.InternalSyntax.ExpressionSyntax)left.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)right.Green).CreateRed();
        }

        /// <see cref="ElseIfExpressionClauseSyntax" />
        public static ElseIfExpressionClauseSyntax ElseIfExpressionClause(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax value)
        {
            if (elseIfKeyword.Kind() != SyntaxKind.ElseIfKeyword) throw new ArgumentException($"Invalid kind provided. Expected ElseIfKeyword but got {elseIfKeyword.Kind()}.", nameof(elseIfKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword.Kind() != SyntaxKind.ThenKeyword) throw new ArgumentException($"Invalid kind provided. Expected ThenKeyword but got {thenKeyword.Kind()}.", nameof(thenKeyword));
            if (value == null) throw new ArgumentNullException(nameof(value));
            return (ElseIfExpressionClauseSyntax)Syntax.InternalSyntax.SyntaxFactory.ElseIfExpressionClause((Syntax.InternalSyntax.SyntaxToken)elseIfKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)thenKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)value.Green).CreateRed();
        }

        /// <summary>Creates a new ElseIfExpressionClauseSyntax instance.</summary>
        public static ElseIfExpressionClauseSyntax ElseIfExpressionClause(ExpressionSyntax condition, ExpressionSyntax value)
            => SyntaxFactory.ElseIfExpressionClause(SyntaxFactory.Token(SyntaxKind.ElseIfKeyword), condition, SyntaxFactory.Token(SyntaxKind.ThenKeyword), value);

        /// <summary>
        /// Creates a new
        /// <see cref="IfExpressionSyntax" />
        /// node.
        /// </summary>
        public static IfExpressionSyntax IfExpression(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax trueValue, SyntaxList<ElseIfExpressionClauseSyntax> elseIfClauses, SyntaxToken elseKeyword, ExpressionSyntax falseValue)
        {
            if (ifKeyword.Kind() != SyntaxKind.IfKeyword) throw new ArgumentException($"Invalid kind provided. Expected IfKeyword but got {ifKeyword.Kind()}.", nameof(ifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword.Kind() != SyntaxKind.ThenKeyword) throw new ArgumentException($"Invalid kind provided. Expected ThenKeyword but got {thenKeyword.Kind()}.", nameof(thenKeyword));
            if (trueValue == null) throw new ArgumentNullException(nameof(trueValue));
            if (elseKeyword.Kind() != SyntaxKind.ElseKeyword) throw new ArgumentException($"Invalid kind provided. Expected ElseKeyword but got {elseKeyword.Kind()}.", nameof(elseKeyword));
            if (falseValue == null) throw new ArgumentNullException(nameof(falseValue));
            return (IfExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.IfExpression((Syntax.InternalSyntax.SyntaxToken)ifKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)thenKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)trueValue.Green, elseIfClauses.Node.ToGreenList<Syntax.InternalSyntax.ElseIfExpressionClauseSyntax>(), (Syntax.InternalSyntax.SyntaxToken)elseKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)falseValue.Green).CreateRed();
        }

        /// <summary>Creates a new IfExpressionSyntax instance.</summary>
        public static IfExpressionSyntax IfExpression(ExpressionSyntax condition, ExpressionSyntax trueValue, SyntaxList<ElseIfExpressionClauseSyntax> elseIfClauses, ExpressionSyntax falseValue)
            => SyntaxFactory.IfExpression(SyntaxFactory.Token(SyntaxKind.IfKeyword), condition, SyntaxFactory.Token(SyntaxKind.ThenKeyword), trueValue, elseIfClauses, SyntaxFactory.Token(SyntaxKind.ElseKeyword), falseValue);

        /// <summary>Creates a new IfExpressionSyntax instance.</summary>
        public static IfExpressionSyntax IfExpression(ExpressionSyntax condition, ExpressionSyntax trueValue, ExpressionSyntax falseValue)
            => SyntaxFactory.IfExpression(SyntaxFactory.Token(SyntaxKind.IfKeyword), condition, SyntaxFactory.Token(SyntaxKind.ThenKeyword), trueValue, default(SyntaxList<ElseIfExpressionClauseSyntax>), SyntaxFactory.Token(SyntaxKind.ElseKeyword), falseValue);

        /// <see cref="ParenthesizedExpressionSyntax" />
        public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken.Kind() != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind()}.", nameof(openParenthesisToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenthesisToken.Kind() != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind()}.", nameof(closeParenthesisToken));
            return (ParenthesizedExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.ParenthesizedExpression((Syntax.InternalSyntax.SyntaxToken)openParenthesisToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenthesisToken.Node!).CreateRed();
        }

        /// <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        public static ParenthesizedExpressionSyntax ParenthesizedExpression(ExpressionSyntax expression)
            => SyntaxFactory.ParenthesizedExpression(SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        /// <summary>
        /// Creates a new
        /// <see cref="FunctionCallExpressionSyntax" />
        /// node.
        /// </summary>
        public static FunctionCallExpressionSyntax FunctionCallExpression(PrefixExpressionSyntax expression, FunctionArgumentSyntax argument)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (argument == null) throw new ArgumentNullException(nameof(argument));
            return (FunctionCallExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.FunctionCallExpression((Syntax.InternalSyntax.PrefixExpressionSyntax)expression.Green, (Syntax.InternalSyntax.FunctionArgumentSyntax)argument.Green).CreateRed();
        }

        /// <summary>
        /// Creates a new
        /// <see cref="MethodCallExpressionSyntax" />
        /// node.
        /// </summary>
        public static MethodCallExpressionSyntax MethodCallExpression(PrefixExpressionSyntax expression, SyntaxToken colonToken, SyntaxToken identifier, FunctionArgumentSyntax argument)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (colonToken.Kind() != SyntaxKind.ColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonToken but got {colonToken.Kind()}.", nameof(colonToken));
            if (identifier.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind()}.", nameof(identifier));
            if (argument == null) throw new ArgumentNullException(nameof(argument));
            return (MethodCallExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.MethodCallExpression((Syntax.InternalSyntax.PrefixExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node!, (Syntax.InternalSyntax.SyntaxToken)identifier.Node!, (Syntax.InternalSyntax.FunctionArgumentSyntax)argument.Green).CreateRed();
        }

        /// <summary>Creates a new MethodCallExpressionSyntax instance.</summary>
        public static MethodCallExpressionSyntax MethodCallExpression(PrefixExpressionSyntax expression, SyntaxToken identifier, FunctionArgumentSyntax argument)
            => SyntaxFactory.MethodCallExpression(expression, SyntaxFactory.Token(SyntaxKind.ColonToken), identifier, argument);

        /// <summary>Creates a new MethodCallExpressionSyntax instance.</summary>
        public static MethodCallExpressionSyntax MethodCallExpression(PrefixExpressionSyntax expression, string identifier, FunctionArgumentSyntax argument)
            => SyntaxFactory.MethodCallExpression(expression, SyntaxFactory.Token(SyntaxKind.ColonToken), SyntaxFactory.Identifier(identifier), argument);

        /// <summary>
        /// Creates a new
        /// <see cref="VariableAttributeSyntax" />
        /// node.
        /// </summary>
        public static VariableAttributeSyntax VariableAttribute(SyntaxToken lessThanToken, SyntaxToken identifier, SyntaxToken greaterThanToken)
        {
            if (lessThanToken.Kind() != SyntaxKind.LessThanToken) throw new ArgumentException($"Invalid kind provided. Expected LessThanToken but got {lessThanToken.Kind()}.", nameof(lessThanToken));
            if (identifier.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind()}.", nameof(identifier));
            if (greaterThanToken.Kind() != SyntaxKind.GreaterThanToken) throw new ArgumentException($"Invalid kind provided. Expected GreaterThanToken but got {greaterThanToken.Kind()}.", nameof(greaterThanToken));
            return (VariableAttributeSyntax)Syntax.InternalSyntax.SyntaxFactory.VariableAttribute((Syntax.InternalSyntax.SyntaxToken)lessThanToken.Node!, (Syntax.InternalSyntax.SyntaxToken)identifier.Node!, (Syntax.InternalSyntax.SyntaxToken)greaterThanToken.Node!).CreateRed();
        }

        /// <summary>Creates a new VariableAttributeSyntax instance.</summary>
        public static VariableAttributeSyntax VariableAttribute(SyntaxToken identifier)
            => SyntaxFactory.VariableAttribute(SyntaxFactory.Token(SyntaxKind.LessThanToken), identifier, SyntaxFactory.Token(SyntaxKind.GreaterThanToken));

        /// <summary>Creates a new VariableAttributeSyntax instance.</summary>
        public static VariableAttributeSyntax VariableAttribute(string identifier)
            => SyntaxFactory.VariableAttribute(SyntaxFactory.Token(SyntaxKind.LessThanToken), SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.GreaterThanToken));

        /// <summary>
        /// Creates a new
        /// <see cref="LocalDeclarationNameSyntax" />
        /// node.
        /// </summary>
        public static LocalDeclarationNameSyntax LocalDeclarationName(IdentifierNameSyntax identifierName, VariableAttributeSyntax? attribute, TypeBindingSyntax? typeBinding)
        {
            if (identifierName == null) throw new ArgumentNullException(nameof(identifierName));
            return (LocalDeclarationNameSyntax)Syntax.InternalSyntax.SyntaxFactory.LocalDeclarationName((Syntax.InternalSyntax.IdentifierNameSyntax)identifierName.Green, attribute == null ? null : (Syntax.InternalSyntax.VariableAttributeSyntax)attribute.Green, typeBinding == null ? null : (Syntax.InternalSyntax.TypeBindingSyntax)typeBinding.Green).CreateRed();
        }

        /// <summary>Creates a new LocalDeclarationNameSyntax instance.</summary>
        public static LocalDeclarationNameSyntax LocalDeclarationName(IdentifierNameSyntax identifierName)
            => SyntaxFactory.LocalDeclarationName(identifierName, default(VariableAttributeSyntax?), default(TypeBindingSyntax?));

        /// <summary>Creates a new LocalDeclarationNameSyntax instance.</summary>
        public static LocalDeclarationNameSyntax LocalDeclarationName(string identifierName)
            => SyntaxFactory.LocalDeclarationName(SyntaxFactory.IdentifierName(identifierName), default(VariableAttributeSyntax?), default(TypeBindingSyntax?));

        /// <summary>
        /// Creates a new
        /// <see cref="EqualsValuesClauseSyntax" />
        /// node.
        /// </summary>
        public static EqualsValuesClauseSyntax EqualsValuesClause(SyntaxToken equalsToken, SeparatedSyntaxList<ExpressionSyntax> values)
        {
            if (equalsToken.Kind() != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind()}.", nameof(equalsToken));
            if (values.Count < 1) throw new ArgumentException($"'{nameof(values)}' does not have at least 1 elements.", nameof(values));
            return (EqualsValuesClauseSyntax)Syntax.InternalSyntax.SyntaxFactory.EqualsValuesClause((Syntax.InternalSyntax.SyntaxToken)equalsToken.Node!, values.Node.ToGreenSeparatedList<Syntax.InternalSyntax.ExpressionSyntax>()).CreateRed();
        }

        /// <summary>Creates a new EqualsValuesClauseSyntax instance.</summary>
        public static EqualsValuesClauseSyntax EqualsValuesClause(SeparatedSyntaxList<ExpressionSyntax> values)
            => SyntaxFactory.EqualsValuesClause(SyntaxFactory.Token(SyntaxKind.EqualsToken), values);

        /// <summary>
        /// Creates a new
        /// <see cref="AssignmentStatementSyntax" />
        /// node.
        /// </summary>
        public static AssignmentStatementSyntax AssignmentStatement(SeparatedSyntaxList<PrefixExpressionSyntax> variables, EqualsValuesClauseSyntax equalsValues, SyntaxToken semicolonToken)
        {
            if (variables.Count < 1) throw new ArgumentException($"'{nameof(variables)}' does not have at least 1 elements.", nameof(variables));
            if (equalsValues == null) throw new ArgumentNullException(nameof(equalsValues));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (AssignmentStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.AssignmentStatement(variables.Node.ToGreenSeparatedList<Syntax.InternalSyntax.PrefixExpressionSyntax>(), (Syntax.InternalSyntax.EqualsValuesClauseSyntax)equalsValues.Green, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new AssignmentStatementSyntax instance.</summary>
        public static AssignmentStatementSyntax AssignmentStatement(SeparatedSyntaxList<PrefixExpressionSyntax> variables, EqualsValuesClauseSyntax equalsValues)
            => SyntaxFactory.AssignmentStatement(variables, equalsValues, default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="CompoundAssignmentStatementSyntax" />
        /// node.
        /// </summary>
        public static CompoundAssignmentStatementSyntax CompoundAssignmentStatement(SyntaxKind kind, PrefixExpressionSyntax variable, SyntaxToken assignmentOperatorToken, ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.AddAssignmentStatement:
                case SyntaxKind.SubtractAssignmentStatement:
                case SyntaxKind.MultiplyAssignmentStatement:
                case SyntaxKind.DivideAssignmentStatement:
                case SyntaxKind.ModuloAssignmentStatement:
                case SyntaxKind.ConcatAssignmentStatement:
                case SyntaxKind.ExponentiateAssignmentStatement: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(kind));
            }
            if (variable == null) throw new ArgumentNullException(nameof(variable));
            switch (assignmentOperatorToken.Kind())
            {
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.StarEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.PercentEqualsToken:
                case SyntaxKind.DotDotEqualsToken:
                case SyntaxKind.HatEqualsToken: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(assignmentOperatorToken));
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (CompoundAssignmentStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.CompoundAssignmentStatement(kind, (Syntax.InternalSyntax.PrefixExpressionSyntax)variable.Green, (Syntax.InternalSyntax.SyntaxToken)assignmentOperatorToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new CompoundAssignmentStatementSyntax instance.</summary>
        public static CompoundAssignmentStatementSyntax CompoundAssignmentStatement(SyntaxKind kind, PrefixExpressionSyntax variable, ExpressionSyntax expression)
            => SyntaxFactory.CompoundAssignmentStatement(kind, variable, SyntaxFactory.Token(GetCompoundAssignmentStatementAssignmentOperatorTokenKind(kind)), expression, default(SyntaxToken));

        private static SyntaxKind GetCompoundAssignmentStatementAssignmentOperatorTokenKind(SyntaxKind kind)
            => kind switch
            {
                SyntaxKind.AddAssignmentStatement => SyntaxKind.PlusEqualsToken,
                SyntaxKind.SubtractAssignmentStatement => SyntaxKind.MinusEqualsToken,
                SyntaxKind.MultiplyAssignmentStatement => SyntaxKind.StarEqualsToken,
                SyntaxKind.DivideAssignmentStatement => SyntaxKind.SlashEqualsToken,
                SyntaxKind.ModuloAssignmentStatement => SyntaxKind.PercentEqualsToken,
                SyntaxKind.ConcatAssignmentStatement => SyntaxKind.DotDotEqualsToken,
                SyntaxKind.ExponentiateAssignmentStatement => SyntaxKind.HatEqualsToken,
                _ => throw new ArgumentOutOfRangeException(),
            };

        /// <summary>
        /// Creates a new
        /// <see cref="LocalVariableDeclarationStatementSyntax" />
        /// node.
        /// </summary>
        public static LocalVariableDeclarationStatementSyntax LocalVariableDeclarationStatement(SyntaxToken localKeyword, SeparatedSyntaxList<LocalDeclarationNameSyntax> names, EqualsValuesClauseSyntax? equalsValues, SyntaxToken semicolonToken)
        {
            if (localKeyword.Kind() != SyntaxKind.LocalKeyword) throw new ArgumentException($"Invalid kind provided. Expected LocalKeyword but got {localKeyword.Kind()}.", nameof(localKeyword));
            if (names.Count < 1) throw new ArgumentException($"'{nameof(names)}' does not have at least 1 elements.", nameof(names));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (LocalVariableDeclarationStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.LocalVariableDeclarationStatement((Syntax.InternalSyntax.SyntaxToken)localKeyword.Node!, names.Node.ToGreenSeparatedList<Syntax.InternalSyntax.LocalDeclarationNameSyntax>(), equalsValues == null ? null : (Syntax.InternalSyntax.EqualsValuesClauseSyntax)equalsValues.Green, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new LocalVariableDeclarationStatementSyntax instance.</summary>
        public static LocalVariableDeclarationStatementSyntax LocalVariableDeclarationStatement(SeparatedSyntaxList<LocalDeclarationNameSyntax> names, EqualsValuesClauseSyntax? equalsValues)
            => SyntaxFactory.LocalVariableDeclarationStatement(SyntaxFactory.Token(SyntaxKind.LocalKeyword), names, equalsValues, default(SyntaxToken));

        /// <summary>Creates a new LocalVariableDeclarationStatementSyntax instance.</summary>
        public static LocalVariableDeclarationStatementSyntax LocalVariableDeclarationStatement(SeparatedSyntaxList<LocalDeclarationNameSyntax> names)
            => SyntaxFactory.LocalVariableDeclarationStatement(SyntaxFactory.Token(SyntaxKind.LocalKeyword), names, default(EqualsValuesClauseSyntax?), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="TypedIdentifierNameSyntax" />
        /// node.
        /// </summary>
        public static TypedIdentifierNameSyntax TypedIdentifierName(IdentifierNameSyntax identifierName, TypeBindingSyntax? typeBinding)
        {
            if (identifierName == null) throw new ArgumentNullException(nameof(identifierName));
            return (TypedIdentifierNameSyntax)Syntax.InternalSyntax.SyntaxFactory.TypedIdentifierName((Syntax.InternalSyntax.IdentifierNameSyntax)identifierName.Green, typeBinding == null ? null : (Syntax.InternalSyntax.TypeBindingSyntax)typeBinding.Green).CreateRed();
        }

        /// <summary>Creates a new TypedIdentifierNameSyntax instance.</summary>
        public static TypedIdentifierNameSyntax TypedIdentifierName(IdentifierNameSyntax identifierName)
            => SyntaxFactory.TypedIdentifierName(identifierName, default(TypeBindingSyntax?));

        /// <summary>Creates a new TypedIdentifierNameSyntax instance.</summary>
        public static TypedIdentifierNameSyntax TypedIdentifierName(string identifierName)
            => SyntaxFactory.TypedIdentifierName(SyntaxFactory.IdentifierName(identifierName), default(TypeBindingSyntax?));

        /// <summary>
        /// Creates a new
        /// <see cref="NumericForStatementSyntax" />
        /// node.
        /// </summary>
        public static NumericForStatementSyntax NumericForStatement(SyntaxToken forKeyword, TypedIdentifierNameSyntax identifier, SyntaxToken equalsToken, ExpressionSyntax initialValue, SyntaxToken finalValueCommaToken, ExpressionSyntax finalValue, SyntaxToken stepValueCommaToken, ExpressionSyntax? stepValue, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (forKeyword.Kind() != SyntaxKind.ForKeyword) throw new ArgumentException($"Invalid kind provided. Expected ForKeyword but got {forKeyword.Kind()}.", nameof(forKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (equalsToken.Kind() != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind()}.", nameof(equalsToken));
            if (initialValue == null) throw new ArgumentNullException(nameof(initialValue));
            if (finalValueCommaToken.Kind() != SyntaxKind.CommaToken) throw new ArgumentException($"Invalid kind provided. Expected CommaToken but got {finalValueCommaToken.Kind()}.", nameof(finalValueCommaToken));
            if (finalValue == null) throw new ArgumentNullException(nameof(finalValue));
            switch (stepValueCommaToken.Kind())
            {
                case SyntaxKind.CommaToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(stepValueCommaToken));
            }
            if (doKeyword.Kind() != SyntaxKind.DoKeyword) throw new ArgumentException($"Invalid kind provided. Expected DoKeyword but got {doKeyword.Kind()}.", nameof(doKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind()}.", nameof(endKeyword));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (NumericForStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.NumericForStatement((Syntax.InternalSyntax.SyntaxToken)forKeyword.Node!, (Syntax.InternalSyntax.TypedIdentifierNameSyntax)identifier.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)initialValue.Green, (Syntax.InternalSyntax.SyntaxToken)finalValueCommaToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)finalValue.Green, (Syntax.InternalSyntax.SyntaxToken?)stepValueCommaToken.Node, stepValue == null ? null : (Syntax.InternalSyntax.ExpressionSyntax)stepValue.Green, (Syntax.InternalSyntax.SyntaxToken)doKeyword.Node!, (Syntax.InternalSyntax.StatementListSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new NumericForStatementSyntax instance.</summary>
        public static NumericForStatementSyntax NumericForStatement(TypedIdentifierNameSyntax identifier, ExpressionSyntax initialValue, ExpressionSyntax finalValue, ExpressionSyntax? stepValue, StatementListSyntax body)
            => SyntaxFactory.NumericForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), identifier, SyntaxFactory.Token(SyntaxKind.EqualsToken), initialValue, SyntaxFactory.Token(SyntaxKind.CommaToken), finalValue, default(SyntaxToken), stepValue, SyntaxFactory.Token(SyntaxKind.DoKeyword), body, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>Creates a new NumericForStatementSyntax instance.</summary>
        public static NumericForStatementSyntax NumericForStatement(TypedIdentifierNameSyntax identifier, ExpressionSyntax initialValue, ExpressionSyntax finalValue, StatementListSyntax body)
            => SyntaxFactory.NumericForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), identifier, SyntaxFactory.Token(SyntaxKind.EqualsToken), initialValue, SyntaxFactory.Token(SyntaxKind.CommaToken), finalValue, default(SyntaxToken), default(ExpressionSyntax?), SyntaxFactory.Token(SyntaxKind.DoKeyword), body, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>Creates a new NumericForStatementSyntax instance.</summary>
        public static NumericForStatementSyntax NumericForStatement(string identifier, ExpressionSyntax initialValue, ExpressionSyntax finalValue, StatementListSyntax body)
            => SyntaxFactory.NumericForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), SyntaxFactory.TypedIdentifierName(identifier), SyntaxFactory.Token(SyntaxKind.EqualsToken), initialValue, SyntaxFactory.Token(SyntaxKind.CommaToken), finalValue, default(SyntaxToken), default(ExpressionSyntax?), SyntaxFactory.Token(SyntaxKind.DoKeyword), body, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="GenericForStatementSyntax" />
        /// node.
        /// </summary>
        public static GenericForStatementSyntax GenericForStatement(SyntaxToken forKeyword, SeparatedSyntaxList<TypedIdentifierNameSyntax> identifiers, SyntaxToken inKeyword, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (forKeyword.Kind() != SyntaxKind.ForKeyword) throw new ArgumentException($"Invalid kind provided. Expected ForKeyword but got {forKeyword.Kind()}.", nameof(forKeyword));
            if (identifiers.Count < 1) throw new ArgumentException($"'{nameof(identifiers)}' does not have at least 1 elements.", nameof(identifiers));
            if (inKeyword.Kind() != SyntaxKind.InKeyword) throw new ArgumentException($"Invalid kind provided. Expected InKeyword but got {inKeyword.Kind()}.", nameof(inKeyword));
            if (expressions.Count < 1) throw new ArgumentException($"'{nameof(expressions)}' does not have at least 1 elements.", nameof(expressions));
            if (doKeyword.Kind() != SyntaxKind.DoKeyword) throw new ArgumentException($"Invalid kind provided. Expected DoKeyword but got {doKeyword.Kind()}.", nameof(doKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind()}.", nameof(endKeyword));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (GenericForStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.GenericForStatement((Syntax.InternalSyntax.SyntaxToken)forKeyword.Node!, identifiers.Node.ToGreenSeparatedList<Syntax.InternalSyntax.TypedIdentifierNameSyntax>(), (Syntax.InternalSyntax.SyntaxToken)inKeyword.Node!, expressions.Node.ToGreenSeparatedList<Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)doKeyword.Node!, (Syntax.InternalSyntax.StatementListSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new GenericForStatementSyntax instance.</summary>
        public static GenericForStatementSyntax GenericForStatement(SeparatedSyntaxList<TypedIdentifierNameSyntax> identifiers, SeparatedSyntaxList<ExpressionSyntax> expressions, StatementListSyntax body)
            => SyntaxFactory.GenericForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), identifiers, SyntaxFactory.Token(SyntaxKind.InKeyword), expressions, SyntaxFactory.Token(SyntaxKind.DoKeyword), body, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="WhileStatementSyntax" />
        /// node.
        /// </summary>
        public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (whileKeyword.Kind() != SyntaxKind.WhileKeyword) throw new ArgumentException($"Invalid kind provided. Expected WhileKeyword but got {whileKeyword.Kind()}.", nameof(whileKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (doKeyword.Kind() != SyntaxKind.DoKeyword) throw new ArgumentException($"Invalid kind provided. Expected DoKeyword but got {doKeyword.Kind()}.", nameof(doKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind()}.", nameof(endKeyword));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (WhileStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.WhileStatement((Syntax.InternalSyntax.SyntaxToken)whileKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)doKeyword.Node!, (Syntax.InternalSyntax.StatementListSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new WhileStatementSyntax instance.</summary>
        public static WhileStatementSyntax WhileStatement(ExpressionSyntax condition, StatementListSyntax body)
            => SyntaxFactory.WhileStatement(SyntaxFactory.Token(SyntaxKind.WhileKeyword), condition, SyntaxFactory.Token(SyntaxKind.DoKeyword), body, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="RepeatUntilStatementSyntax" />
        /// node.
        /// </summary>
        public static RepeatUntilStatementSyntax RepeatUntilStatement(SyntaxToken repeatKeyword, StatementListSyntax body, SyntaxToken untilKeyword, ExpressionSyntax condition, SyntaxToken semicolonToken)
        {
            if (repeatKeyword.Kind() != SyntaxKind.RepeatKeyword) throw new ArgumentException($"Invalid kind provided. Expected RepeatKeyword but got {repeatKeyword.Kind()}.", nameof(repeatKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (untilKeyword.Kind() != SyntaxKind.UntilKeyword) throw new ArgumentException($"Invalid kind provided. Expected UntilKeyword but got {untilKeyword.Kind()}.", nameof(untilKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (RepeatUntilStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.RepeatUntilStatement((Syntax.InternalSyntax.SyntaxToken)repeatKeyword.Node!, (Syntax.InternalSyntax.StatementListSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)untilKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new RepeatUntilStatementSyntax instance.</summary>
        public static RepeatUntilStatementSyntax RepeatUntilStatement(StatementListSyntax body, ExpressionSyntax condition)
            => SyntaxFactory.RepeatUntilStatement(SyntaxFactory.Token(SyntaxKind.RepeatKeyword), body, SyntaxFactory.Token(SyntaxKind.UntilKeyword), condition, default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="IfStatementSyntax" />
        /// comment.
        /// </summary>
        public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body, SyntaxList<ElseIfClauseSyntax> elseIfClauses, ElseClauseSyntax? elseClause, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (ifKeyword.Kind() != SyntaxKind.IfKeyword) throw new ArgumentException($"Invalid kind provided. Expected IfKeyword but got {ifKeyword.Kind()}.", nameof(ifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword.Kind() != SyntaxKind.ThenKeyword) throw new ArgumentException($"Invalid kind provided. Expected ThenKeyword but got {thenKeyword.Kind()}.", nameof(thenKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind()}.", nameof(endKeyword));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (IfStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.IfStatement((Syntax.InternalSyntax.SyntaxToken)ifKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)thenKeyword.Node!, (Syntax.InternalSyntax.StatementListSyntax)body.Green, elseIfClauses.Node.ToGreenList<Syntax.InternalSyntax.ElseIfClauseSyntax>(), elseClause == null ? null : (Syntax.InternalSyntax.ElseClauseSyntax)elseClause.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new IfStatementSyntax instance.</summary>
        public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementListSyntax body, SyntaxList<ElseIfClauseSyntax> elseIfClauses, ElseClauseSyntax? elseClause)
            => SyntaxFactory.IfStatement(SyntaxFactory.Token(SyntaxKind.IfKeyword), condition, SyntaxFactory.Token(SyntaxKind.ThenKeyword), body, elseIfClauses, elseClause, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>Creates a new IfStatementSyntax instance.</summary>
        public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementListSyntax body)
            => SyntaxFactory.IfStatement(SyntaxFactory.Token(SyntaxKind.IfKeyword), condition, SyntaxFactory.Token(SyntaxKind.ThenKeyword), body, default(SyntaxList<ElseIfClauseSyntax>), default(ElseClauseSyntax?), SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="ElseIfClauseSyntax" />
        /// node.
        /// </summary>
        public static ElseIfClauseSyntax ElseIfClause(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body)
        {
            if (elseIfKeyword.Kind() != SyntaxKind.ElseIfKeyword) throw new ArgumentException($"Invalid kind provided. Expected ElseIfKeyword but got {elseIfKeyword.Kind()}.", nameof(elseIfKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (thenKeyword.Kind() != SyntaxKind.ThenKeyword) throw new ArgumentException($"Invalid kind provided. Expected ThenKeyword but got {thenKeyword.Kind()}.", nameof(thenKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            return (ElseIfClauseSyntax)Syntax.InternalSyntax.SyntaxFactory.ElseIfClause((Syntax.InternalSyntax.SyntaxToken)elseIfKeyword.Node!, (Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)thenKeyword.Node!, (Syntax.InternalSyntax.StatementListSyntax)body.Green).CreateRed();
        }

        /// <summary>Creates a new ElseIfClauseSyntax instance.</summary>
        public static ElseIfClauseSyntax ElseIfClause(ExpressionSyntax condition, StatementListSyntax body)
            => SyntaxFactory.ElseIfClause(SyntaxFactory.Token(SyntaxKind.ElseIfKeyword), condition, SyntaxFactory.Token(SyntaxKind.ThenKeyword), body);

        /// <summary>
        /// Creates a new
        /// <see cref="ElseClauseSyntax" />
        /// comment.
        /// </summary>
        public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementListSyntax elseBody)
        {
            if (elseKeyword.Kind() != SyntaxKind.ElseKeyword) throw new ArgumentException($"Invalid kind provided. Expected ElseKeyword but got {elseKeyword.Kind()}.", nameof(elseKeyword));
            if (elseBody == null) throw new ArgumentNullException(nameof(elseBody));
            return (ElseClauseSyntax)Syntax.InternalSyntax.SyntaxFactory.ElseClause((Syntax.InternalSyntax.SyntaxToken)elseKeyword.Node!, (Syntax.InternalSyntax.StatementListSyntax)elseBody.Green).CreateRed();
        }

        /// <summary>Creates a new ElseClauseSyntax instance.</summary>
        public static ElseClauseSyntax ElseClause(StatementListSyntax elseBody)
            => SyntaxFactory.ElseClause(SyntaxFactory.Token(SyntaxKind.ElseKeyword), elseBody);

        /// <summary>
        /// Creates a new
        /// <see cref="GotoStatementSyntax" />
        /// node.
        /// </summary>
        public static GotoStatementSyntax GotoStatement(SyntaxToken gotoKeyword, SyntaxToken labelName, SyntaxToken semicolonToken)
        {
            if (gotoKeyword.Kind() != SyntaxKind.GotoKeyword) throw new ArgumentException($"Invalid kind provided. Expected GotoKeyword but got {gotoKeyword.Kind()}.", nameof(gotoKeyword));
            if (labelName.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {labelName.Kind()}.", nameof(labelName));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (GotoStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.GotoStatement((Syntax.InternalSyntax.SyntaxToken)gotoKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken)labelName.Node!, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new GotoStatementSyntax instance.</summary>
        public static GotoStatementSyntax GotoStatement(SyntaxToken labelName)
            => SyntaxFactory.GotoStatement(SyntaxFactory.Token(SyntaxKind.GotoKeyword), labelName, default(SyntaxToken));

        /// <summary>Creates a new GotoStatementSyntax instance.</summary>
        public static GotoStatementSyntax GotoStatement(string labelName)
            => SyntaxFactory.GotoStatement(SyntaxFactory.Token(SyntaxKind.GotoKeyword), SyntaxFactory.Identifier(labelName), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="BreakStatementSyntax" />
        /// node.
        /// </summary>
        public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        {
            if (breakKeyword.Kind() != SyntaxKind.BreakKeyword) throw new ArgumentException($"Invalid kind provided. Expected BreakKeyword but got {breakKeyword.Kind()}.", nameof(breakKeyword));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (BreakStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.BreakStatement((Syntax.InternalSyntax.SyntaxToken)breakKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new BreakStatementSyntax instance.</summary>
        public static BreakStatementSyntax BreakStatement()
            => SyntaxFactory.BreakStatement(SyntaxFactory.Token(SyntaxKind.BreakKeyword), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="ReturnStatementSyntax" />
        /// node.
        /// </summary>
        public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken semicolonToken)
        {
            if (returnKeyword.Kind() != SyntaxKind.ReturnKeyword) throw new ArgumentException($"Invalid kind provided. Expected ReturnKeyword but got {returnKeyword.Kind()}.", nameof(returnKeyword));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (ReturnStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.ReturnStatement((Syntax.InternalSyntax.SyntaxToken)returnKeyword.Node!, expressions.Node.ToGreenSeparatedList<Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new ReturnStatementSyntax instance.</summary>
        public static ReturnStatementSyntax ReturnStatement(SeparatedSyntaxList<ExpressionSyntax> expressions = default)
            => SyntaxFactory.ReturnStatement(SyntaxFactory.Token(SyntaxKind.ReturnKeyword), expressions, default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="ContinueStatementSyntax" />
        /// node.
        /// </summary>
        public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        {
            if (continueKeyword.Kind() != SyntaxKind.ContinueKeyword) throw new ArgumentException($"Invalid kind provided. Expected ContinueKeyword but got {continueKeyword.Kind()}.", nameof(continueKeyword));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (ContinueStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.ContinueStatement((Syntax.InternalSyntax.SyntaxToken)continueKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new ContinueStatementSyntax instance.</summary>
        public static ContinueStatementSyntax ContinueStatement()
            => SyntaxFactory.ContinueStatement(SyntaxFactory.Token(SyntaxKind.ContinueKeyword), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="LocalFunctionDeclarationStatementSyntax" />
        /// node.
        /// </summary>
        public static LocalFunctionDeclarationStatementSyntax LocalFunctionDeclarationStatement(SyntaxToken localKeyword, SyntaxToken functionKeyword, IdentifierNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (localKeyword.Kind() != SyntaxKind.LocalKeyword) throw new ArgumentException($"Invalid kind provided. Expected LocalKeyword but got {localKeyword.Kind()}.", nameof(localKeyword));
            if (functionKeyword.Kind() != SyntaxKind.FunctionKeyword) throw new ArgumentException($"Invalid kind provided. Expected FunctionKeyword but got {functionKeyword.Kind()}.", nameof(functionKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (parameters == null) throw new ArgumentNullException(nameof(parameters));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind()}.", nameof(endKeyword));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (LocalFunctionDeclarationStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.LocalFunctionDeclarationStatement((Syntax.InternalSyntax.SyntaxToken)localKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken)functionKeyword.Node!, (Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, typeParameterList == null ? null : (Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, (Syntax.InternalSyntax.ParameterListSyntax)parameters.Green, typeBinding == null ? null : (Syntax.InternalSyntax.TypeBindingSyntax)typeBinding.Green, (Syntax.InternalSyntax.StatementListSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new LocalFunctionDeclarationStatementSyntax instance.</summary>
        public static LocalFunctionDeclarationStatementSyntax LocalFunctionDeclarationStatement(IdentifierNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body)
            => SyntaxFactory.LocalFunctionDeclarationStatement(SyntaxFactory.Token(SyntaxKind.LocalKeyword), SyntaxFactory.Token(SyntaxKind.FunctionKeyword), name, typeParameterList, parameters, typeBinding, body, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>Creates a new LocalFunctionDeclarationStatementSyntax instance.</summary>
        public static LocalFunctionDeclarationStatementSyntax LocalFunctionDeclarationStatement(IdentifierNameSyntax name, ParameterListSyntax parameters, StatementListSyntax body)
            => SyntaxFactory.LocalFunctionDeclarationStatement(SyntaxFactory.Token(SyntaxKind.LocalKeyword), SyntaxFactory.Token(SyntaxKind.FunctionKeyword), name, default(TypeParameterListSyntax?), parameters, default(TypeBindingSyntax?), body, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>Creates a new LocalFunctionDeclarationStatementSyntax instance.</summary>
        public static LocalFunctionDeclarationStatementSyntax LocalFunctionDeclarationStatement(string name, ParameterListSyntax parameters, StatementListSyntax body)
            => SyntaxFactory.LocalFunctionDeclarationStatement(SyntaxFactory.Token(SyntaxKind.LocalKeyword), SyntaxFactory.Token(SyntaxKind.FunctionKeyword), SyntaxFactory.IdentifierName(name), default(TypeParameterListSyntax?), parameters, default(TypeBindingSyntax?), body, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="FunctionDeclarationStatementSyntax" />
        /// node.
        /// </summary>
        public static FunctionDeclarationStatementSyntax FunctionDeclarationStatement(SyntaxToken functionKeyword, FunctionNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (functionKeyword.Kind() != SyntaxKind.FunctionKeyword) throw new ArgumentException($"Invalid kind provided. Expected FunctionKeyword but got {functionKeyword.Kind()}.", nameof(functionKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (parameters == null) throw new ArgumentNullException(nameof(parameters));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind()}.", nameof(endKeyword));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (FunctionDeclarationStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.FunctionDeclarationStatement((Syntax.InternalSyntax.SyntaxToken)functionKeyword.Node!, (Syntax.InternalSyntax.FunctionNameSyntax)name.Green, typeParameterList == null ? null : (Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, (Syntax.InternalSyntax.ParameterListSyntax)parameters.Green, typeBinding == null ? null : (Syntax.InternalSyntax.TypeBindingSyntax)typeBinding.Green, (Syntax.InternalSyntax.StatementListSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new FunctionDeclarationStatementSyntax instance.</summary>
        public static FunctionDeclarationStatementSyntax FunctionDeclarationStatement(FunctionNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body)
            => SyntaxFactory.FunctionDeclarationStatement(SyntaxFactory.Token(SyntaxKind.FunctionKeyword), name, typeParameterList, parameters, typeBinding, body, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>Creates a new FunctionDeclarationStatementSyntax instance.</summary>
        public static FunctionDeclarationStatementSyntax FunctionDeclarationStatement(FunctionNameSyntax name, ParameterListSyntax parameters, StatementListSyntax body)
            => SyntaxFactory.FunctionDeclarationStatement(SyntaxFactory.Token(SyntaxKind.FunctionKeyword), name, default(TypeParameterListSyntax?), parameters, default(TypeBindingSyntax?), body, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="DoStatementSyntax" />
        /// node.
        /// </summary>
        public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (doKeyword.Kind() != SyntaxKind.DoKeyword) throw new ArgumentException($"Invalid kind provided. Expected DoKeyword but got {doKeyword.Kind()}.", nameof(doKeyword));
            if (body == null) throw new ArgumentNullException(nameof(body));
            if (endKeyword.Kind() != SyntaxKind.EndKeyword) throw new ArgumentException($"Invalid kind provided. Expected EndKeyword but got {endKeyword.Kind()}.", nameof(endKeyword));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (DoStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.DoStatement((Syntax.InternalSyntax.SyntaxToken)doKeyword.Node!, (Syntax.InternalSyntax.StatementListSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)endKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new DoStatementSyntax instance.</summary>
        public static DoStatementSyntax DoStatement(StatementListSyntax body)
            => SyntaxFactory.DoStatement(SyntaxFactory.Token(SyntaxKind.DoKeyword), body, SyntaxFactory.Token(SyntaxKind.EndKeyword), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="GotoLabelStatementSyntax" />
        /// node.
        /// </summary>
        public static GotoLabelStatementSyntax GotoLabelStatement(SyntaxToken leftDelimiterToken, SyntaxToken identifier, SyntaxToken rightDelimiterToken, SyntaxToken semicolonToken)
        {
            if (leftDelimiterToken.Kind() != SyntaxKind.ColonColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonColonToken but got {leftDelimiterToken.Kind()}.", nameof(leftDelimiterToken));
            if (identifier.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind()}.", nameof(identifier));
            if (rightDelimiterToken.Kind() != SyntaxKind.ColonColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonColonToken but got {rightDelimiterToken.Kind()}.", nameof(rightDelimiterToken));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (GotoLabelStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.GotoLabelStatement((Syntax.InternalSyntax.SyntaxToken)leftDelimiterToken.Node!, (Syntax.InternalSyntax.SyntaxToken)identifier.Node!, (Syntax.InternalSyntax.SyntaxToken)rightDelimiterToken.Node!, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new GotoLabelStatementSyntax instance.</summary>
        public static GotoLabelStatementSyntax GotoLabelStatement(SyntaxToken identifier)
            => SyntaxFactory.GotoLabelStatement(SyntaxFactory.Token(SyntaxKind.ColonColonToken), identifier, SyntaxFactory.Token(SyntaxKind.ColonColonToken), default(SyntaxToken));

        /// <summary>Creates a new GotoLabelStatementSyntax instance.</summary>
        public static GotoLabelStatementSyntax GotoLabelStatement(string identifier)
            => SyntaxFactory.GotoLabelStatement(SyntaxFactory.Token(SyntaxKind.ColonColonToken), SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.ColonColonToken), default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="ExpressionStatementSyntax" />
        /// node.
        /// </summary>
        public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (ExpressionStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.ExpressionStatement((Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new ExpressionStatementSyntax instance.</summary>
        public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression)
            => SyntaxFactory.ExpressionStatement(expression, default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="EmptyStatementSyntax" />
        /// node.
        /// </summary>
        public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
        {
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (EmptyStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.EmptyStatement((Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new EmptyStatementSyntax instance.</summary>
        public static EmptyStatementSyntax EmptyStatement()
            => SyntaxFactory.EmptyStatement(default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="TypeDeclarationStatementSyntax" />
        /// node.
        /// </summary>
        public static TypeDeclarationStatementSyntax TypeDeclarationStatement(SyntaxToken exportKeyword, SyntaxToken typeKeyword, SyntaxToken name, TypeParameterListSyntax? typeParameterList, SyntaxToken equalsToken, TypeSyntax type, SyntaxToken semicolonToken)
        {
            switch (exportKeyword.Kind())
            {
                case SyntaxKind.ExportKeyword:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(exportKeyword));
            }
            if (typeKeyword.Kind() != SyntaxKind.TypeKeyword) throw new ArgumentException($"Invalid kind provided. Expected TypeKeyword but got {typeKeyword.Kind()}.", nameof(typeKeyword));
            if (name.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {name.Kind()}.", nameof(name));
            if (equalsToken.Kind() != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind()}.", nameof(equalsToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            switch (semicolonToken.Kind())
            {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(semicolonToken));
            }
            return (TypeDeclarationStatementSyntax)Syntax.InternalSyntax.SyntaxFactory.TypeDeclarationStatement((Syntax.InternalSyntax.SyntaxToken?)exportKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)typeKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken)name.Node!, typeParameterList == null ? null : (Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node!, (Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken?)semicolonToken.Node).CreateRed();
        }

        /// <summary>Creates a new TypeDeclarationStatementSyntax instance.</summary>
        public static TypeDeclarationStatementSyntax TypeDeclarationStatement(SyntaxToken name, TypeParameterListSyntax? typeParameterList, TypeSyntax type)
            => SyntaxFactory.TypeDeclarationStatement(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.TypeKeyword), name, typeParameterList, SyntaxFactory.Token(SyntaxKind.EqualsToken), type, default(SyntaxToken));

        /// <summary>Creates a new TypeDeclarationStatementSyntax instance.</summary>
        public static TypeDeclarationStatementSyntax TypeDeclarationStatement(SyntaxToken name, TypeSyntax type)
            => SyntaxFactory.TypeDeclarationStatement(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.TypeKeyword), name, default(TypeParameterListSyntax?), SyntaxFactory.Token(SyntaxKind.EqualsToken), type, default(SyntaxToken));

        /// <summary>Creates a new TypeDeclarationStatementSyntax instance.</summary>
        public static TypeDeclarationStatementSyntax TypeDeclarationStatement(string name, TypeSyntax type)
            => SyntaxFactory.TypeDeclarationStatement(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.TypeKeyword), SyntaxFactory.Identifier(name), default(TypeParameterListSyntax?), SyntaxFactory.Token(SyntaxKind.EqualsToken), type, default(SyntaxToken));

        /// <summary>
        /// Creates a new
        /// <see cref="TypeBindingSyntax" />
        /// node.
        /// </summary>
        public static TypeBindingSyntax TypeBinding(SyntaxToken colonToken, TypeSyntax type)
        {
            if (colonToken.Kind() != SyntaxKind.ColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonToken but got {colonToken.Kind()}.", nameof(colonToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            return (TypeBindingSyntax)Syntax.InternalSyntax.SyntaxFactory.TypeBinding((Syntax.InternalSyntax.SyntaxToken)colonToken.Node!, (Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
        }

        /// <summary>Creates a new TypeBindingSyntax instance.</summary>
        public static TypeBindingSyntax TypeBinding(TypeSyntax type)
            => SyntaxFactory.TypeBinding(SyntaxFactory.Token(SyntaxKind.ColonToken), type);

        /// <summary>
        /// Creates a new
        /// <see cref="SimpleTypeNameSyntax" />
        /// node.
        /// </summary>
        public static SimpleTypeNameSyntax SimpleTypeName(SyntaxToken identifierToken, TypeArgumentListSyntax? typeArgumentList)
        {
            if (identifierToken.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifierToken.Kind()}.", nameof(identifierToken));
            return (SimpleTypeNameSyntax)Syntax.InternalSyntax.SyntaxFactory.SimpleTypeName((Syntax.InternalSyntax.SyntaxToken)identifierToken.Node!, typeArgumentList == null ? null : (Syntax.InternalSyntax.TypeArgumentListSyntax)typeArgumentList.Green).CreateRed();
        }

        /// <summary>Creates a new SimpleTypeNameSyntax instance.</summary>
        public static SimpleTypeNameSyntax SimpleTypeName(SyntaxToken identifierToken)
            => SyntaxFactory.SimpleTypeName(identifierToken, default(TypeArgumentListSyntax?));

        /// <summary>Creates a new SimpleTypeNameSyntax instance.</summary>
        public static SimpleTypeNameSyntax SimpleTypeName(string identifierToken)
            => SyntaxFactory.SimpleTypeName(SyntaxFactory.Identifier(identifierToken), default(TypeArgumentListSyntax?));

        /// <summary>
        /// Creates a new
        /// <see cref="CompositeTypeNameSyntax" />
        /// node.
        /// </summary>
        public static CompositeTypeNameSyntax CompositeTypeName(TypeNameSyntax @base, SyntaxToken dotToken, SyntaxToken identifierToken, TypeArgumentListSyntax? typeArgumentList)
        {
            if (@base == null) throw new ArgumentNullException(nameof(@base));
            if (dotToken.Kind() != SyntaxKind.DotToken) throw new ArgumentException($"Invalid kind provided. Expected DotToken but got {dotToken.Kind()}.", nameof(dotToken));
            if (identifierToken.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifierToken.Kind()}.", nameof(identifierToken));
            return (CompositeTypeNameSyntax)Syntax.InternalSyntax.SyntaxFactory.CompositeTypeName((Syntax.InternalSyntax.TypeNameSyntax)@base.Green, (Syntax.InternalSyntax.SyntaxToken)dotToken.Node!, (Syntax.InternalSyntax.SyntaxToken)identifierToken.Node!, typeArgumentList == null ? null : (Syntax.InternalSyntax.TypeArgumentListSyntax)typeArgumentList.Green).CreateRed();
        }

        /// <summary>Creates a new CompositeTypeNameSyntax instance.</summary>
        public static CompositeTypeNameSyntax CompositeTypeName(TypeNameSyntax @base, SyntaxToken identifierToken, TypeArgumentListSyntax? typeArgumentList)
            => SyntaxFactory.CompositeTypeName(@base, SyntaxFactory.Token(SyntaxKind.DotToken), identifierToken, typeArgumentList);

        /// <summary>Creates a new CompositeTypeNameSyntax instance.</summary>
        public static CompositeTypeNameSyntax CompositeTypeName(TypeNameSyntax @base, SyntaxToken identifierToken)
            => SyntaxFactory.CompositeTypeName(@base, SyntaxFactory.Token(SyntaxKind.DotToken), identifierToken, default(TypeArgumentListSyntax?));

        /// <summary>Creates a new CompositeTypeNameSyntax instance.</summary>
        public static CompositeTypeNameSyntax CompositeTypeName(TypeNameSyntax @base, string identifierToken)
            => SyntaxFactory.CompositeTypeName(@base, SyntaxFactory.Token(SyntaxKind.DotToken), SyntaxFactory.Identifier(identifierToken), default(TypeArgumentListSyntax?));

        /// <summary>
        /// Creates a new
        /// <see cref="NilableTypeSyntax" />
        /// node.
        /// </summary>
        public static NilableTypeSyntax NilableType(TypeSyntax type, SyntaxToken questionToken)
        {
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (questionToken.Kind() != SyntaxKind.QuestionToken) throw new ArgumentException($"Invalid kind provided. Expected QuestionToken but got {questionToken.Kind()}.", nameof(questionToken));
            return (NilableTypeSyntax)Syntax.InternalSyntax.SyntaxFactory.NilableType((Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)questionToken.Node!).CreateRed();
        }

        /// <summary>Creates a new NilableTypeSyntax instance.</summary>
        public static NilableTypeSyntax NilableType(TypeSyntax type)
            => SyntaxFactory.NilableType(type, SyntaxFactory.Token(SyntaxKind.QuestionToken));

        /// <summary>
        /// Creates a new
        /// <see cref="ParenthesizedTypeSyntax" />
        /// node.
        /// </summary>
        public static ParenthesizedTypeSyntax ParenthesizedType(SyntaxToken openParenthesisToken, TypeSyntax type, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken.Kind() != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind()}.", nameof(openParenthesisToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenthesisToken.Kind() != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind()}.", nameof(closeParenthesisToken));
            return (ParenthesizedTypeSyntax)Syntax.InternalSyntax.SyntaxFactory.ParenthesizedType((Syntax.InternalSyntax.SyntaxToken)openParenthesisToken.Node!, (Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenthesisToken.Node!).CreateRed();
        }

        /// <summary>Creates a new ParenthesizedTypeSyntax instance.</summary>
        public static ParenthesizedTypeSyntax ParenthesizedType(TypeSyntax type)
            => SyntaxFactory.ParenthesizedType(SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), type, SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        /// <summary>
        /// Creates a new
        /// <see cref="TypePackSyntax" />
        /// node.
        /// </summary>
        public static TypePackSyntax TypePack(SyntaxToken openParenthesisToken, SeparatedSyntaxList<TypeSyntax> types, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken.Kind() != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind()}.", nameof(openParenthesisToken));
            if (closeParenthesisToken.Kind() != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind()}.", nameof(closeParenthesisToken));
            return (TypePackSyntax)Syntax.InternalSyntax.SyntaxFactory.TypePack((Syntax.InternalSyntax.SyntaxToken)openParenthesisToken.Node!, types.Node.ToGreenSeparatedList<Syntax.InternalSyntax.TypeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenthesisToken.Node!).CreateRed();
        }

        /// <summary>Creates a new TypePackSyntax instance.</summary>
        public static TypePackSyntax TypePack(SeparatedSyntaxList<TypeSyntax> types = default)
            => SyntaxFactory.TypePack(SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), types, SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        /// <summary>
        /// Creates a new
        /// <see cref="FunctionTypeSyntax" />
        /// node.
        /// </summary>
        public static FunctionTypeSyntax FunctionType(TypeParameterListSyntax? typeParameterList, SyntaxToken openParenthesisToken, SeparatedSyntaxList<TypeSyntax> parameters, SyntaxToken closeParenthesisToken, SyntaxToken minusGreaterThanToken, TypeSyntax returnType)
        {
            if (openParenthesisToken.Kind() != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind()}.", nameof(openParenthesisToken));
            if (closeParenthesisToken.Kind() != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind()}.", nameof(closeParenthesisToken));
            if (minusGreaterThanToken.Kind() != SyntaxKind.MinusGreaterThanToken) throw new ArgumentException($"Invalid kind provided. Expected MinusGreaterThanToken but got {minusGreaterThanToken.Kind()}.", nameof(minusGreaterThanToken));
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
            return (FunctionTypeSyntax)Syntax.InternalSyntax.SyntaxFactory.FunctionType(typeParameterList == null ? null : (Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, (Syntax.InternalSyntax.SyntaxToken)openParenthesisToken.Node!, parameters.Node.ToGreenSeparatedList<Syntax.InternalSyntax.TypeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenthesisToken.Node!, (Syntax.InternalSyntax.SyntaxToken)minusGreaterThanToken.Node!, (Syntax.InternalSyntax.TypeSyntax)returnType.Green).CreateRed();
        }

        /// <summary>Creates a new FunctionTypeSyntax instance.</summary>
        public static FunctionTypeSyntax FunctionType(TypeParameterListSyntax? typeParameterList, SeparatedSyntaxList<TypeSyntax> parameters, TypeSyntax returnType)
            => SyntaxFactory.FunctionType(typeParameterList, SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), parameters, SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken), SyntaxFactory.Token(SyntaxKind.MinusGreaterThanToken), returnType);

        /// <summary>Creates a new FunctionTypeSyntax instance.</summary>
        public static FunctionTypeSyntax FunctionType(TypeSyntax returnType)
            => SyntaxFactory.FunctionType(default(TypeParameterListSyntax?), SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), default(SeparatedSyntaxList<TypeSyntax>), SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken), SyntaxFactory.Token(SyntaxKind.MinusGreaterThanToken), returnType);

        /// <summary>
        /// Creates a new
        /// <see cref="ArrayTypeSyntax" />
        /// node.
        /// </summary>
        public static ArrayTypeSyntax ArrayType(SyntaxToken openBraceToken, TypeSyntax type, SyntaxToken closeBraceToken)
        {
            if (openBraceToken.Kind() != SyntaxKind.OpenBraceToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBraceToken but got {openBraceToken.Kind()}.", nameof(openBraceToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeBraceToken.Kind() != SyntaxKind.CloseBraceToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBraceToken but got {closeBraceToken.Kind()}.", nameof(closeBraceToken));
            return (ArrayTypeSyntax)Syntax.InternalSyntax.SyntaxFactory.ArrayType((Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node!, (Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node!).CreateRed();
        }

        /// <summary>Creates a new ArrayTypeSyntax instance.</summary>
        public static ArrayTypeSyntax ArrayType(TypeSyntax type)
            => SyntaxFactory.ArrayType(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), type, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));

        /// <summary>
        /// Creates a new
        /// <see cref="TableTypeIndexerSyntax" />
        /// node.
        /// </summary>
        public static TableTypeIndexerSyntax TableTypeIndexer(SyntaxToken openBracketToken, TypeSyntax indexType, SyntaxToken closeBracketToken, SyntaxToken colonToken, TypeSyntax valueType)
        {
            if (openBracketToken.Kind() != SyntaxKind.OpenBracketToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBracketToken but got {openBracketToken.Kind()}.", nameof(openBracketToken));
            if (indexType == null) throw new ArgumentNullException(nameof(indexType));
            if (closeBracketToken.Kind() != SyntaxKind.CloseBracketToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBracketToken but got {closeBracketToken.Kind()}.", nameof(closeBracketToken));
            if (colonToken.Kind() != SyntaxKind.ColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonToken but got {colonToken.Kind()}.", nameof(colonToken));
            if (valueType == null) throw new ArgumentNullException(nameof(valueType));
            return (TableTypeIndexerSyntax)Syntax.InternalSyntax.SyntaxFactory.TableTypeIndexer((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node!, (Syntax.InternalSyntax.TypeSyntax)indexType.Green, (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node!, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node!, (Syntax.InternalSyntax.TypeSyntax)valueType.Green).CreateRed();
        }

        /// <summary>Creates a new TableTypeIndexerSyntax instance.</summary>
        public static TableTypeIndexerSyntax TableTypeIndexer(TypeSyntax indexType, TypeSyntax valueType)
            => SyntaxFactory.TableTypeIndexer(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), indexType, SyntaxFactory.Token(SyntaxKind.CloseBracketToken), SyntaxFactory.Token(SyntaxKind.ColonToken), valueType);

        /// <summary>
        /// Creates a new
        /// <see cref="TableTypePropertySyntax" />
        /// node.
        /// </summary>
        public static TableTypePropertySyntax TableTypeProperty(SyntaxToken identifier, SyntaxToken colonToken, TypeSyntax valueType)
        {
            if (identifier.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind()}.", nameof(identifier));
            if (colonToken.Kind() != SyntaxKind.ColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonToken but got {colonToken.Kind()}.", nameof(colonToken));
            if (valueType == null) throw new ArgumentNullException(nameof(valueType));
            return (TableTypePropertySyntax)Syntax.InternalSyntax.SyntaxFactory.TableTypeProperty((Syntax.InternalSyntax.SyntaxToken)identifier.Node!, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node!, (Syntax.InternalSyntax.TypeSyntax)valueType.Green).CreateRed();
        }

        /// <summary>Creates a new TableTypePropertySyntax instance.</summary>
        public static TableTypePropertySyntax TableTypeProperty(SyntaxToken identifier, TypeSyntax valueType)
            => SyntaxFactory.TableTypeProperty(identifier, SyntaxFactory.Token(SyntaxKind.ColonToken), valueType);

        /// <summary>Creates a new TableTypePropertySyntax instance.</summary>
        public static TableTypePropertySyntax TableTypeProperty(string identifier, TypeSyntax valueType)
            => SyntaxFactory.TableTypeProperty(SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.ColonToken), valueType);

        /// <summary>
        /// Creates a new
        /// <see cref="TableTypeSyntax" />
        /// node.
        /// </summary>
        public static TableTypeSyntax TableType(SyntaxToken openBraceToken, SeparatedSyntaxList<TableTypeElementSyntax> elements, SyntaxToken closeBraceToken)
        {
            if (openBraceToken.Kind() != SyntaxKind.OpenBraceToken) throw new ArgumentException($"Invalid kind provided. Expected OpenBraceToken but got {openBraceToken.Kind()}.", nameof(openBraceToken));
            if (closeBraceToken.Kind() != SyntaxKind.CloseBraceToken) throw new ArgumentException($"Invalid kind provided. Expected CloseBraceToken but got {closeBraceToken.Kind()}.", nameof(closeBraceToken));
            return (TableTypeSyntax)Syntax.InternalSyntax.SyntaxFactory.TableType((Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node!, elements.Node.ToGreenSeparatedList<Syntax.InternalSyntax.TableTypeElementSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node!).CreateRed();
        }

        /// <summary>Creates a new TableTypeSyntax instance.</summary>
        public static TableTypeSyntax TableType(SeparatedSyntaxList<TableTypeElementSyntax> elements = default)
            => SyntaxFactory.TableType(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), elements, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));

        /// <summary>
        /// Creates a new
        /// <see cref="TypeCastExpressionSyntax" />
        /// node.
        /// </summary>
        public static TypeCastExpressionSyntax TypeCastExpression(ExpressionSyntax expression, SyntaxToken colonColonToken, TypeSyntax type)
        {
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (colonColonToken.Kind() != SyntaxKind.ColonColonToken) throw new ArgumentException($"Invalid kind provided. Expected ColonColonToken but got {colonColonToken.Kind()}.", nameof(colonColonToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            return (TypeCastExpressionSyntax)Syntax.InternalSyntax.SyntaxFactory.TypeCastExpression((Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)colonColonToken.Node!, (Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
        }

        /// <summary>Creates a new TypeCastExpressionSyntax instance.</summary>
        public static TypeCastExpressionSyntax TypeCastExpression(ExpressionSyntax expression, TypeSyntax type)
            => SyntaxFactory.TypeCastExpression(expression, SyntaxFactory.Token(SyntaxKind.ColonColonToken), type);

        /// <summary>
        /// Creates a new
        /// <see cref="UnionTypeSyntax" />
        /// node.
        /// </summary>
        public static UnionTypeSyntax UnionType(TypeSyntax left, SyntaxToken pipeToken, TypeSyntax right)
        {
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (pipeToken.Kind() != SyntaxKind.PipeToken) throw new ArgumentException($"Invalid kind provided. Expected PipeToken but got {pipeToken.Kind()}.", nameof(pipeToken));
            if (right == null) throw new ArgumentNullException(nameof(right));
            return (UnionTypeSyntax)Syntax.InternalSyntax.SyntaxFactory.UnionType((Syntax.InternalSyntax.TypeSyntax)left.Green, (Syntax.InternalSyntax.SyntaxToken)pipeToken.Node!, (Syntax.InternalSyntax.TypeSyntax)right.Green).CreateRed();
        }

        /// <summary>Creates a new UnionTypeSyntax instance.</summary>
        public static UnionTypeSyntax UnionType(TypeSyntax left, TypeSyntax right)
            => SyntaxFactory.UnionType(left, SyntaxFactory.Token(SyntaxKind.PipeToken), right);

        /// <summary>
        /// Creates a new
        /// <see cref="IntersectionTypeSyntax" />
        /// node.
        /// </summary>
        public static IntersectionTypeSyntax IntersectionType(TypeSyntax left, SyntaxToken ampersandToken, TypeSyntax right)
        {
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (ampersandToken.Kind() != SyntaxKind.AmpersandToken) throw new ArgumentException($"Invalid kind provided. Expected AmpersandToken but got {ampersandToken.Kind()}.", nameof(ampersandToken));
            if (right == null) throw new ArgumentNullException(nameof(right));
            return (IntersectionTypeSyntax)Syntax.InternalSyntax.SyntaxFactory.IntersectionType((Syntax.InternalSyntax.TypeSyntax)left.Green, (Syntax.InternalSyntax.SyntaxToken)ampersandToken.Node!, (Syntax.InternalSyntax.TypeSyntax)right.Green).CreateRed();
        }

        /// <summary>Creates a new IntersectionTypeSyntax instance.</summary>
        public static IntersectionTypeSyntax IntersectionType(TypeSyntax left, TypeSyntax right)
            => SyntaxFactory.IntersectionType(left, SyntaxFactory.Token(SyntaxKind.AmpersandToken), right);

        /// <summary>
        /// Creates a new
        /// <see cref="EqualsTypeSyntax" />
        /// node.
        /// </summary>
        public static EqualsTypeSyntax EqualsType(SyntaxToken equalsToken, TypeSyntax type)
        {
            if (equalsToken.Kind() != SyntaxKind.EqualsToken) throw new ArgumentException($"Invalid kind provided. Expected EqualsToken but got {equalsToken.Kind()}.", nameof(equalsToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            return (EqualsTypeSyntax)Syntax.InternalSyntax.SyntaxFactory.EqualsType((Syntax.InternalSyntax.SyntaxToken)equalsToken.Node!, (Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
        }

        /// <summary>Creates a new EqualsTypeSyntax instance.</summary>
        public static EqualsTypeSyntax EqualsType(TypeSyntax type)
            => SyntaxFactory.EqualsType(SyntaxFactory.Token(SyntaxKind.EqualsToken), type);

        /// <summary>
        /// Creates a new
        /// <see cref="TypeParameterSyntax" />
        /// node.
        /// </summary>
        public static TypeParameterSyntax TypeParameter(SyntaxToken identifier, SyntaxToken dotDotDotToken, EqualsTypeSyntax? equalsType)
        {
            if (identifier.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind()}.", nameof(identifier));
            switch (dotDotDotToken.Kind())
            {
                case SyntaxKind.DotDotDotToken:
                case SyntaxKind.None: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(dotDotDotToken));
            }
            return (TypeParameterSyntax)Syntax.InternalSyntax.SyntaxFactory.TypeParameter((Syntax.InternalSyntax.SyntaxToken)identifier.Node!, (Syntax.InternalSyntax.SyntaxToken?)dotDotDotToken.Node, equalsType == null ? null : (Syntax.InternalSyntax.EqualsTypeSyntax)equalsType.Green).CreateRed();
        }

        /// <summary>Creates a new TypeParameterSyntax instance.</summary>
        public static TypeParameterSyntax TypeParameter(SyntaxToken identifier, EqualsTypeSyntax? equalsType)
            => SyntaxFactory.TypeParameter(identifier, default(SyntaxToken), equalsType);

        /// <summary>Creates a new TypeParameterSyntax instance.</summary>
        public static TypeParameterSyntax TypeParameter(SyntaxToken identifier)
            => SyntaxFactory.TypeParameter(identifier, default(SyntaxToken), default(EqualsTypeSyntax?));

        /// <summary>Creates a new TypeParameterSyntax instance.</summary>
        public static TypeParameterSyntax TypeParameter(string identifier)
            => SyntaxFactory.TypeParameter(SyntaxFactory.Identifier(identifier), default(SyntaxToken), default(EqualsTypeSyntax?));

        /// <summary>
        /// Creates a new
        /// <see cref="TypeParameterListSyntax" />
        /// node.
        /// </summary>
        public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> names, SyntaxToken greaterThanToken)
        {
            if (lessThanToken.Kind() != SyntaxKind.LessThanToken) throw new ArgumentException($"Invalid kind provided. Expected LessThanToken but got {lessThanToken.Kind()}.", nameof(lessThanToken));
            if (greaterThanToken.Kind() != SyntaxKind.GreaterThanToken) throw new ArgumentException($"Invalid kind provided. Expected GreaterThanToken but got {greaterThanToken.Kind()}.", nameof(greaterThanToken));
            return (TypeParameterListSyntax)Syntax.InternalSyntax.SyntaxFactory.TypeParameterList((Syntax.InternalSyntax.SyntaxToken)lessThanToken.Node!, names.Node.ToGreenSeparatedList<Syntax.InternalSyntax.TypeParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)greaterThanToken.Node!).CreateRed();
        }

        /// <summary>Creates a new TypeParameterListSyntax instance.</summary>
        public static TypeParameterListSyntax TypeParameterList(SeparatedSyntaxList<TypeParameterSyntax> names = default)
            => SyntaxFactory.TypeParameterList(SyntaxFactory.Token(SyntaxKind.LessThanToken), names, SyntaxFactory.Token(SyntaxKind.GreaterThanToken));

        /// <summary>
        /// Creates a new
        /// <see cref="TypeArgumentListSyntax" />
        /// node.
        /// </summary>
        public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
        {
            if (lessThanToken.Kind() != SyntaxKind.LessThanToken) throw new ArgumentException($"Invalid kind provided. Expected LessThanToken but got {lessThanToken.Kind()}.", nameof(lessThanToken));
            if (greaterThanToken.Kind() != SyntaxKind.GreaterThanToken) throw new ArgumentException($"Invalid kind provided. Expected GreaterThanToken but got {greaterThanToken.Kind()}.", nameof(greaterThanToken));
            return (TypeArgumentListSyntax)Syntax.InternalSyntax.SyntaxFactory.TypeArgumentList((Syntax.InternalSyntax.SyntaxToken)lessThanToken.Node!, arguments.Node.ToGreenSeparatedList<Syntax.InternalSyntax.TypeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)greaterThanToken.Node!).CreateRed();
        }

        /// <summary>Creates a new TypeArgumentListSyntax instance.</summary>
        public static TypeArgumentListSyntax TypeArgumentList(SeparatedSyntaxList<TypeSyntax> arguments = default)
            => SyntaxFactory.TypeArgumentList(SyntaxFactory.Token(SyntaxKind.LessThanToken), arguments, SyntaxFactory.Token(SyntaxKind.GreaterThanToken));

        /// <summary>
        /// Creates a new
        /// <see cref="LiteralTypeSyntax" />
        /// node.
        /// </summary>
        public static LiteralTypeSyntax LiteralType(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.StringType:
                case SyntaxKind.TrueType:
                case SyntaxKind.FalseType:
                case SyntaxKind.NilType: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(kind));
            }
            switch (token.Kind())
            {
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NilKeyword: break;
                default: throw new ArgumentException("Provided kind is not one of the valid ones.", nameof(token));
            }
            return (LiteralTypeSyntax)Syntax.InternalSyntax.SyntaxFactory.LiteralType(kind, (Syntax.InternalSyntax.SyntaxToken)token.Node!).CreateRed();
        }

        /// <summary>Creates a new LiteralTypeSyntax instance.</summary>
        public static LiteralTypeSyntax LiteralType(SyntaxKind kind)
            => SyntaxFactory.LiteralType(kind, SyntaxFactory.Token(GetLiteralTypeTokenKind(kind)));

        private static SyntaxKind GetLiteralTypeTokenKind(SyntaxKind kind)
            => kind switch
            {
                SyntaxKind.StringType => SyntaxKind.StringLiteralToken,
                SyntaxKind.TrueType => SyntaxKind.TrueKeyword,
                SyntaxKind.FalseType => SyntaxKind.FalseKeyword,
                SyntaxKind.NilType => SyntaxKind.NilKeyword,
                _ => throw new ArgumentOutOfRangeException(),
            };

        /// <summary>
        /// Creates a new
        /// <see cref="TypeofTypeSyntax" />
        /// node.
        /// </summary>
        public static TypeofTypeSyntax TypeofType(SyntaxToken typeofKeyword, SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken)
        {
            if (typeofKeyword.Kind() != SyntaxKind.TypeofKeyword) throw new ArgumentException($"Invalid kind provided. Expected TypeofKeyword but got {typeofKeyword.Kind()}.", nameof(typeofKeyword));
            if (openParenthesisToken.Kind() != SyntaxKind.OpenParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected OpenParenthesisToken but got {openParenthesisToken.Kind()}.", nameof(openParenthesisToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenthesisToken.Kind() != SyntaxKind.CloseParenthesisToken) throw new ArgumentException($"Invalid kind provided. Expected CloseParenthesisToken but got {closeParenthesisToken.Kind()}.", nameof(closeParenthesisToken));
            return (TypeofTypeSyntax)Syntax.InternalSyntax.SyntaxFactory.TypeofType((Syntax.InternalSyntax.SyntaxToken)typeofKeyword.Node!, (Syntax.InternalSyntax.SyntaxToken)openParenthesisToken.Node!, (Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenthesisToken.Node!).CreateRed();
        }

        /// <summary>Creates a new TypeofTypeSyntax instance.</summary>
        public static TypeofTypeSyntax TypeofType(ExpressionSyntax expression)
            => SyntaxFactory.TypeofType(SyntaxFactory.Token(SyntaxKind.TypeofKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenthesisToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenthesisToken));

        /// <summary>
        /// Creates a new
        /// <see cref="VariadicTypePackSyntax" />
        /// node.
        /// </summary>
        public static VariadicTypePackSyntax VariadicTypePack(SyntaxToken dotDotDotToken, TypeSyntax type)
        {
            if (dotDotDotToken.Kind() != SyntaxKind.DotDotDotToken) throw new ArgumentException($"Invalid kind provided. Expected DotDotDotToken but got {dotDotDotToken.Kind()}.", nameof(dotDotDotToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            return (VariadicTypePackSyntax)Syntax.InternalSyntax.SyntaxFactory.VariadicTypePack((Syntax.InternalSyntax.SyntaxToken)dotDotDotToken.Node!, (Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
        }

        /// <summary>Creates a new VariadicTypePackSyntax instance.</summary>
        public static VariadicTypePackSyntax VariadicTypePack(TypeSyntax type)
            => SyntaxFactory.VariadicTypePack(SyntaxFactory.Token(SyntaxKind.DotDotDotToken), type);

        /// <summary>
        /// Creates a new
        /// <see cref="GenericTypePackSyntax" />
        /// node.
        /// </summary>
        public static GenericTypePackSyntax GenericTypePack(SyntaxToken identifier, SyntaxToken dotDotDotToken)
        {
            if (identifier.Kind() != SyntaxKind.IdentifierToken) throw new ArgumentException($"Invalid kind provided. Expected IdentifierToken but got {identifier.Kind()}.", nameof(identifier));
            if (dotDotDotToken.Kind() != SyntaxKind.DotDotDotToken) throw new ArgumentException($"Invalid kind provided. Expected DotDotDotToken but got {dotDotDotToken.Kind()}.", nameof(dotDotDotToken));
            return (GenericTypePackSyntax)Syntax.InternalSyntax.SyntaxFactory.GenericTypePack((Syntax.InternalSyntax.SyntaxToken)identifier.Node!, (Syntax.InternalSyntax.SyntaxToken)dotDotDotToken.Node!).CreateRed();
        }

        /// <summary>Creates a new GenericTypePackSyntax instance.</summary>
        public static GenericTypePackSyntax GenericTypePack(SyntaxToken identifier)
            => SyntaxFactory.GenericTypePack(identifier, SyntaxFactory.Token(SyntaxKind.DotDotDotToken));

        /// <summary>Creates a new GenericTypePackSyntax instance.</summary>
        public static GenericTypePackSyntax GenericTypePack(string identifier)
            => SyntaxFactory.GenericTypePack(SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.DotDotDotToken));

        /// <summary>
        /// Creates a new
        /// <see cref="CompilationUnitSyntax" />
        /// node.
        /// </summary>
        public static CompilationUnitSyntax CompilationUnit(StatementListSyntax statements, SyntaxToken endOfFileToken)
        {
            if (statements == null) throw new ArgumentNullException(nameof(statements));
            if (endOfFileToken.Kind() != SyntaxKind.EndOfFileToken) throw new ArgumentException($"Invalid kind provided. Expected EndOfFileToken but got {endOfFileToken.Kind()}.", nameof(endOfFileToken));
            return (CompilationUnitSyntax)Syntax.InternalSyntax.SyntaxFactory.CompilationUnit((Syntax.InternalSyntax.StatementListSyntax)statements.Green, (Syntax.InternalSyntax.SyntaxToken)endOfFileToken.Node!).CreateRed();
        }

        /// <summary>Creates a new CompilationUnitSyntax instance.</summary>
        public static CompilationUnitSyntax CompilationUnit(StatementListSyntax statements)
            => SyntaxFactory.CompilationUnit(statements, SyntaxFactory.Token(SyntaxKind.EndOfFileToken));
    }
}
