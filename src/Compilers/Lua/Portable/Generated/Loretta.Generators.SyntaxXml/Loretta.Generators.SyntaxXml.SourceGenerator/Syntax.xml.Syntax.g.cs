// <auto-generated />

#pragma warning disable CS1591
#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Loretta.CodeAnalysis.Syntax.InternalSyntax;
using Loretta.Utilities;

namespace Loretta.CodeAnalysis.Lua.Syntax
{


    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SkippedTokensTrivia"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {

        internal SkippedTokensTriviaSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        public SyntaxTokenList Tokens
        {
            get
            {
                var slot = this.Green.GetSlot(0);
                return slot != null ? new SyntaxTokenList(this, slot, Position, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens) => Update(tokens);

        public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items) => WithTokens(this.Tokens.AddRange(items));
    }

    /// <summary>Represents a block of code.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.StatementList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class StatementListSyntax : LuaSyntaxNode
    {
        private SyntaxNode? statements;

        internal StatementListSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The list of statements contained within this block.</summary>
        public SyntaxList<StatementSyntax> Statements => new SyntaxList<StatementSyntax>(GetRed(ref this.statements, 0));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.statements)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.statements : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitStatementList(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitStatementList(this);

        public StatementListSyntax Update(SyntaxList<StatementSyntax> statements)
        {
            if (statements != this.Statements)
            {
                var newNode = SyntaxFactory.StatementList(statements);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public StatementListSyntax WithStatements(SyntaxList<StatementSyntax> statements) => Update(statements);

        public StatementListSyntax AddStatements(params StatementSyntax[] items) => WithStatements(this.Statements.AddRange(items));
    }

    /// <summary>The base type for parameter nodes.</summary>
    public abstract partial class ParameterSyntax : LuaSyntaxNode
    {
        internal ParameterSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>Represents a named function parameter.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NamedParameter"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class NamedParameterSyntax : ParameterSyntax
    {
        private TypeBindingSyntax? typeBinding;

        internal NamedParameterSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The name of the parameter.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.NamedParameterSyntax)this.Green).identifier, Position, 0);

        /// <summary>
        /// The
        /// <see cref="TypeBindingSyntax" />
        /// containing the (optional) type.
        /// </summary>
        public TypeBindingSyntax? TypeBinding => GetRed(ref this.typeBinding, 1);

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.typeBinding, 1) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.typeBinding : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitNamedParameter(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitNamedParameter(this);

        public NamedParameterSyntax Update(SyntaxToken identifier, TypeBindingSyntax? typeBinding)
        {
            if (identifier != this.Identifier || typeBinding != this.TypeBinding)
            {
                var newNode = SyntaxFactory.NamedParameter(identifier, typeBinding);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public NamedParameterSyntax WithIdentifier(SyntaxToken identifier) => Update(identifier, this.TypeBinding);
        public NamedParameterSyntax WithTypeBinding(TypeBindingSyntax? typeBinding) => Update(this.Identifier, typeBinding);
    }

    /// <summary>Represents a vararg function parameter.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.VarArgParameter"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class VarArgParameterSyntax : ParameterSyntax
    {
        private TypeBindingSyntax? typeBinding;

        internal VarArgParameterSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The vararg token.</summary>
        public SyntaxToken VarArgToken => new SyntaxToken(this, ((Syntax.InternalSyntax.VarArgParameterSyntax)this.Green).varArgToken, Position, 0);

        /// <summary>
        /// The
        /// <see cref="TypeBindingSyntax" />
        /// containing the (optional) type.
        /// </summary>
        public TypeBindingSyntax? TypeBinding => GetRed(ref this.typeBinding, 1);

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.typeBinding, 1) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.typeBinding : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitVarArgParameter(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitVarArgParameter(this);

        public VarArgParameterSyntax Update(SyntaxToken varArgToken, TypeBindingSyntax? typeBinding)
        {
            if (varArgToken != this.VarArgToken || typeBinding != this.TypeBinding)
            {
                var newNode = SyntaxFactory.VarArgParameter(varArgToken, typeBinding);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public VarArgParameterSyntax WithVarArgToken(SyntaxToken varArgToken) => Update(varArgToken, this.TypeBinding);
        public VarArgParameterSyntax WithTypeBinding(TypeBindingSyntax? typeBinding) => Update(this.VarArgToken, typeBinding);
    }

    /// <summary>Represents a function declaration's parameter list.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ParameterList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParameterListSyntax : LuaSyntaxNode
    {
        private SyntaxNode? parameters;

        internal ParameterListSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The parameter list opening parenthesis.</summary>
        public SyntaxToken OpenParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterListSyntax)this.Green).openParenthesisToken, Position, 0);

        /// <summary>The parameter list opening parenthesis.</summary>
        public SeparatedSyntaxList<ParameterSyntax> Parameters
        {
            get
            {
                var red = GetRed(ref this.parameters, 1);
                return red != null ? new SeparatedSyntaxList<ParameterSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>The close parenthesis token.</summary>
        public SyntaxToken CloseParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParameterListSyntax)this.Green).closeParenthesisToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.parameters, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.parameters : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitParameterList(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParameterList(this);

        public ParameterListSyntax Update(SyntaxToken openParenthesisToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken != this.OpenParenthesisToken || parameters != this.Parameters || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.ParameterList(openParenthesisToken, parameters, closeParenthesisToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParameterListSyntax WithOpenParenthesisToken(SyntaxToken openParenthesisToken) => Update(openParenthesisToken, this.Parameters, this.CloseParenthesisToken);
        public ParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters) => Update(this.OpenParenthesisToken, parameters, this.CloseParenthesisToken);
        public ParameterListSyntax WithCloseParenthesisToken(SyntaxToken closeParenthesisToken) => Update(this.OpenParenthesisToken, this.Parameters, closeParenthesisToken);

        public ParameterListSyntax AddParameters(params ParameterSyntax[] items) => WithParameters(this.Parameters.AddRange(items));
    }

    /// <summary>The base class for table fields.</summary>
    public abstract partial class TableFieldSyntax : LuaSyntaxNode
    {
        internal TableFieldSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>Represents a table field whose key is an identifier.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IdentifierKeyedTableField"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IdentifierKeyedTableFieldSyntax : TableFieldSyntax
    {
        private ExpressionSyntax? value;

        internal IdentifierKeyedTableFieldSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The table field's key.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.IdentifierKeyedTableFieldSyntax)this.Green).identifier, Position, 0);

        /// <summary>The equals token.</summary>
        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.IdentifierKeyedTableFieldSyntax)this.Green).equalsToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The table field's value.</summary>
        public ExpressionSyntax Value => GetRed(ref this.value, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.value, 2)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.value : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIdentifierKeyedTableField(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIdentifierKeyedTableField(this);

        public IdentifierKeyedTableFieldSyntax Update(SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax value)
        {
            if (identifier != this.Identifier || equalsToken != this.EqualsToken || value != this.Value)
            {
                var newNode = SyntaxFactory.IdentifierKeyedTableField(identifier, equalsToken, value);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public IdentifierKeyedTableFieldSyntax WithIdentifier(SyntaxToken identifier) => Update(identifier, this.EqualsToken, this.Value);
        public IdentifierKeyedTableFieldSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.Identifier, equalsToken, this.Value);
        public IdentifierKeyedTableFieldSyntax WithValue(ExpressionSyntax value) => Update(this.Identifier, this.EqualsToken, value);
    }

    /// <summary>Represents a table field whose key is an expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ExpressionKeyedTableField"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ExpressionKeyedTableFieldSyntax : TableFieldSyntax
    {
        private ExpressionSyntax? key;
        private ExpressionSyntax? value;

        internal ExpressionKeyedTableFieldSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The opening bracket token.</summary>
        public SyntaxToken OpenBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ExpressionKeyedTableFieldSyntax)this.Green).openBracketToken, Position, 0);

        /// <summary>The table field's key.</summary>
        public ExpressionSyntax Key => GetRed(ref this.key, 1)!;

        /// <summary>The closing bracket token.</summary>
        public SyntaxToken CloseBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ExpressionKeyedTableFieldSyntax)this.Green).closeBracketToken, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The equals token.</summary>
        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ExpressionKeyedTableFieldSyntax)this.Green).equalsToken, GetChildPosition(3), GetChildIndex(3));

        /// <summary>The field's value.</summary>
        public ExpressionSyntax Value => GetRed(ref this.value, 4)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.key, 1)!,
                4 => GetRed(ref this.value, 4)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.key,
                4 => this.value,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitExpressionKeyedTableField(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitExpressionKeyedTableField(this);

        public ExpressionKeyedTableFieldSyntax Update(SyntaxToken openBracketToken, ExpressionSyntax key, SyntaxToken closeBracketToken, SyntaxToken equalsToken, ExpressionSyntax value)
        {
            if (openBracketToken != this.OpenBracketToken || key != this.Key || closeBracketToken != this.CloseBracketToken || equalsToken != this.EqualsToken || value != this.Value)
            {
                var newNode = SyntaxFactory.ExpressionKeyedTableField(openBracketToken, key, closeBracketToken, equalsToken, value);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ExpressionKeyedTableFieldSyntax WithOpenBracketToken(SyntaxToken openBracketToken) => Update(openBracketToken, this.Key, this.CloseBracketToken, this.EqualsToken, this.Value);
        public ExpressionKeyedTableFieldSyntax WithKey(ExpressionSyntax key) => Update(this.OpenBracketToken, key, this.CloseBracketToken, this.EqualsToken, this.Value);
        public ExpressionKeyedTableFieldSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) => Update(this.OpenBracketToken, this.Key, closeBracketToken, this.EqualsToken, this.Value);
        public ExpressionKeyedTableFieldSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.OpenBracketToken, this.Key, this.CloseBracketToken, equalsToken, this.Value);
        public ExpressionKeyedTableFieldSyntax WithValue(ExpressionSyntax value) => Update(this.OpenBracketToken, this.Key, this.CloseBracketToken, this.EqualsToken, value);
    }

    /// <summary>Represents a table field without a key.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.UnkeyedTableField"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class UnkeyedTableFieldSyntax : TableFieldSyntax
    {
        private ExpressionSyntax? value;

        internal UnkeyedTableFieldSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The table field's value.</summary>
        public ExpressionSyntax Value => GetRedAtZero(ref this.value)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.value)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.value : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitUnkeyedTableField(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitUnkeyedTableField(this);

        public UnkeyedTableFieldSyntax Update(ExpressionSyntax value)
        {
            if (value != this.Value)
            {
                var newNode = SyntaxFactory.UnkeyedTableField(value);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public UnkeyedTableFieldSyntax WithValue(ExpressionSyntax value) => Update(value);
    }

    /// <summary>The base class for function name nodes.</summary>
    public abstract partial class FunctionNameSyntax : LuaSyntaxNode
    {
        internal FunctionNameSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The member name.</summary>
        public abstract SyntaxToken Name { get; }
        public FunctionNameSyntax WithName(SyntaxToken name) => WithNameCore(name);
        internal abstract FunctionNameSyntax WithNameCore(SyntaxToken name);
    }

    /// <summary>Represents a function name which is only an identifier.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SimpleFunctionName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SimpleFunctionNameSyntax : FunctionNameSyntax
    {

        internal SimpleFunctionNameSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The function name.</summary>
        public override SyntaxToken Name => new SyntaxToken(this, ((Syntax.InternalSyntax.SimpleFunctionNameSyntax)this.Green).name, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitSimpleFunctionName(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSimpleFunctionName(this);

        public SimpleFunctionNameSyntax Update(SyntaxToken name)
        {
            if (name != this.Name)
            {
                var newNode = SyntaxFactory.SimpleFunctionName(name);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override FunctionNameSyntax WithNameCore(SyntaxToken name) => WithName(name);
        public new SimpleFunctionNameSyntax WithName(SyntaxToken name) => Update(name);
    }

    /// <summary>Represents a function name which is a member.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.MemberFunctionName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class MemberFunctionNameSyntax : FunctionNameSyntax
    {
        private FunctionNameSyntax? baseName;

        internal MemberFunctionNameSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The base function name.</summary>
        public FunctionNameSyntax BaseName => GetRedAtZero(ref this.baseName)!;

        /// <summary>The dot token.</summary>
        public SyntaxToken DotToken => new SyntaxToken(this, ((Syntax.InternalSyntax.MemberFunctionNameSyntax)this.Green).dotToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The member name.</summary>
        public override SyntaxToken Name => new SyntaxToken(this, ((Syntax.InternalSyntax.MemberFunctionNameSyntax)this.Green).name, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.baseName)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.baseName : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitMemberFunctionName(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitMemberFunctionName(this);

        public MemberFunctionNameSyntax Update(FunctionNameSyntax baseName, SyntaxToken dotToken, SyntaxToken name)
        {
            if (baseName != this.BaseName || dotToken != this.DotToken || name != this.Name)
            {
                var newNode = SyntaxFactory.MemberFunctionName(baseName, dotToken, name);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public MemberFunctionNameSyntax WithBaseName(FunctionNameSyntax baseName) => Update(baseName, this.DotToken, this.Name);
        public MemberFunctionNameSyntax WithDotToken(SyntaxToken dotToken) => Update(this.BaseName, dotToken, this.Name);
        internal override FunctionNameSyntax WithNameCore(SyntaxToken name) => WithName(name);
        public new MemberFunctionNameSyntax WithName(SyntaxToken name) => Update(this.BaseName, this.DotToken, name);
    }

    /// <summary>Represents a method-style function name syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.MethodFunctionName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class MethodFunctionNameSyntax : FunctionNameSyntax
    {
        private FunctionNameSyntax? baseName;

        internal MethodFunctionNameSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The base name for this method.</summary>
        public FunctionNameSyntax BaseName => GetRedAtZero(ref this.baseName)!;

        /// <summary>The colon token.</summary>
        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.MethodFunctionNameSyntax)this.Green).colonToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The method name.</summary>
        public override SyntaxToken Name => new SyntaxToken(this, ((Syntax.InternalSyntax.MethodFunctionNameSyntax)this.Green).name, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.baseName)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.baseName : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitMethodFunctionName(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitMethodFunctionName(this);

        public MethodFunctionNameSyntax Update(FunctionNameSyntax baseName, SyntaxToken colonToken, SyntaxToken name)
        {
            if (baseName != this.BaseName || colonToken != this.ColonToken || name != this.Name)
            {
                var newNode = SyntaxFactory.MethodFunctionName(baseName, colonToken, name);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public MethodFunctionNameSyntax WithBaseName(FunctionNameSyntax baseName) => Update(baseName, this.ColonToken, this.Name);
        public MethodFunctionNameSyntax WithColonToken(SyntaxToken colonToken) => Update(this.BaseName, colonToken, this.Name);
        internal override FunctionNameSyntax WithNameCore(SyntaxToken name) => WithName(name);
        public new MethodFunctionNameSyntax WithName(SyntaxToken name) => Update(this.BaseName, this.ColonToken, name);
    }

    /// <summary>The base class for function arguments.</summary>
    public abstract partial class FunctionArgumentSyntax : LuaSyntaxNode
    {
        internal FunctionArgumentSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>Represents a string being passed as a function call's argument.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.StringFunctionArgument"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class StringFunctionArgumentSyntax : FunctionArgumentSyntax
    {
        private LiteralExpressionSyntax? expression;

        internal StringFunctionArgumentSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The string literal being passed as an argument.</summary>
        public LiteralExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.expression)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.expression : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitStringFunctionArgument(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitStringFunctionArgument(this);

        public StringFunctionArgumentSyntax Update(LiteralExpressionSyntax expression)
        {
            if (expression != this.Expression)
            {
                var newNode = SyntaxFactory.StringFunctionArgument(expression);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public StringFunctionArgumentSyntax WithExpression(LiteralExpressionSyntax expression) => Update(expression);
    }

    /// <summary>Represents a table being passed as a function call's arguments.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TableConstructorFunctionArgument"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TableConstructorFunctionArgumentSyntax : FunctionArgumentSyntax
    {
        private TableConstructorExpressionSyntax? tableConstructor;

        internal TableConstructorFunctionArgumentSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The actual table constructor.</summary>
        public TableConstructorExpressionSyntax TableConstructor => GetRedAtZero(ref this.tableConstructor)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.tableConstructor)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.tableConstructor : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTableConstructorFunctionArgument(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTableConstructorFunctionArgument(this);

        public TableConstructorFunctionArgumentSyntax Update(TableConstructorExpressionSyntax tableConstructor)
        {
            if (tableConstructor != this.TableConstructor)
            {
                var newNode = SyntaxFactory.TableConstructorFunctionArgument(tableConstructor);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TableConstructorFunctionArgumentSyntax WithTableConstructor(TableConstructorExpressionSyntax tableConstructor) => Update(tableConstructor);

        public TableConstructorFunctionArgumentSyntax AddTableConstructorFields(params TableFieldSyntax[] items) => WithTableConstructor(this.TableConstructor.WithFields(this.TableConstructor.Fields.AddRange(items)));
    }

    /// <summary>Represents a list of expressions being passed as a function's arguments.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ExpressionListFunctionArgument"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ExpressionListFunctionArgumentSyntax : FunctionArgumentSyntax
    {
        private SyntaxNode? expressions;

        internal ExpressionListFunctionArgumentSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The argument list's opening parenthesis token.</summary>
        public SyntaxToken OpenParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ExpressionListFunctionArgumentSyntax)this.Green).openParenthesisToken, Position, 0);

        /// <summary>The list of expressions.</summary>
        public SeparatedSyntaxList<ExpressionSyntax> Expressions
        {
            get
            {
                var red = GetRed(ref this.expressions, 1);
                return red != null ? new SeparatedSyntaxList<ExpressionSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>The argument list's closing parenthesis token.</summary>
        public SyntaxToken CloseParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ExpressionListFunctionArgumentSyntax)this.Green).closeParenthesisToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expressions, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expressions : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitExpressionListFunctionArgument(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitExpressionListFunctionArgument(this);

        public ExpressionListFunctionArgumentSyntax Update(SyntaxToken openParenthesisToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken != this.OpenParenthesisToken || expressions != this.Expressions || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.ExpressionListFunctionArgument(openParenthesisToken, expressions, closeParenthesisToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ExpressionListFunctionArgumentSyntax WithOpenParenthesisToken(SyntaxToken openParenthesisToken) => Update(openParenthesisToken, this.Expressions, this.CloseParenthesisToken);
        public ExpressionListFunctionArgumentSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions) => Update(this.OpenParenthesisToken, expressions, this.CloseParenthesisToken);
        public ExpressionListFunctionArgumentSyntax WithCloseParenthesisToken(SyntaxToken closeParenthesisToken) => Update(this.OpenParenthesisToken, this.Expressions, closeParenthesisToken);

        public ExpressionListFunctionArgumentSyntax AddExpressions(params ExpressionSyntax[] items) => WithExpressions(this.Expressions.AddRange(items));
    }

    /// <summary>
    /// The base class interpolated string parts, either an
    /// <see cref="InterpolatedStringTextSyntax" />
    /// with
    /// plain text or an
    /// <see cref="InterpolationSyntax" />
    /// with an expression to be formatted.
    /// </summary>
    public abstract partial class InterpolatedStringContentSyntax : LuaSyntaxNode
    {
        internal InterpolatedStringContentSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>
    /// The part of an interpolated string with plain text.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.InterpolatedStringText"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
    {

        internal InterpolatedStringTextSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The text contents of a part of the interpolated string.</summary>
        public SyntaxToken TextToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolatedStringTextSyntax)this.Green).textToken, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitInterpolatedStringText(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInterpolatedStringText(this);

        public InterpolatedStringTextSyntax Update(SyntaxToken textToken)
        {
            if (textToken != this.TextToken)
            {
                var newNode = SyntaxFactory.InterpolatedStringText(textToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InterpolatedStringTextSyntax WithTextToken(SyntaxToken textToken) => Update(textToken);
    }

    /// <summary>
    /// An expression to be interpolated into the string.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.Interpolation"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
    {
        private ExpressionSyntax? expression;

        internal InterpolationSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// This could be a single <c>{</c> or multiple in a row.
        /// </summary>
        public SyntaxToken OpenBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolationSyntax)this.Green).openBraceToken, Position, 0);

        public ExpressionSyntax Expression => GetRed(ref this.expression, 1)!;

        /// <summary>
        /// This could be a single <c>}</c> or multiple in a row.
        /// </summary>
        public SyntaxToken CloseBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolationSyntax)this.Green).closeBraceToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitInterpolation(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInterpolation(this);

        public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || expression != this.Expression || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.Interpolation(openBraceToken, expression, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InterpolationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) => Update(openBraceToken, this.Expression, this.CloseBraceToken);
        public InterpolationSyntax WithExpression(ExpressionSyntax expression) => Update(this.OpenBraceToken, expression, this.CloseBraceToken);
        public InterpolationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.OpenBraceToken, this.Expression, closeBraceToken);
    }

    /// <summary>The base class for expressions.</summary>
    public abstract partial class ExpressionSyntax : LuaSyntaxNode
    {
        internal ExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>Represents an anonymous function expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AnonymousFunctionExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class AnonymousFunctionExpressionSyntax : ExpressionSyntax
    {
        private TypeParameterListSyntax? typeParameterList;
        private ParameterListSyntax? parameters;
        private TypeBindingSyntax? typeBinding;
        private StatementListSyntax? body;

        internal AnonymousFunctionExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'function' keyword.</summary>
        public SyntaxToken FunctionKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.AnonymousFunctionExpressionSyntax)this.Green).functionKeyword, Position, 0);

        /// <summary>Gets the type parameter list for this function (if any).</summary>
        public TypeParameterListSyntax? TypeParameterList => GetRed(ref this.typeParameterList, 1);

        /// <summary>The list of parameters.</summary>
        public ParameterListSyntax Parameters => GetRed(ref this.parameters, 2)!;

        /// <summary>The function's (optional) return type.</summary>
        public TypeBindingSyntax? TypeBinding => GetRed(ref this.typeBinding, 3);

        /// <summary>The function's body.</summary>
        public StatementListSyntax Body => GetRed(ref this.body, 4)!;

        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.AnonymousFunctionExpressionSyntax)this.Green).endKeyword, GetChildPosition(5), GetChildIndex(5));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.typeParameterList, 1),
                2 => GetRed(ref this.parameters, 2)!,
                3 => GetRed(ref this.typeBinding, 3),
                4 => GetRed(ref this.body, 4)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.typeParameterList,
                2 => this.parameters,
                3 => this.typeBinding,
                4 => this.body,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitAnonymousFunctionExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitAnonymousFunctionExpression(this);

        public AnonymousFunctionExpressionSyntax Update(SyntaxToken functionKeyword, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword)
        {
            if (functionKeyword != this.FunctionKeyword || typeParameterList != this.TypeParameterList || parameters != this.Parameters || typeBinding != this.TypeBinding || body != this.Body || endKeyword != this.EndKeyword)
            {
                var newNode = SyntaxFactory.AnonymousFunctionExpression(functionKeyword, typeParameterList, parameters, typeBinding, body, endKeyword);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public AnonymousFunctionExpressionSyntax WithFunctionKeyword(SyntaxToken functionKeyword) => Update(functionKeyword, this.TypeParameterList, this.Parameters, this.TypeBinding, this.Body, this.EndKeyword);
        public AnonymousFunctionExpressionSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) => Update(this.FunctionKeyword, typeParameterList, this.Parameters, this.TypeBinding, this.Body, this.EndKeyword);
        public AnonymousFunctionExpressionSyntax WithParameters(ParameterListSyntax parameters) => Update(this.FunctionKeyword, this.TypeParameterList, parameters, this.TypeBinding, this.Body, this.EndKeyword);
        public AnonymousFunctionExpressionSyntax WithTypeBinding(TypeBindingSyntax? typeBinding) => Update(this.FunctionKeyword, this.TypeParameterList, this.Parameters, typeBinding, this.Body, this.EndKeyword);
        public AnonymousFunctionExpressionSyntax WithBody(StatementListSyntax body) => Update(this.FunctionKeyword, this.TypeParameterList, this.Parameters, this.TypeBinding, body, this.EndKeyword);
        public AnonymousFunctionExpressionSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.FunctionKeyword, this.TypeParameterList, this.Parameters, this.TypeBinding, this.Body, endKeyword);

        public AnonymousFunctionExpressionSyntax AddTypeParameterListNames(params TypeParameterSyntax[] items)
        {
            var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
            return WithTypeParameterList(typeParameterList.WithNames(typeParameterList.Names.AddRange(items)));
        }
        public AnonymousFunctionExpressionSyntax AddParametersParameters(params ParameterSyntax[] items) => WithParameters(this.Parameters.WithParameters(this.Parameters.Parameters.AddRange(items)));
        public AnonymousFunctionExpressionSyntax AddBodyStatements(params StatementSyntax[] items) => WithBody(this.Body.WithStatements(this.Body.Statements.AddRange(items)));
    }

    /// <summary>Represents a table constructor expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TableConstructorExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TableConstructorExpressionSyntax : ExpressionSyntax
    {
        private SyntaxNode? fields;

        internal TableConstructorExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The opening brace token.</summary>
        public SyntaxToken OpenBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TableConstructorExpressionSyntax)this.Green).openBraceToken, Position, 0);

        /// <summary>The list of fields.</summary>
        public SeparatedSyntaxList<TableFieldSyntax> Fields
        {
            get
            {
                var red = GetRed(ref this.fields, 1);
                return red != null ? new SeparatedSyntaxList<TableFieldSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>The closing brace token.</summary>
        public SyntaxToken CloseBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TableConstructorExpressionSyntax)this.Green).closeBraceToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.fields, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.fields : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTableConstructorExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTableConstructorExpression(this);

        public TableConstructorExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<TableFieldSyntax> fields, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || fields != this.Fields || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.TableConstructorExpression(openBraceToken, fields, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TableConstructorExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken) => Update(openBraceToken, this.Fields, this.CloseBraceToken);
        public TableConstructorExpressionSyntax WithFields(SeparatedSyntaxList<TableFieldSyntax> fields) => Update(this.OpenBraceToken, fields, this.CloseBraceToken);
        public TableConstructorExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.OpenBraceToken, this.Fields, closeBraceToken);

        public TableConstructorExpressionSyntax AddFields(params TableFieldSyntax[] items) => WithFields(this.Fields.AddRange(items));
    }

    /// <summary>Represents a literal expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NumericalLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.StringLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.TrueLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.FalseLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.NilLiteralExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.HashStringLiteralExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LiteralExpressionSyntax : ExpressionSyntax
    {

        internal LiteralExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The literal token.</summary>
        public SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.LiteralExpressionSyntax)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLiteralExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLiteralExpression(this);

        public LiteralExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralExpression(this.Kind(), token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LiteralExpressionSyntax WithToken(SyntaxToken token) => Update(token);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.InterpolatedStringExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class InterpolatedStringExpressionSyntax : ExpressionSyntax
    {
        private SyntaxNode? contents;

        internal InterpolatedStringExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// The first part of an interpolated string:
        /// <c>`</c>
        /// </summary>
        public SyntaxToken StringStartToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolatedStringExpressionSyntax)this.Green).stringStartToken, Position, 0);

        /// <summary>
        /// List of parts of the interpolated string, each one is either a literal part or an interpolation.
        /// </summary>
        public SyntaxList<InterpolatedStringContentSyntax> Contents => new SyntaxList<InterpolatedStringContentSyntax>(GetRed(ref this.contents, 1));

        /// <summary>
        /// The closing <c>`</c> of the interpolated string.
        /// </summary>
        public SyntaxToken StringEndToken => new SyntaxToken(this, ((Syntax.InternalSyntax.InterpolatedStringExpressionSyntax)this.Green).stringEndToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.contents, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.contents : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitInterpolatedStringExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitInterpolatedStringExpression(this);

        public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
        {
            if (stringStartToken != this.StringStartToken || contents != this.Contents || stringEndToken != this.StringEndToken)
            {
                var newNode = SyntaxFactory.InterpolatedStringExpression(stringStartToken, contents, stringEndToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public InterpolatedStringExpressionSyntax WithStringStartToken(SyntaxToken stringStartToken) => Update(stringStartToken, this.Contents, this.StringEndToken);
        public InterpolatedStringExpressionSyntax WithContents(SyntaxList<InterpolatedStringContentSyntax> contents) => Update(this.StringStartToken, contents, this.StringEndToken);
        public InterpolatedStringExpressionSyntax WithStringEndToken(SyntaxToken stringEndToken) => Update(this.StringStartToken, this.Contents, stringEndToken);

        public InterpolatedStringExpressionSyntax AddContents(params InterpolatedStringContentSyntax[] items) => WithContents(this.Contents.AddRange(items));
    }

    /// <summary>Represents a vararg expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.VarArgExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class VarArgExpressionSyntax : ExpressionSyntax
    {

        internal VarArgExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The vararg token.</summary>
        public SyntaxToken VarArgToken => new SyntaxToken(this, ((Syntax.InternalSyntax.VarArgExpressionSyntax)this.Green).varArgToken, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitVarArgExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitVarArgExpression(this);

        public VarArgExpressionSyntax Update(SyntaxToken varArgToken)
        {
            if (varArgToken != this.VarArgToken)
            {
                var newNode = SyntaxFactory.VarArgExpression(varArgToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public VarArgExpressionSyntax WithVarArgToken(SyntaxToken varArgToken) => Update(varArgToken);
    }

    /// <summary>The base class for variable expressions (values that can be assigned to).</summary>
    public abstract partial class VariableExpressionSyntax : PrefixExpressionSyntax
    {
        internal VariableExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>A name expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IdentifierName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IdentifierNameSyntax : VariableExpressionSyntax
    {

        internal IdentifierNameSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The identifier.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.IdentifierNameSyntax)this.Green).identifier, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIdentifierName(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIdentifierName(this);

        public IdentifierNameSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.IdentifierName(identifier);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public IdentifierNameSyntax WithIdentifier(SyntaxToken identifier) => Update(identifier);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.MemberAccessExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class MemberAccessExpressionSyntax : VariableExpressionSyntax
    {
        private PrefixExpressionSyntax? expression;

        internal MemberAccessExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The expression that contains the member being accessed.</summary>
        public PrefixExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        /// <summary>The dot separating the expression and the identifier.</summary>
        public SyntaxToken DotSeparator => new SyntaxToken(this, ((Syntax.InternalSyntax.MemberAccessExpressionSyntax)this.Green).dotSeparator, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The identifier representing the member name.</summary>
        public SyntaxToken MemberName => new SyntaxToken(this, ((Syntax.InternalSyntax.MemberAccessExpressionSyntax)this.Green).memberName, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.expression)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.expression : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitMemberAccessExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitMemberAccessExpression(this);

        public MemberAccessExpressionSyntax Update(PrefixExpressionSyntax expression, SyntaxToken dotSeparator, SyntaxToken memberName)
        {
            if (expression != this.Expression || dotSeparator != this.DotSeparator || memberName != this.MemberName)
            {
                var newNode = SyntaxFactory.MemberAccessExpression(expression, dotSeparator, memberName);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public MemberAccessExpressionSyntax WithExpression(PrefixExpressionSyntax expression) => Update(expression, this.DotSeparator, this.MemberName);
        public MemberAccessExpressionSyntax WithDotSeparator(SyntaxToken dotSeparator) => Update(this.Expression, dotSeparator, this.MemberName);
        public MemberAccessExpressionSyntax WithMemberName(SyntaxToken memberName) => Update(this.Expression, this.DotSeparator, memberName);
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ElementAccessExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ElementAccessExpressionSyntax : VariableExpressionSyntax
    {
        private PrefixExpressionSyntax? expression;
        private ExpressionSyntax? keyExpression;

        internal ElementAccessExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The expression that contains the member being accessed.</summary>
        public PrefixExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        /// <summary>The opening bracket token.</summary>
        public SyntaxToken OpenBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ElementAccessExpressionSyntax)this.Green).openBracketToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The key expression.</summary>
        public ExpressionSyntax KeyExpression => GetRed(ref this.keyExpression, 2)!;

        /// <summary>The closing bracket token.</summary>
        public SyntaxToken CloseBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ElementAccessExpressionSyntax)this.Green).closeBracketToken, GetChildPosition(3), GetChildIndex(3));

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                2 => GetRed(ref this.keyExpression, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                2 => this.keyExpression,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitElementAccessExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitElementAccessExpression(this);

        public ElementAccessExpressionSyntax Update(PrefixExpressionSyntax expression, SyntaxToken openBracketToken, ExpressionSyntax keyExpression, SyntaxToken closeBracketToken)
        {
            if (expression != this.Expression || openBracketToken != this.OpenBracketToken || keyExpression != this.KeyExpression || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.ElementAccessExpression(expression, openBracketToken, keyExpression, closeBracketToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ElementAccessExpressionSyntax WithExpression(PrefixExpressionSyntax expression) => Update(expression, this.OpenBracketToken, this.KeyExpression, this.CloseBracketToken);
        public ElementAccessExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken) => Update(this.Expression, openBracketToken, this.KeyExpression, this.CloseBracketToken);
        public ElementAccessExpressionSyntax WithKeyExpression(ExpressionSyntax keyExpression) => Update(this.Expression, this.OpenBracketToken, keyExpression, this.CloseBracketToken);
        public ElementAccessExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) => Update(this.Expression, this.OpenBracketToken, this.KeyExpression, closeBracketToken);
    }

    /// <summary>Represents an unary expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.BitwiseNotExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LengthExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LogicalNotExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.UnaryMinusExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class UnaryExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? operand;

        internal UnaryExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The operator token.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.UnaryExpressionSyntax)this.Green).operatorToken, Position, 0);

        /// <summary>The operand expression.</summary>
        public ExpressionSyntax Operand => GetRed(ref this.operand, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.operand, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.operand : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitUnaryExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitUnaryExpression(this);

        public UnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            if (operatorToken != this.OperatorToken || operand != this.Operand)
            {
                var newNode = SyntaxFactory.UnaryExpression(this.Kind(), operatorToken, operand);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public UnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) => Update(operatorToken, this.Operand);
        public UnaryExpressionSyntax WithOperand(ExpressionSyntax operand) => Update(this.OperatorToken, operand);
    }

    /// <summary>Represents a binary expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AddExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseAndExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.BitwiseOrExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ConcatExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.DivideExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.EqualsExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ExclusiveOrExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ExponentiateExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.GreaterThanExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.GreaterThanOrEqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LeftShiftExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LessThanExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LessThanOrEqualExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LogicalAndExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.LogicalOrExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.ModuloExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.MultiplyExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.NotEqualsExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.RightShiftExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.SubtractExpression"/></description></item>
    /// <item><description><see cref="SyntaxKind.FloorDivideExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BinaryExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? left;
        private ExpressionSyntax? right;

        internal BinaryExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The expression on the left side of the operator.</summary>
        public ExpressionSyntax Left => GetRedAtZero(ref this.left)!;

        /// <summary>The operator token.</summary>
        public SyntaxToken OperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.BinaryExpressionSyntax)this.Green).operatorToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The expression on the right side of the operator.</summary>
        public ExpressionSyntax Right => GetRed(ref this.right, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.left)!,
                2 => GetRed(ref this.right, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.left,
                2 => this.right,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitBinaryExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBinaryExpression(this);

        public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.BinaryExpression(this.Kind(), left, operatorToken, right);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BinaryExpressionSyntax WithLeft(ExpressionSyntax left) => Update(left, this.OperatorToken, this.Right);
        public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) => Update(this.Left, operatorToken, this.Right);
        public BinaryExpressionSyntax WithRight(ExpressionSyntax right) => Update(this.Left, this.OperatorToken, right);
    }

    /// <summary>
    /// Represents an elseif clause in an if expression.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ElseIfExpressionClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ElseIfExpressionClauseSyntax : LuaSyntaxNode
    {
        private ExpressionSyntax? condition;
        private ExpressionSyntax? value;

        internal ElseIfExpressionClauseSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'elseif' keyword.</summary>
        public SyntaxToken ElseIfKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseIfExpressionClauseSyntax)this.Green).elseIfKeyword, Position, 0);

        /// <summary>The elseif's condition.</summary>
        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        /// <summary>The 'then' keyword.</summary>
        public SyntaxToken ThenKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseIfExpressionClauseSyntax)this.Green).thenKeyword, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The value to be returned if the condition is true.</summary>
        public ExpressionSyntax Value => GetRed(ref this.value, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.value, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.value,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitElseIfExpressionClause(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitElseIfExpressionClause(this);

        public ElseIfExpressionClauseSyntax Update(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax value)
        {
            if (elseIfKeyword != this.ElseIfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || value != this.Value)
            {
                var newNode = SyntaxFactory.ElseIfExpressionClause(elseIfKeyword, condition, thenKeyword, value);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ElseIfExpressionClauseSyntax WithElseIfKeyword(SyntaxToken elseIfKeyword) => Update(elseIfKeyword, this.Condition, this.ThenKeyword, this.Value);
        public ElseIfExpressionClauseSyntax WithCondition(ExpressionSyntax condition) => Update(this.ElseIfKeyword, condition, this.ThenKeyword, this.Value);
        public ElseIfExpressionClauseSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.ElseIfKeyword, this.Condition, thenKeyword, this.Value);
        public ElseIfExpressionClauseSyntax WithValue(ExpressionSyntax value) => Update(this.ElseIfKeyword, this.Condition, this.ThenKeyword, value);
    }

    /// <summary>
    /// Represents Luau's if expression.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IfExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IfExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? condition;
        private ExpressionSyntax? trueValue;
        private SyntaxNode? elseIfClauses;
        private ExpressionSyntax? falseValue;

        internal IfExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'if' keyword.</summary>
        public SyntaxToken IfKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfExpressionSyntax)this.Green).ifKeyword, Position, 0);

        /// <summary>The if's condition.</summary>
        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        /// <summary>The 'then' keyword.</summary>
        public SyntaxToken ThenKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfExpressionSyntax)this.Green).thenKeyword, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The value that will be returned if condition is true.</summary>
        public ExpressionSyntax TrueValue => GetRed(ref this.trueValue, 3)!;

        /// <summary>The elseif clauses.</summary>
        public SyntaxList<ElseIfExpressionClauseSyntax> ElseIfClauses => new SyntaxList<ElseIfExpressionClauseSyntax>(GetRed(ref this.elseIfClauses, 4));

        /// <summary>The 'else' keyword.</summary>
        public SyntaxToken ElseKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfExpressionSyntax)this.Green).elseKeyword, GetChildPosition(5), GetChildIndex(5));

        /// <summary>The value that will be returned if none of the previous conditions are true.</summary>
        public ExpressionSyntax FalseValue => GetRed(ref this.falseValue, 6)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.trueValue, 3)!,
                4 => GetRed(ref this.elseIfClauses, 4)!,
                6 => GetRed(ref this.falseValue, 6)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.trueValue,
                4 => this.elseIfClauses,
                6 => this.falseValue,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIfExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIfExpression(this);

        public IfExpressionSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax trueValue, SyntaxList<ElseIfExpressionClauseSyntax> elseIfClauses, SyntaxToken elseKeyword, ExpressionSyntax falseValue)
        {
            if (ifKeyword != this.IfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || trueValue != this.TrueValue || elseIfClauses != this.ElseIfClauses || elseKeyword != this.ElseKeyword || falseValue != this.FalseValue)
            {
                var newNode = SyntaxFactory.IfExpression(ifKeyword, condition, thenKeyword, trueValue, elseIfClauses, elseKeyword, falseValue);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public IfExpressionSyntax WithIfKeyword(SyntaxToken ifKeyword) => Update(ifKeyword, this.Condition, this.ThenKeyword, this.TrueValue, this.ElseIfClauses, this.ElseKeyword, this.FalseValue);
        public IfExpressionSyntax WithCondition(ExpressionSyntax condition) => Update(this.IfKeyword, condition, this.ThenKeyword, this.TrueValue, this.ElseIfClauses, this.ElseKeyword, this.FalseValue);
        public IfExpressionSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.IfKeyword, this.Condition, thenKeyword, this.TrueValue, this.ElseIfClauses, this.ElseKeyword, this.FalseValue);
        public IfExpressionSyntax WithTrueValue(ExpressionSyntax trueValue) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, trueValue, this.ElseIfClauses, this.ElseKeyword, this.FalseValue);
        public IfExpressionSyntax WithElseIfClauses(SyntaxList<ElseIfExpressionClauseSyntax> elseIfClauses) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.TrueValue, elseIfClauses, this.ElseKeyword, this.FalseValue);
        public IfExpressionSyntax WithElseKeyword(SyntaxToken elseKeyword) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.TrueValue, this.ElseIfClauses, elseKeyword, this.FalseValue);
        public IfExpressionSyntax WithFalseValue(ExpressionSyntax falseValue) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.TrueValue, this.ElseIfClauses, this.ElseKeyword, falseValue);

        public IfExpressionSyntax AddElseIfClauses(params ElseIfExpressionClauseSyntax[] items) => WithElseIfClauses(this.ElseIfClauses.AddRange(items));
    }

    /// <summary>
    /// The base node for prefix expressions (expressions that can be called as functions,
    /// have methods called on them and/or have members/elements accessed on them).
    /// </summary>
    public abstract partial class PrefixExpressionSyntax : ExpressionSyntax
    {
        internal PrefixExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ParenthesizedExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParenthesizedExpressionSyntax : PrefixExpressionSyntax
    {
        private ExpressionSyntax? expression;

        internal ParenthesizedExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The opening parenthesis token.</summary>
        public SyntaxToken OpenParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).openParenthesisToken, Position, 0);

        /// <summary>The inner expression.</summary>
        public ExpressionSyntax Expression => GetRed(ref this.expression, 1)!;

        /// <summary>The closing parenthesis token.</summary>
        public SyntaxToken CloseParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).closeParenthesisToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expression, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expression : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitParenthesizedExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParenthesizedExpression(this);

        public ParenthesizedExpressionSyntax Update(SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken != this.OpenParenthesisToken || expression != this.Expression || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.ParenthesizedExpression(openParenthesisToken, expression, closeParenthesisToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParenthesizedExpressionSyntax WithOpenParenthesisToken(SyntaxToken openParenthesisToken) => Update(openParenthesisToken, this.Expression, this.CloseParenthesisToken);
        public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(this.OpenParenthesisToken, expression, this.CloseParenthesisToken);
        public ParenthesizedExpressionSyntax WithCloseParenthesisToken(SyntaxToken closeParenthesisToken) => Update(this.OpenParenthesisToken, this.Expression, closeParenthesisToken);
    }

    /// <summary>Represents a function call expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.FunctionCallExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class FunctionCallExpressionSyntax : PrefixExpressionSyntax
    {
        private PrefixExpressionSyntax? expression;
        private FunctionArgumentSyntax? argument;

        internal FunctionCallExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The expression returning the function to be called.</summary>
        public PrefixExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        /// <summary>The function's arguments.</summary>
        public FunctionArgumentSyntax Argument => GetRed(ref this.argument, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                1 => GetRed(ref this.argument, 1)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.argument,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitFunctionCallExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitFunctionCallExpression(this);

        public FunctionCallExpressionSyntax Update(PrefixExpressionSyntax expression, FunctionArgumentSyntax argument)
        {
            if (expression != this.Expression || argument != this.Argument)
            {
                var newNode = SyntaxFactory.FunctionCallExpression(expression, argument);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public FunctionCallExpressionSyntax WithExpression(PrefixExpressionSyntax expression) => Update(expression, this.Argument);
        public FunctionCallExpressionSyntax WithArgument(FunctionArgumentSyntax argument) => Update(this.Expression, argument);
    }

    /// <summary>Represents a method call (obj:method args...) expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.MethodCallExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class MethodCallExpressionSyntax : PrefixExpressionSyntax
    {
        private PrefixExpressionSyntax? expression;
        private FunctionArgumentSyntax? argument;

        internal MethodCallExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The expression that contains the method being called.</summary>
        public PrefixExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        /// <summary>The colon token.</summary>
        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.MethodCallExpressionSyntax)this.Green).colonToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The identifier containing the method name.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.MethodCallExpressionSyntax)this.Green).identifier, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The method call's arguments.</summary>
        public FunctionArgumentSyntax Argument => GetRed(ref this.argument, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                3 => GetRed(ref this.argument, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                3 => this.argument,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitMethodCallExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitMethodCallExpression(this);

        public MethodCallExpressionSyntax Update(PrefixExpressionSyntax expression, SyntaxToken colonToken, SyntaxToken identifier, FunctionArgumentSyntax argument)
        {
            if (expression != this.Expression || colonToken != this.ColonToken || identifier != this.Identifier || argument != this.Argument)
            {
                var newNode = SyntaxFactory.MethodCallExpression(expression, colonToken, identifier, argument);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public MethodCallExpressionSyntax WithExpression(PrefixExpressionSyntax expression) => Update(expression, this.ColonToken, this.Identifier, this.Argument);
        public MethodCallExpressionSyntax WithColonToken(SyntaxToken colonToken) => Update(this.Expression, colonToken, this.Identifier, this.Argument);
        public MethodCallExpressionSyntax WithIdentifier(SyntaxToken identifier) => Update(this.Expression, this.ColonToken, identifier, this.Argument);
        public MethodCallExpressionSyntax WithArgument(FunctionArgumentSyntax argument) => Update(this.Expression, this.ColonToken, this.Identifier, argument);
    }

    /// <summary>The base class for statements.</summary>
    public abstract partial class StatementSyntax : LuaSyntaxNode
    {
        internal StatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public abstract SyntaxToken SemicolonToken { get; }
        public StatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => WithSemicolonTokenCore(semicolonToken);
        internal abstract StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken);
    }

    /// <summary>Represents a variable attribute syntax.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.VariableAttribute"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class VariableAttributeSyntax : LuaSyntaxNode
    {

        internal VariableAttributeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// The leading <c>&lt;</c> token.
        /// </summary>
        public SyntaxToken LessThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.VariableAttributeSyntax)this.Green).lessThanToken, Position, 0);

        /// <summary>The attribute name identifier token.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.VariableAttributeSyntax)this.Green).identifier, GetChildPosition(1), GetChildIndex(1));

        /// <summary>
        /// The trailing <c>&gt;</c> token.
        /// </summary>
        public SyntaxToken GreaterThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.VariableAttributeSyntax)this.Green).greaterThanToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitVariableAttribute(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitVariableAttribute(this);

        public VariableAttributeSyntax Update(SyntaxToken lessThanToken, SyntaxToken identifier, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || identifier != this.Identifier || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.VariableAttribute(lessThanToken, identifier, greaterThanToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public VariableAttributeSyntax WithLessThanToken(SyntaxToken lessThanToken) => Update(lessThanToken, this.Identifier, this.GreaterThanToken);
        public VariableAttributeSyntax WithIdentifier(SyntaxToken identifier) => Update(this.LessThanToken, identifier, this.GreaterThanToken);
        public VariableAttributeSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) => Update(this.LessThanToken, this.Identifier, greaterThanToken);
    }

    /// <summary>
    /// Represents a variable name in a
    /// <see cref="LocalVariableDeclarationStatementSyntax" />
    /// node.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.LocalDeclarationName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LocalDeclarationNameSyntax : LuaSyntaxNode
    {
        private IdentifierNameSyntax? identifierName;
        private VariableAttributeSyntax? attribute;
        private TypeBindingSyntax? typeBinding;

        internal LocalDeclarationNameSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// The
        /// <see cref="IdentifierNameSyntax" />
        /// containing the name.
        /// </summary>
        public IdentifierNameSyntax IdentifierName => GetRedAtZero(ref this.identifierName)!;

        /// <summary>
        /// The
        /// <see cref="VariableAttributeSyntax" />
        /// containing the (optional) variable attribute.
        /// </summary>
        public VariableAttributeSyntax? Attribute => GetRed(ref this.attribute, 1);

        /// <summary>
        /// The
        /// <see cref="TypeBindingSyntax" />
        /// containing the (optional) type.
        /// </summary>
        public TypeBindingSyntax? TypeBinding => GetRed(ref this.typeBinding, 2);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.identifierName)!,
                1 => GetRed(ref this.attribute, 1),
                2 => GetRed(ref this.typeBinding, 2),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.identifierName,
                1 => this.attribute,
                2 => this.typeBinding,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLocalDeclarationName(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLocalDeclarationName(this);

        public LocalDeclarationNameSyntax Update(IdentifierNameSyntax identifierName, VariableAttributeSyntax? attribute, TypeBindingSyntax? typeBinding)
        {
            if (identifierName != this.IdentifierName || attribute != this.Attribute || typeBinding != this.TypeBinding)
            {
                var newNode = SyntaxFactory.LocalDeclarationName(identifierName, attribute, typeBinding);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LocalDeclarationNameSyntax WithIdentifierName(IdentifierNameSyntax identifierName) => Update(identifierName, this.Attribute, this.TypeBinding);
        public LocalDeclarationNameSyntax WithAttribute(VariableAttributeSyntax? attribute) => Update(this.IdentifierName, attribute, this.TypeBinding);
        public LocalDeclarationNameSyntax WithTypeBinding(TypeBindingSyntax? typeBinding) => Update(this.IdentifierName, this.Attribute, typeBinding);
    }

    /// <summary>Represents the values being assigned to the names in an assignment or variable declaration.
    /// </summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.EqualsValuesClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class EqualsValuesClauseSyntax : LuaSyntaxNode
    {
        private SyntaxNode? values;

        internal EqualsValuesClauseSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The equals token.</summary>
        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.EqualsValuesClauseSyntax)this.Green).equalsToken, Position, 0);

        /// <summary>The list of values being assigned.</summary>
        public SeparatedSyntaxList<ExpressionSyntax> Values
        {
            get
            {
                var red = GetRed(ref this.values, 1);
                return red != null ? new SeparatedSyntaxList<ExpressionSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.values, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.values : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitEqualsValuesClause(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitEqualsValuesClause(this);

        public EqualsValuesClauseSyntax Update(SyntaxToken equalsToken, SeparatedSyntaxList<ExpressionSyntax> values)
        {
            if (equalsToken != this.EqualsToken || values != this.Values)
            {
                var newNode = SyntaxFactory.EqualsValuesClause(equalsToken, values);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public EqualsValuesClauseSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(equalsToken, this.Values);
        public EqualsValuesClauseSyntax WithValues(SeparatedSyntaxList<ExpressionSyntax> values) => Update(this.EqualsToken, values);

        public EqualsValuesClauseSyntax AddValues(params ExpressionSyntax[] items) => WithValues(this.Values.AddRange(items));
    }

    /// <summary>Represents an assignment statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AssignmentStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class AssignmentStatementSyntax : StatementSyntax
    {
        private SyntaxNode? variables;
        private EqualsValuesClauseSyntax? equalsValues;

        internal AssignmentStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The variables being assigned to.</summary>
        public SeparatedSyntaxList<PrefixExpressionSyntax> Variables
        {
            get
            {
                var red = GetRed(ref this.variables, 0);
                return red != null ? new SeparatedSyntaxList<PrefixExpressionSyntax>(red, 0) : default;
            }
        }

        /// <summary>The values being assigned to the names (if any).</summary>
        public EqualsValuesClauseSyntax EqualsValues => GetRed(ref this.equalsValues, 1)!;

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.AssignmentStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.variables)!,
                1 => GetRed(ref this.equalsValues, 1)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.variables,
                1 => this.equalsValues,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitAssignmentStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitAssignmentStatement(this);

        public AssignmentStatementSyntax Update(SeparatedSyntaxList<PrefixExpressionSyntax> variables, EqualsValuesClauseSyntax equalsValues, SyntaxToken semicolonToken)
        {
            if (variables != this.Variables || equalsValues != this.EqualsValues || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.AssignmentStatement(variables, equalsValues, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public AssignmentStatementSyntax WithVariables(SeparatedSyntaxList<PrefixExpressionSyntax> variables) => Update(variables, this.EqualsValues, this.SemicolonToken);
        public AssignmentStatementSyntax WithEqualsValues(EqualsValuesClauseSyntax equalsValues) => Update(this.Variables, equalsValues, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new AssignmentStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.Variables, this.EqualsValues, semicolonToken);

        public AssignmentStatementSyntax AddVariables(params PrefixExpressionSyntax[] items) => WithVariables(this.Variables.AddRange(items));
        public AssignmentStatementSyntax AddEqualsValuesValues(params ExpressionSyntax[] items) => WithEqualsValues(this.EqualsValues.WithValues(this.EqualsValues.Values.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.AddAssignmentStatement"/></description></item>
    /// <item><description><see cref="SyntaxKind.SubtractAssignmentStatement"/></description></item>
    /// <item><description><see cref="SyntaxKind.MultiplyAssignmentStatement"/></description></item>
    /// <item><description><see cref="SyntaxKind.DivideAssignmentStatement"/></description></item>
    /// <item><description><see cref="SyntaxKind.ModuloAssignmentStatement"/></description></item>
    /// <item><description><see cref="SyntaxKind.ConcatAssignmentStatement"/></description></item>
    /// <item><description><see cref="SyntaxKind.ExponentiateAssignmentStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class CompoundAssignmentStatementSyntax : StatementSyntax
    {
        private PrefixExpressionSyntax? variable;
        private ExpressionSyntax? expression;

        internal CompoundAssignmentStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The variable being assigned to.</summary>
        public PrefixExpressionSyntax Variable => GetRedAtZero(ref this.variable)!;

        /// <summary>The compound assignment operator token.</summary>
        public SyntaxToken AssignmentOperatorToken => new SyntaxToken(this, ((Syntax.InternalSyntax.CompoundAssignmentStatementSyntax)this.Green).assignmentOperatorToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The expression on the right side of the operator.</summary>
        public ExpressionSyntax Expression => GetRed(ref this.expression, 2)!;

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.CompoundAssignmentStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(3), GetChildIndex(3)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.variable)!,
                2 => GetRed(ref this.expression, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.variable,
                2 => this.expression,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitCompoundAssignmentStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitCompoundAssignmentStatement(this);

        public CompoundAssignmentStatementSyntax Update(PrefixExpressionSyntax variable, SyntaxToken assignmentOperatorToken, ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
            if (variable != this.Variable || assignmentOperatorToken != this.AssignmentOperatorToken || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.CompoundAssignmentStatement(this.Kind(), variable, assignmentOperatorToken, expression, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public CompoundAssignmentStatementSyntax WithVariable(PrefixExpressionSyntax variable) => Update(variable, this.AssignmentOperatorToken, this.Expression, this.SemicolonToken);
        public CompoundAssignmentStatementSyntax WithAssignmentOperatorToken(SyntaxToken assignmentOperatorToken) => Update(this.Variable, assignmentOperatorToken, this.Expression, this.SemicolonToken);
        public CompoundAssignmentStatementSyntax WithExpression(ExpressionSyntax expression) => Update(this.Variable, this.AssignmentOperatorToken, expression, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new CompoundAssignmentStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.Variable, this.AssignmentOperatorToken, this.Expression, semicolonToken);
    }

    /// <summary>Represents a local variable declaration statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.LocalVariableDeclarationStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LocalVariableDeclarationStatementSyntax : StatementSyntax
    {
        private SyntaxNode? names;
        private EqualsValuesClauseSyntax? equalsValues;

        internal LocalVariableDeclarationStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'local' keyword.</summary>
        public SyntaxToken LocalKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.LocalVariableDeclarationStatementSyntax)this.Green).localKeyword, Position, 0);

        /// <summary>The list of names being assigned to.</summary>
        public SeparatedSyntaxList<LocalDeclarationNameSyntax> Names
        {
            get
            {
                var red = GetRed(ref this.names, 1);
                return red != null ? new SeparatedSyntaxList<LocalDeclarationNameSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>The values being assigned to the names (if any).</summary>
        public EqualsValuesClauseSyntax? EqualsValues => GetRed(ref this.equalsValues, 2);

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.LocalVariableDeclarationStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(3), GetChildIndex(3)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.names, 1)!,
                2 => GetRed(ref this.equalsValues, 2),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.names,
                2 => this.equalsValues,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLocalVariableDeclarationStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLocalVariableDeclarationStatement(this);

        public LocalVariableDeclarationStatementSyntax Update(SyntaxToken localKeyword, SeparatedSyntaxList<LocalDeclarationNameSyntax> names, EqualsValuesClauseSyntax? equalsValues, SyntaxToken semicolonToken)
        {
            if (localKeyword != this.LocalKeyword || names != this.Names || equalsValues != this.EqualsValues || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.LocalVariableDeclarationStatement(localKeyword, names, equalsValues, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LocalVariableDeclarationStatementSyntax WithLocalKeyword(SyntaxToken localKeyword) => Update(localKeyword, this.Names, this.EqualsValues, this.SemicolonToken);
        public LocalVariableDeclarationStatementSyntax WithNames(SeparatedSyntaxList<LocalDeclarationNameSyntax> names) => Update(this.LocalKeyword, names, this.EqualsValues, this.SemicolonToken);
        public LocalVariableDeclarationStatementSyntax WithEqualsValues(EqualsValuesClauseSyntax? equalsValues) => Update(this.LocalKeyword, this.Names, equalsValues, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new LocalVariableDeclarationStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.LocalKeyword, this.Names, this.EqualsValues, semicolonToken);

        public LocalVariableDeclarationStatementSyntax AddNames(params LocalDeclarationNameSyntax[] items) => WithNames(this.Names.AddRange(items));
    }

    /// <summary>This node represents an identifier name with a type binding.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypedIdentifierName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypedIdentifierNameSyntax : LuaSyntaxNode
    {
        private IdentifierNameSyntax? identifierName;
        private TypeBindingSyntax? typeBinding;

        internal TypedIdentifierNameSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The identifier.</summary>
        public IdentifierNameSyntax IdentifierName => GetRedAtZero(ref this.identifierName)!;

        /// <summary>
        /// The type binding containing the type (if any).
        /// </summary>
        public TypeBindingSyntax? TypeBinding => GetRed(ref this.typeBinding, 1);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.identifierName)!,
                1 => GetRed(ref this.typeBinding, 1),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.identifierName,
                1 => this.typeBinding,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypedIdentifierName(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypedIdentifierName(this);

        public TypedIdentifierNameSyntax Update(IdentifierNameSyntax identifierName, TypeBindingSyntax? typeBinding)
        {
            if (identifierName != this.IdentifierName || typeBinding != this.TypeBinding)
            {
                var newNode = SyntaxFactory.TypedIdentifierName(identifierName, typeBinding);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypedIdentifierNameSyntax WithIdentifierName(IdentifierNameSyntax identifierName) => Update(identifierName, this.TypeBinding);
        public TypedIdentifierNameSyntax WithTypeBinding(TypeBindingSyntax? typeBinding) => Update(this.IdentifierName, typeBinding);
    }

    /// <summary>Represents a numeric for statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NumericForStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class NumericForStatementSyntax : StatementSyntax
    {
        private TypedIdentifierNameSyntax? identifier;
        private ExpressionSyntax? initialValue;
        private ExpressionSyntax? finalValue;
        private ExpressionSyntax? stepValue;
        private StatementListSyntax? body;

        internal NumericForStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'for' keyword.</summary>
        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.NumericForStatementSyntax)this.Green).forKeyword, Position, 0);

        /// <summary>The loop variable.</summary>
        public TypedIdentifierNameSyntax Identifier => GetRed(ref this.identifier, 1)!;

        /// <summary>The equals token.</summary>
        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.NumericForStatementSyntax)this.Green).equalsToken, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The expression defining the initial value of the loop variable.</summary>
        public ExpressionSyntax InitialValue => GetRed(ref this.initialValue, 3)!;

        /// <summary>The comma separating the initial value from the final value.</summary>
        public SyntaxToken FinalValueCommaToken => new SyntaxToken(this, ((Syntax.InternalSyntax.NumericForStatementSyntax)this.Green).finalValueCommaToken, GetChildPosition(4), GetChildIndex(4));

        /// <summary>The expression defining the final value of the loop variable.</summary>
        public ExpressionSyntax FinalValue => GetRed(ref this.finalValue, 5)!;

        /// <summary>
        /// The comma separating the final value from the step value.
        /// May be None if there is no step.
        /// </summary>
        public SyntaxToken StepValueCommaToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.NumericForStatementSyntax)this.Green).stepValueCommaToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(6), GetChildIndex(6)) : default;
            }
        }

        /// <summary>
        /// The expression defining the step value of the loop variable.
        /// May be None if there is no step.
        /// </summary>
        public ExpressionSyntax? StepValue => GetRed(ref this.stepValue, 7);

        /// <summary>The 'do' keyword.</summary>
        public SyntaxToken DoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.NumericForStatementSyntax)this.Green).doKeyword, GetChildPosition(8), GetChildIndex(8));

        /// <summary>The loop's body.</summary>
        public StatementListSyntax Body => GetRed(ref this.body, 9)!;

        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.NumericForStatementSyntax)this.Green).endKeyword, GetChildPosition(10), GetChildIndex(10));

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.NumericForStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(11), GetChildIndex(11)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.identifier, 1)!,
                3 => GetRed(ref this.initialValue, 3)!,
                5 => GetRed(ref this.finalValue, 5)!,
                7 => GetRed(ref this.stepValue, 7),
                9 => GetRed(ref this.body, 9)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.identifier,
                3 => this.initialValue,
                5 => this.finalValue,
                7 => this.stepValue,
                9 => this.body,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitNumericForStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitNumericForStatement(this);

        public NumericForStatementSyntax Update(SyntaxToken forKeyword, TypedIdentifierNameSyntax identifier, SyntaxToken equalsToken, ExpressionSyntax initialValue, SyntaxToken finalValueCommaToken, ExpressionSyntax finalValue, SyntaxToken stepValueCommaToken, ExpressionSyntax? stepValue, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (forKeyword != this.ForKeyword || identifier != this.Identifier || equalsToken != this.EqualsToken || initialValue != this.InitialValue || finalValueCommaToken != this.FinalValueCommaToken || finalValue != this.FinalValue || stepValueCommaToken != this.StepValueCommaToken || stepValue != this.StepValue || doKeyword != this.DoKeyword || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.NumericForStatement(forKeyword, identifier, equalsToken, initialValue, finalValueCommaToken, finalValue, stepValueCommaToken, stepValue, doKeyword, body, endKeyword, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public NumericForStatementSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Identifier, this.EqualsToken, this.InitialValue, this.FinalValueCommaToken, this.FinalValue, this.StepValueCommaToken, this.StepValue, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public NumericForStatementSyntax WithIdentifier(TypedIdentifierNameSyntax identifier) => Update(this.ForKeyword, identifier, this.EqualsToken, this.InitialValue, this.FinalValueCommaToken, this.FinalValue, this.StepValueCommaToken, this.StepValue, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public NumericForStatementSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.ForKeyword, this.Identifier, equalsToken, this.InitialValue, this.FinalValueCommaToken, this.FinalValue, this.StepValueCommaToken, this.StepValue, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public NumericForStatementSyntax WithInitialValue(ExpressionSyntax initialValue) => Update(this.ForKeyword, this.Identifier, this.EqualsToken, initialValue, this.FinalValueCommaToken, this.FinalValue, this.StepValueCommaToken, this.StepValue, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public NumericForStatementSyntax WithFinalValueCommaToken(SyntaxToken finalValueCommaToken) => Update(this.ForKeyword, this.Identifier, this.EqualsToken, this.InitialValue, finalValueCommaToken, this.FinalValue, this.StepValueCommaToken, this.StepValue, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public NumericForStatementSyntax WithFinalValue(ExpressionSyntax finalValue) => Update(this.ForKeyword, this.Identifier, this.EqualsToken, this.InitialValue, this.FinalValueCommaToken, finalValue, this.StepValueCommaToken, this.StepValue, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public NumericForStatementSyntax WithStepValueCommaToken(SyntaxToken stepValueCommaToken) => Update(this.ForKeyword, this.Identifier, this.EqualsToken, this.InitialValue, this.FinalValueCommaToken, this.FinalValue, stepValueCommaToken, this.StepValue, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public NumericForStatementSyntax WithStepValue(ExpressionSyntax? stepValue) => Update(this.ForKeyword, this.Identifier, this.EqualsToken, this.InitialValue, this.FinalValueCommaToken, this.FinalValue, this.StepValueCommaToken, stepValue, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public NumericForStatementSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(this.ForKeyword, this.Identifier, this.EqualsToken, this.InitialValue, this.FinalValueCommaToken, this.FinalValue, this.StepValueCommaToken, this.StepValue, doKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public NumericForStatementSyntax WithBody(StatementListSyntax body) => Update(this.ForKeyword, this.Identifier, this.EqualsToken, this.InitialValue, this.FinalValueCommaToken, this.FinalValue, this.StepValueCommaToken, this.StepValue, this.DoKeyword, body, this.EndKeyword, this.SemicolonToken);
        public NumericForStatementSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.ForKeyword, this.Identifier, this.EqualsToken, this.InitialValue, this.FinalValueCommaToken, this.FinalValue, this.StepValueCommaToken, this.StepValue, this.DoKeyword, this.Body, endKeyword, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new NumericForStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.ForKeyword, this.Identifier, this.EqualsToken, this.InitialValue, this.FinalValueCommaToken, this.FinalValue, this.StepValueCommaToken, this.StepValue, this.DoKeyword, this.Body, this.EndKeyword, semicolonToken);

        public NumericForStatementSyntax AddBodyStatements(params StatementSyntax[] items) => WithBody(this.Body.WithStatements(this.Body.Statements.AddRange(items)));
    }

    /// <summary>Represents a generic for loop statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.GenericForStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class GenericForStatementSyntax : StatementSyntax
    {
        private SyntaxNode? identifiers;
        private SyntaxNode? expressions;
        private StatementListSyntax? body;

        internal GenericForStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'for' keyword.</summary>
        public SyntaxToken ForKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.GenericForStatementSyntax)this.Green).forKeyword, Position, 0);

        /// <summary>The list of loop variables.</summary>
        public SeparatedSyntaxList<TypedIdentifierNameSyntax> Identifiers
        {
            get
            {
                var red = GetRed(ref this.identifiers, 1);
                return red != null ? new SeparatedSyntaxList<TypedIdentifierNameSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>The 'in' keyword.</summary>
        public SyntaxToken InKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.GenericForStatementSyntax)this.Green).inKeyword, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The list of expressions.</summary>
        public SeparatedSyntaxList<ExpressionSyntax> Expressions
        {
            get
            {
                var red = GetRed(ref this.expressions, 3);
                return red != null ? new SeparatedSyntaxList<ExpressionSyntax>(red, GetChildIndex(3)) : default;
            }
        }

        /// <summary>The 'do' keyword.</summary>
        public SyntaxToken DoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.GenericForStatementSyntax)this.Green).doKeyword, GetChildPosition(4), GetChildIndex(4));

        /// <summary>The loop's body.</summary>
        public StatementListSyntax Body => GetRed(ref this.body, 5)!;

        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.GenericForStatementSyntax)this.Green).endKeyword, GetChildPosition(6), GetChildIndex(6));

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.GenericForStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(7), GetChildIndex(7)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.identifiers, 1)!,
                3 => GetRed(ref this.expressions, 3)!,
                5 => GetRed(ref this.body, 5)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.identifiers,
                3 => this.expressions,
                5 => this.body,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitGenericForStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitGenericForStatement(this);

        public GenericForStatementSyntax Update(SyntaxToken forKeyword, SeparatedSyntaxList<TypedIdentifierNameSyntax> identifiers, SyntaxToken inKeyword, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (forKeyword != this.ForKeyword || identifiers != this.Identifiers || inKeyword != this.InKeyword || expressions != this.Expressions || doKeyword != this.DoKeyword || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.GenericForStatement(forKeyword, identifiers, inKeyword, expressions, doKeyword, body, endKeyword, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public GenericForStatementSyntax WithForKeyword(SyntaxToken forKeyword) => Update(forKeyword, this.Identifiers, this.InKeyword, this.Expressions, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public GenericForStatementSyntax WithIdentifiers(SeparatedSyntaxList<TypedIdentifierNameSyntax> identifiers) => Update(this.ForKeyword, identifiers, this.InKeyword, this.Expressions, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public GenericForStatementSyntax WithInKeyword(SyntaxToken inKeyword) => Update(this.ForKeyword, this.Identifiers, inKeyword, this.Expressions, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public GenericForStatementSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions) => Update(this.ForKeyword, this.Identifiers, this.InKeyword, expressions, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public GenericForStatementSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(this.ForKeyword, this.Identifiers, this.InKeyword, this.Expressions, doKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public GenericForStatementSyntax WithBody(StatementListSyntax body) => Update(this.ForKeyword, this.Identifiers, this.InKeyword, this.Expressions, this.DoKeyword, body, this.EndKeyword, this.SemicolonToken);
        public GenericForStatementSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.ForKeyword, this.Identifiers, this.InKeyword, this.Expressions, this.DoKeyword, this.Body, endKeyword, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new GenericForStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.ForKeyword, this.Identifiers, this.InKeyword, this.Expressions, this.DoKeyword, this.Body, this.EndKeyword, semicolonToken);

        public GenericForStatementSyntax AddIdentifiers(params TypedIdentifierNameSyntax[] items) => WithIdentifiers(this.Identifiers.AddRange(items));
        public GenericForStatementSyntax AddExpressions(params ExpressionSyntax[] items) => WithExpressions(this.Expressions.AddRange(items));
        public GenericForStatementSyntax AddBodyStatements(params StatementSyntax[] items) => WithBody(this.Body.WithStatements(this.Body.Statements.AddRange(items)));
    }

    /// <summary>Represents a while statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.WhileStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class WhileStatementSyntax : StatementSyntax
    {
        private ExpressionSyntax? condition;
        private StatementListSyntax? body;

        internal WhileStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'while' keyword.</summary>
        public SyntaxToken WhileKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileStatementSyntax)this.Green).whileKeyword, Position, 0);

        /// <summary>The while's condition.</summary>
        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        /// <summary>The 'do' keyword.</summary>
        public SyntaxToken DoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileStatementSyntax)this.Green).doKeyword, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The while's body.</summary>
        public StatementListSyntax Body => GetRed(ref this.body, 3)!;

        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.WhileStatementSyntax)this.Green).endKeyword, GetChildPosition(4), GetChildIndex(4));

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.WhileStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(5), GetChildIndex(5)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.body, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.body,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitWhileStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitWhileStatement(this);

        public WhileStatementSyntax Update(SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (whileKeyword != this.WhileKeyword || condition != this.Condition || doKeyword != this.DoKeyword || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.WhileStatement(whileKeyword, condition, doKeyword, body, endKeyword, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword) => Update(whileKeyword, this.Condition, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public WhileStatementSyntax WithCondition(ExpressionSyntax condition) => Update(this.WhileKeyword, condition, this.DoKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public WhileStatementSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(this.WhileKeyword, this.Condition, doKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public WhileStatementSyntax WithBody(StatementListSyntax body) => Update(this.WhileKeyword, this.Condition, this.DoKeyword, body, this.EndKeyword, this.SemicolonToken);
        public WhileStatementSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.WhileKeyword, this.Condition, this.DoKeyword, this.Body, endKeyword, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new WhileStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.WhileKeyword, this.Condition, this.DoKeyword, this.Body, this.EndKeyword, semicolonToken);

        public WhileStatementSyntax AddBodyStatements(params StatementSyntax[] items) => WithBody(this.Body.WithStatements(this.Body.Statements.AddRange(items)));
    }

    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.RepeatUntilStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class RepeatUntilStatementSyntax : StatementSyntax
    {
        private StatementListSyntax? body;
        private ExpressionSyntax? condition;

        internal RepeatUntilStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'repeat' until keyword.</summary>
        public SyntaxToken RepeatKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.RepeatUntilStatementSyntax)this.Green).repeatKeyword, Position, 0);

        /// <summary>The repeat until's body.</summary>
        public StatementListSyntax Body => GetRed(ref this.body, 1)!;

        /// <summary>The 'until' keyword.</summary>
        public SyntaxToken UntilKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.RepeatUntilStatementSyntax)this.Green).untilKeyword, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The repeat until's condition.</summary>
        public ExpressionSyntax Condition => GetRed(ref this.condition, 3)!;

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.RepeatUntilStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(4), GetChildIndex(4)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.body, 1)!,
                3 => GetRed(ref this.condition, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.body,
                3 => this.condition,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitRepeatUntilStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitRepeatUntilStatement(this);

        public RepeatUntilStatementSyntax Update(SyntaxToken repeatKeyword, StatementListSyntax body, SyntaxToken untilKeyword, ExpressionSyntax condition, SyntaxToken semicolonToken)
        {
            if (repeatKeyword != this.RepeatKeyword || body != this.Body || untilKeyword != this.UntilKeyword || condition != this.Condition || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.RepeatUntilStatement(repeatKeyword, body, untilKeyword, condition, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public RepeatUntilStatementSyntax WithRepeatKeyword(SyntaxToken repeatKeyword) => Update(repeatKeyword, this.Body, this.UntilKeyword, this.Condition, this.SemicolonToken);
        public RepeatUntilStatementSyntax WithBody(StatementListSyntax body) => Update(this.RepeatKeyword, body, this.UntilKeyword, this.Condition, this.SemicolonToken);
        public RepeatUntilStatementSyntax WithUntilKeyword(SyntaxToken untilKeyword) => Update(this.RepeatKeyword, this.Body, untilKeyword, this.Condition, this.SemicolonToken);
        public RepeatUntilStatementSyntax WithCondition(ExpressionSyntax condition) => Update(this.RepeatKeyword, this.Body, this.UntilKeyword, condition, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new RepeatUntilStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.RepeatKeyword, this.Body, this.UntilKeyword, this.Condition, semicolonToken);

        public RepeatUntilStatementSyntax AddBodyStatements(params StatementSyntax[] items) => WithBody(this.Body.WithStatements(this.Body.Statements.AddRange(items)));
    }

    /// <summary>Represents an if statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IfStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IfStatementSyntax : StatementSyntax
    {
        private ExpressionSyntax? condition;
        private StatementListSyntax? body;
        private SyntaxNode? elseIfClauses;
        private ElseClauseSyntax? elseClause;

        internal IfStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'if' keyword.</summary>
        public SyntaxToken IfKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfStatementSyntax)this.Green).ifKeyword, Position, 0);

        /// <summary>The if's condition.</summary>
        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        /// <summary>The 'then' keyword.</summary>
        public SyntaxToken ThenKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfStatementSyntax)this.Green).thenKeyword, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The if's body.</summary>
        public StatementListSyntax Body => GetRed(ref this.body, 3)!;

        /// <summary>The elseif clauses.</summary>
        public SyntaxList<ElseIfClauseSyntax> ElseIfClauses => new SyntaxList<ElseIfClauseSyntax>(GetRed(ref this.elseIfClauses, 4));

        /// <summary>The else clause.</summary>
        public ElseClauseSyntax? ElseClause => GetRed(ref this.elseClause, 5);

        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.IfStatementSyntax)this.Green).endKeyword, GetChildPosition(6), GetChildIndex(6));

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.IfStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(7), GetChildIndex(7)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.body, 3)!,
                4 => GetRed(ref this.elseIfClauses, 4)!,
                5 => GetRed(ref this.elseClause, 5),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.body,
                4 => this.elseIfClauses,
                5 => this.elseClause,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIfStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIfStatement(this);

        public IfStatementSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body, SyntaxList<ElseIfClauseSyntax> elseIfClauses, ElseClauseSyntax? elseClause, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (ifKeyword != this.IfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || body != this.Body || elseIfClauses != this.ElseIfClauses || elseClause != this.ElseClause || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.IfStatement(ifKeyword, condition, thenKeyword, body, elseIfClauses, elseClause, endKeyword, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public IfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword) => Update(ifKeyword, this.Condition, this.ThenKeyword, this.Body, this.ElseIfClauses, this.ElseClause, this.EndKeyword, this.SemicolonToken);
        public IfStatementSyntax WithCondition(ExpressionSyntax condition) => Update(this.IfKeyword, condition, this.ThenKeyword, this.Body, this.ElseIfClauses, this.ElseClause, this.EndKeyword, this.SemicolonToken);
        public IfStatementSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.IfKeyword, this.Condition, thenKeyword, this.Body, this.ElseIfClauses, this.ElseClause, this.EndKeyword, this.SemicolonToken);
        public IfStatementSyntax WithBody(StatementListSyntax body) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, body, this.ElseIfClauses, this.ElseClause, this.EndKeyword, this.SemicolonToken);
        public IfStatementSyntax WithElseIfClauses(SyntaxList<ElseIfClauseSyntax> elseIfClauses) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.Body, elseIfClauses, this.ElseClause, this.EndKeyword, this.SemicolonToken);
        public IfStatementSyntax WithElseClause(ElseClauseSyntax? elseClause) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.Body, this.ElseIfClauses, elseClause, this.EndKeyword, this.SemicolonToken);
        public IfStatementSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.Body, this.ElseIfClauses, this.ElseClause, endKeyword, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new IfStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.Body, this.ElseIfClauses, this.ElseClause, this.EndKeyword, semicolonToken);

        public IfStatementSyntax AddBodyStatements(params StatementSyntax[] items) => WithBody(this.Body.WithStatements(this.Body.Statements.AddRange(items)));
        public IfStatementSyntax AddElseIfClauses(params ElseIfClauseSyntax[] items) => WithElseIfClauses(this.ElseIfClauses.AddRange(items));
    }

    /// <summary>Represents an elseif clause.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ElseIfClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ElseIfClauseSyntax : LuaSyntaxNode
    {
        private ExpressionSyntax? condition;
        private StatementListSyntax? body;

        internal ElseIfClauseSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'elseif' keyword.</summary>
        public SyntaxToken ElseIfKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseIfClauseSyntax)this.Green).elseIfKeyword, Position, 0);

        /// <summary>The condition.</summary>
        public ExpressionSyntax Condition => GetRed(ref this.condition, 1)!;

        /// <summary>The 'then' keyword.</summary>
        public SyntaxToken ThenKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseIfClauseSyntax)this.Green).thenKeyword, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The elseif body.</summary>
        public StatementListSyntax Body => GetRed(ref this.body, 3)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.condition, 1)!,
                3 => GetRed(ref this.body, 3)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.condition,
                3 => this.body,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitElseIfClause(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitElseIfClause(this);

        public ElseIfClauseSyntax Update(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, StatementListSyntax body)
        {
            if (elseIfKeyword != this.ElseIfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || body != this.Body)
            {
                var newNode = SyntaxFactory.ElseIfClause(elseIfKeyword, condition, thenKeyword, body);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ElseIfClauseSyntax WithElseIfKeyword(SyntaxToken elseIfKeyword) => Update(elseIfKeyword, this.Condition, this.ThenKeyword, this.Body);
        public ElseIfClauseSyntax WithCondition(ExpressionSyntax condition) => Update(this.ElseIfKeyword, condition, this.ThenKeyword, this.Body);
        public ElseIfClauseSyntax WithThenKeyword(SyntaxToken thenKeyword) => Update(this.ElseIfKeyword, this.Condition, thenKeyword, this.Body);
        public ElseIfClauseSyntax WithBody(StatementListSyntax body) => Update(this.ElseIfKeyword, this.Condition, this.ThenKeyword, body);

        public ElseIfClauseSyntax AddBodyStatements(params StatementSyntax[] items) => WithBody(this.Body.WithStatements(this.Body.Statements.AddRange(items)));
    }

    /// <summary>Represents an else clause.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ElseClause"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ElseClauseSyntax : LuaSyntaxNode
    {
        private StatementListSyntax? elseBody;

        internal ElseClauseSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'else' keyword.</summary>
        public SyntaxToken ElseKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ElseClauseSyntax)this.Green).elseKeyword, Position, 0);

        /// <summary>The else's body.</summary>
        public StatementListSyntax ElseBody => GetRed(ref this.elseBody, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.elseBody, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.elseBody : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitElseClause(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitElseClause(this);

        public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementListSyntax elseBody)
        {
            if (elseKeyword != this.ElseKeyword || elseBody != this.ElseBody)
            {
                var newNode = SyntaxFactory.ElseClause(elseKeyword, elseBody);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword) => Update(elseKeyword, this.ElseBody);
        public ElseClauseSyntax WithElseBody(StatementListSyntax elseBody) => Update(this.ElseKeyword, elseBody);

        public ElseClauseSyntax AddElseBodyStatements(params StatementSyntax[] items) => WithElseBody(this.ElseBody.WithStatements(this.ElseBody.Statements.AddRange(items)));
    }

    /// <summary>Represents a goto statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.GotoStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class GotoStatementSyntax : StatementSyntax
    {

        internal GotoStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'goto' keyword.</summary>
        public SyntaxToken GotoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.GotoStatementSyntax)this.Green).gotoKeyword, Position, 0);

        /// <summary>The name of the label being jumped to.</summary>
        public SyntaxToken LabelName => new SyntaxToken(this, ((Syntax.InternalSyntax.GotoStatementSyntax)this.Green).labelName, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.GotoStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitGotoStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitGotoStatement(this);

        public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken labelName, SyntaxToken semicolonToken)
        {
            if (gotoKeyword != this.GotoKeyword || labelName != this.LabelName || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.GotoStatement(gotoKeyword, labelName, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public GotoStatementSyntax WithGotoKeyword(SyntaxToken gotoKeyword) => Update(gotoKeyword, this.LabelName, this.SemicolonToken);
        public GotoStatementSyntax WithLabelName(SyntaxToken labelName) => Update(this.GotoKeyword, labelName, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new GotoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.GotoKeyword, this.LabelName, semicolonToken);
    }

    /// <summary>Represents a break statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.BreakStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BreakStatementSyntax : StatementSyntax
    {

        internal BreakStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'break' keyword.</summary>
        public SyntaxToken BreakKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.BreakStatementSyntax)this.Green).breakKeyword, Position, 0);

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.BreakStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitBreakStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitBreakStatement(this);

        public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        {
            if (breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.BreakStatement(breakKeyword, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public BreakStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword) => Update(breakKeyword, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new BreakStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.BreakKeyword, semicolonToken);
    }

    /// <summary>Represents a return statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ReturnStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ReturnStatementSyntax : StatementSyntax
    {
        private SyntaxNode? expressions;

        internal ReturnStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'return' keyword.</summary>
        public SyntaxToken ReturnKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ReturnStatementSyntax)this.Green).returnKeyword, Position, 0);

        /// <summary>The expressions being returned.</summary>
        public SeparatedSyntaxList<ExpressionSyntax> Expressions
        {
            get
            {
                var red = GetRed(ref this.expressions, 1);
                return red != null ? new SeparatedSyntaxList<ExpressionSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ReturnStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(2), GetChildIndex(2)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.expressions, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.expressions : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitReturnStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitReturnStatement(this);

        public ReturnStatementSyntax Update(SyntaxToken returnKeyword, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken semicolonToken)
        {
            if (returnKeyword != this.ReturnKeyword || expressions != this.Expressions || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ReturnStatement(returnKeyword, expressions, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ReturnStatementSyntax WithReturnKeyword(SyntaxToken returnKeyword) => Update(returnKeyword, this.Expressions, this.SemicolonToken);
        public ReturnStatementSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions) => Update(this.ReturnKeyword, expressions, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new ReturnStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.ReturnKeyword, this.Expressions, semicolonToken);

        public ReturnStatementSyntax AddExpressions(params ExpressionSyntax[] items) => WithExpressions(this.Expressions.AddRange(items));
    }

    /// <summary>Represents a continue statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ContinueStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ContinueStatementSyntax : StatementSyntax
    {

        internal ContinueStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'continue' keyword.</summary>
        public SyntaxToken ContinueKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.ContinueStatementSyntax)this.Green).continueKeyword, Position, 0);

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ContinueStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitContinueStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitContinueStatement(this);

        public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        {
            if (continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ContinueStatement(continueKeyword, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ContinueStatementSyntax WithContinueKeyword(SyntaxToken continueKeyword) => Update(continueKeyword, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new ContinueStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.ContinueKeyword, semicolonToken);
    }

    /// <summary>Represents a local function declaration statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.LocalFunctionDeclarationStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LocalFunctionDeclarationStatementSyntax : StatementSyntax
    {
        private IdentifierNameSyntax? name;
        private TypeParameterListSyntax? typeParameterList;
        private ParameterListSyntax? parameters;
        private TypeBindingSyntax? typeBinding;
        private StatementListSyntax? body;

        internal LocalFunctionDeclarationStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'local' keyword.</summary>
        public SyntaxToken LocalKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.LocalFunctionDeclarationStatementSyntax)this.Green).localKeyword, Position, 0);

        /// <summary>The 'function' keyword.</summary>
        public SyntaxToken FunctionKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.LocalFunctionDeclarationStatementSyntax)this.Green).functionKeyword, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The function's name.</summary>
        public IdentifierNameSyntax Name => GetRed(ref this.name, 2)!;

        /// <summary>Gets the type parameter list for this function (if any).</summary>
        public TypeParameterListSyntax? TypeParameterList => GetRed(ref this.typeParameterList, 3);

        /// <summary>The parameter list.</summary>
        public ParameterListSyntax Parameters => GetRed(ref this.parameters, 4)!;

        /// <summary>The function's (optional) return type.</summary>
        public TypeBindingSyntax? TypeBinding => GetRed(ref this.typeBinding, 5);

        /// <summary>The function's body.</summary>
        public StatementListSyntax Body => GetRed(ref this.body, 6)!;

        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.LocalFunctionDeclarationStatementSyntax)this.Green).endKeyword, GetChildPosition(7), GetChildIndex(7));

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.LocalFunctionDeclarationStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(8), GetChildIndex(8)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                2 => GetRed(ref this.name, 2)!,
                3 => GetRed(ref this.typeParameterList, 3),
                4 => GetRed(ref this.parameters, 4)!,
                5 => GetRed(ref this.typeBinding, 5),
                6 => GetRed(ref this.body, 6)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                2 => this.name,
                3 => this.typeParameterList,
                4 => this.parameters,
                5 => this.typeBinding,
                6 => this.body,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLocalFunctionDeclarationStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLocalFunctionDeclarationStatement(this);

        public LocalFunctionDeclarationStatementSyntax Update(SyntaxToken localKeyword, SyntaxToken functionKeyword, IdentifierNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (localKeyword != this.LocalKeyword || functionKeyword != this.FunctionKeyword || name != this.Name || typeParameterList != this.TypeParameterList || parameters != this.Parameters || typeBinding != this.TypeBinding || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.LocalFunctionDeclarationStatement(localKeyword, functionKeyword, name, typeParameterList, parameters, typeBinding, body, endKeyword, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LocalFunctionDeclarationStatementSyntax WithLocalKeyword(SyntaxToken localKeyword) => Update(localKeyword, this.FunctionKeyword, this.Name, this.TypeParameterList, this.Parameters, this.TypeBinding, this.Body, this.EndKeyword, this.SemicolonToken);
        public LocalFunctionDeclarationStatementSyntax WithFunctionKeyword(SyntaxToken functionKeyword) => Update(this.LocalKeyword, functionKeyword, this.Name, this.TypeParameterList, this.Parameters, this.TypeBinding, this.Body, this.EndKeyword, this.SemicolonToken);
        public LocalFunctionDeclarationStatementSyntax WithName(IdentifierNameSyntax name) => Update(this.LocalKeyword, this.FunctionKeyword, name, this.TypeParameterList, this.Parameters, this.TypeBinding, this.Body, this.EndKeyword, this.SemicolonToken);
        public LocalFunctionDeclarationStatementSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) => Update(this.LocalKeyword, this.FunctionKeyword, this.Name, typeParameterList, this.Parameters, this.TypeBinding, this.Body, this.EndKeyword, this.SemicolonToken);
        public LocalFunctionDeclarationStatementSyntax WithParameters(ParameterListSyntax parameters) => Update(this.LocalKeyword, this.FunctionKeyword, this.Name, this.TypeParameterList, parameters, this.TypeBinding, this.Body, this.EndKeyword, this.SemicolonToken);
        public LocalFunctionDeclarationStatementSyntax WithTypeBinding(TypeBindingSyntax? typeBinding) => Update(this.LocalKeyword, this.FunctionKeyword, this.Name, this.TypeParameterList, this.Parameters, typeBinding, this.Body, this.EndKeyword, this.SemicolonToken);
        public LocalFunctionDeclarationStatementSyntax WithBody(StatementListSyntax body) => Update(this.LocalKeyword, this.FunctionKeyword, this.Name, this.TypeParameterList, this.Parameters, this.TypeBinding, body, this.EndKeyword, this.SemicolonToken);
        public LocalFunctionDeclarationStatementSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.LocalKeyword, this.FunctionKeyword, this.Name, this.TypeParameterList, this.Parameters, this.TypeBinding, this.Body, endKeyword, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new LocalFunctionDeclarationStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.LocalKeyword, this.FunctionKeyword, this.Name, this.TypeParameterList, this.Parameters, this.TypeBinding, this.Body, this.EndKeyword, semicolonToken);

        public LocalFunctionDeclarationStatementSyntax AddTypeParameterListNames(params TypeParameterSyntax[] items)
        {
            var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
            return WithTypeParameterList(typeParameterList.WithNames(typeParameterList.Names.AddRange(items)));
        }
        public LocalFunctionDeclarationStatementSyntax AddParametersParameters(params ParameterSyntax[] items) => WithParameters(this.Parameters.WithParameters(this.Parameters.Parameters.AddRange(items)));
        public LocalFunctionDeclarationStatementSyntax AddBodyStatements(params StatementSyntax[] items) => WithBody(this.Body.WithStatements(this.Body.Statements.AddRange(items)));
    }

    /// <summary>Represents a function declaration statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.FunctionDeclarationStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class FunctionDeclarationStatementSyntax : StatementSyntax
    {
        private FunctionNameSyntax? name;
        private TypeParameterListSyntax? typeParameterList;
        private ParameterListSyntax? parameters;
        private TypeBindingSyntax? typeBinding;
        private StatementListSyntax? body;

        internal FunctionDeclarationStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'function' keyword.</summary>
        public SyntaxToken FunctionKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.FunctionDeclarationStatementSyntax)this.Green).functionKeyword, Position, 0);

        /// <summary>The function's name.</summary>
        public FunctionNameSyntax Name => GetRed(ref this.name, 1)!;

        /// <summary>Gets the type parameter list for this function (if any).</summary>
        public TypeParameterListSyntax? TypeParameterList => GetRed(ref this.typeParameterList, 2);

        /// <summary>The function's parameters.</summary>
        public ParameterListSyntax Parameters => GetRed(ref this.parameters, 3)!;

        /// <summary>The function's (optional) return type.</summary>
        public TypeBindingSyntax? TypeBinding => GetRed(ref this.typeBinding, 4);

        /// <summary>The function's body.</summary>
        public StatementListSyntax Body => GetRed(ref this.body, 5)!;

        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.FunctionDeclarationStatementSyntax)this.Green).endKeyword, GetChildPosition(6), GetChildIndex(6));

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.FunctionDeclarationStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(7), GetChildIndex(7)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.name, 1)!,
                2 => GetRed(ref this.typeParameterList, 2),
                3 => GetRed(ref this.parameters, 3)!,
                4 => GetRed(ref this.typeBinding, 4),
                5 => GetRed(ref this.body, 5)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.name,
                2 => this.typeParameterList,
                3 => this.parameters,
                4 => this.typeBinding,
                5 => this.body,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitFunctionDeclarationStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitFunctionDeclarationStatement(this);

        public FunctionDeclarationStatementSyntax Update(SyntaxToken functionKeyword, FunctionNameSyntax name, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameters, TypeBindingSyntax? typeBinding, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (functionKeyword != this.FunctionKeyword || name != this.Name || typeParameterList != this.TypeParameterList || parameters != this.Parameters || typeBinding != this.TypeBinding || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.FunctionDeclarationStatement(functionKeyword, name, typeParameterList, parameters, typeBinding, body, endKeyword, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public FunctionDeclarationStatementSyntax WithFunctionKeyword(SyntaxToken functionKeyword) => Update(functionKeyword, this.Name, this.TypeParameterList, this.Parameters, this.TypeBinding, this.Body, this.EndKeyword, this.SemicolonToken);
        public FunctionDeclarationStatementSyntax WithName(FunctionNameSyntax name) => Update(this.FunctionKeyword, name, this.TypeParameterList, this.Parameters, this.TypeBinding, this.Body, this.EndKeyword, this.SemicolonToken);
        public FunctionDeclarationStatementSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) => Update(this.FunctionKeyword, this.Name, typeParameterList, this.Parameters, this.TypeBinding, this.Body, this.EndKeyword, this.SemicolonToken);
        public FunctionDeclarationStatementSyntax WithParameters(ParameterListSyntax parameters) => Update(this.FunctionKeyword, this.Name, this.TypeParameterList, parameters, this.TypeBinding, this.Body, this.EndKeyword, this.SemicolonToken);
        public FunctionDeclarationStatementSyntax WithTypeBinding(TypeBindingSyntax? typeBinding) => Update(this.FunctionKeyword, this.Name, this.TypeParameterList, this.Parameters, typeBinding, this.Body, this.EndKeyword, this.SemicolonToken);
        public FunctionDeclarationStatementSyntax WithBody(StatementListSyntax body) => Update(this.FunctionKeyword, this.Name, this.TypeParameterList, this.Parameters, this.TypeBinding, body, this.EndKeyword, this.SemicolonToken);
        public FunctionDeclarationStatementSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.FunctionKeyword, this.Name, this.TypeParameterList, this.Parameters, this.TypeBinding, this.Body, endKeyword, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new FunctionDeclarationStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.FunctionKeyword, this.Name, this.TypeParameterList, this.Parameters, this.TypeBinding, this.Body, this.EndKeyword, semicolonToken);

        public FunctionDeclarationStatementSyntax AddTypeParameterListNames(params TypeParameterSyntax[] items)
        {
            var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
            return WithTypeParameterList(typeParameterList.WithNames(typeParameterList.Names.AddRange(items)));
        }
        public FunctionDeclarationStatementSyntax AddParametersParameters(params ParameterSyntax[] items) => WithParameters(this.Parameters.WithParameters(this.Parameters.Parameters.AddRange(items)));
        public FunctionDeclarationStatementSyntax AddBodyStatements(params StatementSyntax[] items) => WithBody(this.Body.WithStatements(this.Body.Statements.AddRange(items)));
    }

    /// <summary>Represents a do statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.DoStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class DoStatementSyntax : StatementSyntax
    {
        private StatementListSyntax? body;

        internal DoStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'do' keyword.</summary>
        public SyntaxToken DoKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.DoStatementSyntax)this.Green).doKeyword, Position, 0);

        /// <summary>The do's body.</summary>
        public StatementListSyntax Body => GetRed(ref this.body, 1)!;

        /// <summary>The 'end' keyword.</summary>
        public SyntaxToken EndKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.DoStatementSyntax)this.Green).endKeyword, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.DoStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(3), GetChildIndex(3)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.body, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.body : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitDoStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitDoStatement(this);

        public DoStatementSyntax Update(SyntaxToken doKeyword, StatementListSyntax body, SyntaxToken endKeyword, SyntaxToken semicolonToken)
        {
            if (doKeyword != this.DoKeyword || body != this.Body || endKeyword != this.EndKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.DoStatement(doKeyword, body, endKeyword, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword) => Update(doKeyword, this.Body, this.EndKeyword, this.SemicolonToken);
        public DoStatementSyntax WithBody(StatementListSyntax body) => Update(this.DoKeyword, body, this.EndKeyword, this.SemicolonToken);
        public DoStatementSyntax WithEndKeyword(SyntaxToken endKeyword) => Update(this.DoKeyword, this.Body, endKeyword, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new DoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.DoKeyword, this.Body, this.EndKeyword, semicolonToken);

        public DoStatementSyntax AddBodyStatements(params StatementSyntax[] items) => WithBody(this.Body.WithStatements(this.Body.Statements.AddRange(items)));
    }

    /// <summary>Represents a goto label statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.GotoLabelStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class GotoLabelStatementSyntax : StatementSyntax
    {

        internal GotoLabelStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The delimiter on the left of the name.</summary>
        public SyntaxToken LeftDelimiterToken => new SyntaxToken(this, ((Syntax.InternalSyntax.GotoLabelStatementSyntax)this.Green).leftDelimiterToken, Position, 0);

        /// <summary>The label name.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.GotoLabelStatementSyntax)this.Green).identifier, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The delimiter on the right of the name.</summary>
        public SyntaxToken RightDelimiterToken => new SyntaxToken(this, ((Syntax.InternalSyntax.GotoLabelStatementSyntax)this.Green).rightDelimiterToken, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.GotoLabelStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(3), GetChildIndex(3)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitGotoLabelStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitGotoLabelStatement(this);

        public GotoLabelStatementSyntax Update(SyntaxToken leftDelimiterToken, SyntaxToken identifier, SyntaxToken rightDelimiterToken, SyntaxToken semicolonToken)
        {
            if (leftDelimiterToken != this.LeftDelimiterToken || identifier != this.Identifier || rightDelimiterToken != this.RightDelimiterToken || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.GotoLabelStatement(leftDelimiterToken, identifier, rightDelimiterToken, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public GotoLabelStatementSyntax WithLeftDelimiterToken(SyntaxToken leftDelimiterToken) => Update(leftDelimiterToken, this.Identifier, this.RightDelimiterToken, this.SemicolonToken);
        public GotoLabelStatementSyntax WithIdentifier(SyntaxToken identifier) => Update(this.LeftDelimiterToken, identifier, this.RightDelimiterToken, this.SemicolonToken);
        public GotoLabelStatementSyntax WithRightDelimiterToken(SyntaxToken rightDelimiterToken) => Update(this.LeftDelimiterToken, this.Identifier, rightDelimiterToken, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new GotoLabelStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.LeftDelimiterToken, this.Identifier, this.RightDelimiterToken, semicolonToken);
    }

    /// <summary>An expression as a statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ExpressionStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ExpressionStatementSyntax : StatementSyntax
    {
        private ExpressionSyntax? expression;

        internal ExpressionStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The function call expression.</summary>
        public ExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.ExpressionStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.expression)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.expression : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitExpressionStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitExpressionStatement(this);

        public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
            if (expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ExpressionStatement(expression, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ExpressionStatementSyntax WithExpression(ExpressionSyntax expression) => Update(expression, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new ExpressionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.Expression, semicolonToken);
    }

    /// <summary>An empty statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.EmptyStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class EmptyStatementSyntax : StatementSyntax
    {

        internal EmptyStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.EmptyStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, Position, 0) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitEmptyStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitEmptyStatement(this);

        public EmptyStatementSyntax Update(SyntaxToken semicolonToken)
        {
            if (semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.EmptyStatement(semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new EmptyStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(semicolonToken);
    }

    /// <summary>Represents a type declaration statement.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeDeclarationStatement"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeDeclarationStatementSyntax : StatementSyntax
    {
        private TypeParameterListSyntax? typeParameterList;
        private TypeSyntax? type;

        internal TypeDeclarationStatementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The 'export' keyword.</summary>
        public SyntaxToken ExportKeyword
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.TypeDeclarationStatementSyntax)this.Green).exportKeyword;
                return slot != null ? new SyntaxToken(this, slot, Position, 0) : default;
            }
        }

        /// <summary>The 'type' keyword.</summary>
        public SyntaxToken TypeKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeDeclarationStatementSyntax)this.Green).typeKeyword, GetChildPosition(1), GetChildIndex(1));

        /// <summary>Represents the type's name.</summary>
        public SyntaxToken Name => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeDeclarationStatementSyntax)this.Green).name, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The type parameter list for this generic type.</summary>
        public TypeParameterListSyntax? TypeParameterList => GetRed(ref this.typeParameterList, 3);

        /// <summary>The equals token of the type.</summary>
        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeDeclarationStatementSyntax)this.Green).equalsToken, GetChildPosition(4), GetChildIndex(4));

        /// <summary>Represents the declared type.</summary>
        public TypeSyntax Type => GetRed(ref this.type, 5)!;

        /// <summary>The semicolon at the end of the statement (if any).</summary>
        public override SyntaxToken SemicolonToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.TypeDeclarationStatementSyntax)this.Green).semicolonToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(6), GetChildIndex(6)) : default;
            }
        }

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                3 => GetRed(ref this.typeParameterList, 3),
                5 => GetRed(ref this.type, 5)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                3 => this.typeParameterList,
                5 => this.type,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeDeclarationStatement(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeDeclarationStatement(this);

        public TypeDeclarationStatementSyntax Update(SyntaxToken exportKeyword, SyntaxToken typeKeyword, SyntaxToken name, TypeParameterListSyntax? typeParameterList, SyntaxToken equalsToken, TypeSyntax type, SyntaxToken semicolonToken)
        {
            if (exportKeyword != this.ExportKeyword || typeKeyword != this.TypeKeyword || name != this.Name || typeParameterList != this.TypeParameterList || equalsToken != this.EqualsToken || type != this.Type || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.TypeDeclarationStatement(exportKeyword, typeKeyword, name, typeParameterList, equalsToken, type, semicolonToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeDeclarationStatementSyntax WithExportKeyword(SyntaxToken exportKeyword) => Update(exportKeyword, this.TypeKeyword, this.Name, this.TypeParameterList, this.EqualsToken, this.Type, this.SemicolonToken);
        public TypeDeclarationStatementSyntax WithTypeKeyword(SyntaxToken typeKeyword) => Update(this.ExportKeyword, typeKeyword, this.Name, this.TypeParameterList, this.EqualsToken, this.Type, this.SemicolonToken);
        public TypeDeclarationStatementSyntax WithName(SyntaxToken name) => Update(this.ExportKeyword, this.TypeKeyword, name, this.TypeParameterList, this.EqualsToken, this.Type, this.SemicolonToken);
        public TypeDeclarationStatementSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) => Update(this.ExportKeyword, this.TypeKeyword, this.Name, typeParameterList, this.EqualsToken, this.Type, this.SemicolonToken);
        public TypeDeclarationStatementSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(this.ExportKeyword, this.TypeKeyword, this.Name, this.TypeParameterList, equalsToken, this.Type, this.SemicolonToken);
        public TypeDeclarationStatementSyntax WithType(TypeSyntax type) => Update(this.ExportKeyword, this.TypeKeyword, this.Name, this.TypeParameterList, this.EqualsToken, type, this.SemicolonToken);
        internal override StatementSyntax WithSemicolonTokenCore(SyntaxToken semicolonToken) => WithSemicolonToken(semicolonToken);
        public new TypeDeclarationStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) => Update(this.ExportKeyword, this.TypeKeyword, this.Name, this.TypeParameterList, this.EqualsToken, this.Type, semicolonToken);

        public TypeDeclarationStatementSyntax AddTypeParameterListNames(params TypeParameterSyntax[] items)
        {
            var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
            return WithTypeParameterList(typeParameterList.WithNames(typeParameterList.Names.AddRange(items)));
        }
    }

    /// <summary>The base node for type annotations</summary>
    public abstract partial class TypeSyntax : LuaSyntaxNode
    {
        internal TypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>The node representing a type annotation</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeBinding"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeBindingSyntax : LuaSyntaxNode
    {
        private TypeSyntax? type;

        internal TypeBindingSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets the <c>:</c> token.
        /// </summary>
        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeBindingSyntax)this.Green).colonToken, Position, 0);

        /// <summary>Gets the type of the annotation.</summary>
        public TypeSyntax Type => GetRed(ref this.type, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.type, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.type : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeBinding(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeBinding(this);

        public TypeBindingSyntax Update(SyntaxToken colonToken, TypeSyntax type)
        {
            if (colonToken != this.ColonToken || type != this.Type)
            {
                var newNode = SyntaxFactory.TypeBinding(colonToken, type);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeBindingSyntax WithColonToken(SyntaxToken colonToken) => Update(colonToken, this.Type);
        public TypeBindingSyntax WithType(TypeSyntax type) => Update(this.ColonToken, type);
    }

    /// <summary>This node represents a type's name.</summary>
    public abstract partial class TypeNameSyntax : TypeSyntax
    {
        internal TypeNameSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The type argument list for this generic type.</summary>
        public abstract TypeArgumentListSyntax? TypeArgumentList { get; }
        public TypeNameSyntax WithTypeArgumentList(TypeArgumentListSyntax? typeArgumentList) => WithTypeArgumentListCore(typeArgumentList);
        internal abstract TypeNameSyntax WithTypeArgumentListCore(TypeArgumentListSyntax? typeArgumentList);

        public TypeNameSyntax AddTypeArgumentListArguments(params TypeSyntax[] items) => AddTypeArgumentListArgumentsCore(items);
        internal abstract TypeNameSyntax AddTypeArgumentListArgumentsCore(params TypeSyntax[] items);
    }

    /// <summary>This node reperesents a simple name (T).</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.SimpleTypeName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class SimpleTypeNameSyntax : TypeNameSyntax
    {
        private TypeArgumentListSyntax? typeArgumentList;

        internal SimpleTypeNameSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the name of the type.</summary>
        public SyntaxToken IdentifierToken => new SyntaxToken(this, ((Syntax.InternalSyntax.SimpleTypeNameSyntax)this.Green).identifierToken, Position, 0);

        /// <summary>The type argument list for this generic type.</summary>
        public override TypeArgumentListSyntax? TypeArgumentList => GetRed(ref this.typeArgumentList, 1);

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.typeArgumentList, 1) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.typeArgumentList : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitSimpleTypeName(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitSimpleTypeName(this);

        public SimpleTypeNameSyntax Update(SyntaxToken identifierToken, TypeArgumentListSyntax? typeArgumentList)
        {
            if (identifierToken != this.IdentifierToken || typeArgumentList != this.TypeArgumentList)
            {
                var newNode = SyntaxFactory.SimpleTypeName(identifierToken, typeArgumentList);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public SimpleTypeNameSyntax WithIdentifierToken(SyntaxToken identifierToken) => Update(identifierToken, this.TypeArgumentList);
        internal override TypeNameSyntax WithTypeArgumentListCore(TypeArgumentListSyntax? typeArgumentList) => WithTypeArgumentList(typeArgumentList);
        public new SimpleTypeNameSyntax WithTypeArgumentList(TypeArgumentListSyntax? typeArgumentList) => Update(this.IdentifierToken, typeArgumentList);

        internal override TypeNameSyntax AddTypeArgumentListArgumentsCore(params TypeSyntax[] items) => AddTypeArgumentListArguments(items);
        public new SimpleTypeNameSyntax AddTypeArgumentListArguments(params TypeSyntax[] items)
        {
            var typeArgumentList = this.TypeArgumentList ?? SyntaxFactory.TypeArgumentList();
            return WithTypeArgumentList(typeArgumentList.WithArguments(typeArgumentList.Arguments.AddRange(items)));
        }
    }

    /// <summary>This node represents a composite name (.T)</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.CompositeTypeName"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class CompositeTypeNameSyntax : TypeNameSyntax
    {
        private TypeNameSyntax? @base;
        private TypeArgumentListSyntax? typeArgumentList;

        internal CompositeTypeNameSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the name of the type.</summary>
        public TypeNameSyntax Base => GetRedAtZero(ref this.@base)!;

        /// <summary>
        /// Gets the . token.
        /// </summary>
        public SyntaxToken DotToken => new SyntaxToken(this, ((Syntax.InternalSyntax.CompositeTypeNameSyntax)this.Green).dotToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>Gets the name of the type.</summary>
        public SyntaxToken IdentifierToken => new SyntaxToken(this, ((Syntax.InternalSyntax.CompositeTypeNameSyntax)this.Green).identifierToken, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The type argument list for this generic type.</summary>
        public override TypeArgumentListSyntax? TypeArgumentList => GetRed(ref this.typeArgumentList, 3);

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.@base)!,
                3 => GetRed(ref this.typeArgumentList, 3),
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.@base,
                3 => this.typeArgumentList,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitCompositeTypeName(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitCompositeTypeName(this);

        public CompositeTypeNameSyntax Update(TypeNameSyntax @base, SyntaxToken dotToken, SyntaxToken identifierToken, TypeArgumentListSyntax? typeArgumentList)
        {
            if (@base != this.Base || dotToken != this.DotToken || identifierToken != this.IdentifierToken || typeArgumentList != this.TypeArgumentList)
            {
                var newNode = SyntaxFactory.CompositeTypeName(@base, dotToken, identifierToken, typeArgumentList);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public CompositeTypeNameSyntax WithBase(TypeNameSyntax @base) => Update(@base, this.DotToken, this.IdentifierToken, this.TypeArgumentList);
        public CompositeTypeNameSyntax WithDotToken(SyntaxToken dotToken) => Update(this.Base, dotToken, this.IdentifierToken, this.TypeArgumentList);
        public CompositeTypeNameSyntax WithIdentifierToken(SyntaxToken identifierToken) => Update(this.Base, this.DotToken, identifierToken, this.TypeArgumentList);
        internal override TypeNameSyntax WithTypeArgumentListCore(TypeArgumentListSyntax? typeArgumentList) => WithTypeArgumentList(typeArgumentList);
        public new CompositeTypeNameSyntax WithTypeArgumentList(TypeArgumentListSyntax? typeArgumentList) => Update(this.Base, this.DotToken, this.IdentifierToken, typeArgumentList);

        internal override TypeNameSyntax AddTypeArgumentListArgumentsCore(params TypeSyntax[] items) => AddTypeArgumentListArguments(items);
        public new CompositeTypeNameSyntax AddTypeArgumentListArguments(params TypeSyntax[] items)
        {
            var typeArgumentList = this.TypeArgumentList ?? SyntaxFactory.TypeArgumentList();
            return WithTypeArgumentList(typeArgumentList.WithArguments(typeArgumentList.Arguments.AddRange(items)));
        }
    }

    /// <summary>This node represents a nilable type.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.NilableType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class NilableTypeSyntax : TypeSyntax
    {
        private TypeSyntax? type;

        internal NilableTypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the base type that's being made nilable.</summary>
        public TypeSyntax Type => GetRedAtZero(ref this.type)!;

        /// <summary>
        /// Gets the <c>?</c> token.
        /// </summary>
        public SyntaxToken QuestionToken => new SyntaxToken(this, ((Syntax.InternalSyntax.NilableTypeSyntax)this.Green).questionToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.type)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.type : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitNilableType(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitNilableType(this);

        public NilableTypeSyntax Update(TypeSyntax type, SyntaxToken questionToken)
        {
            if (type != this.Type || questionToken != this.QuestionToken)
            {
                var newNode = SyntaxFactory.NilableType(type, questionToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public NilableTypeSyntax WithType(TypeSyntax type) => Update(type, this.QuestionToken);
        public NilableTypeSyntax WithQuestionToken(SyntaxToken questionToken) => Update(this.Type, questionToken);
    }

    /// <summary>This node represents a parenthesized type.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ParenthesizedType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ParenthesizedTypeSyntax : TypeSyntax
    {
        private TypeSyntax? type;

        internal ParenthesizedTypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets the <c>(</c> token.
        /// </summary>
        public SyntaxToken OpenParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedTypeSyntax)this.Green).openParenthesisToken, Position, 0);

        /// <summary>Gets the type contained within the parenthesis.</summary>
        public TypeSyntax Type => GetRed(ref this.type, 1)!;

        /// <summary>
        /// Gets the <c>)</c> token.
        /// </summary>
        public SyntaxToken CloseParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ParenthesizedTypeSyntax)this.Green).closeParenthesisToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.type, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.type : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitParenthesizedType(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitParenthesizedType(this);

        public ParenthesizedTypeSyntax Update(SyntaxToken openParenthesisToken, TypeSyntax type, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken != this.OpenParenthesisToken || type != this.Type || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.ParenthesizedType(openParenthesisToken, type, closeParenthesisToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ParenthesizedTypeSyntax WithOpenParenthesisToken(SyntaxToken openParenthesisToken) => Update(openParenthesisToken, this.Type, this.CloseParenthesisToken);
        public ParenthesizedTypeSyntax WithType(TypeSyntax type) => Update(this.OpenParenthesisToken, type, this.CloseParenthesisToken);
        public ParenthesizedTypeSyntax WithCloseParenthesisToken(SyntaxToken closeParenthesisToken) => Update(this.OpenParenthesisToken, this.Type, closeParenthesisToken);
    }

    /// <summary>This node represents a type pack.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypePack"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypePackSyntax : TypeSyntax
    {
        private SyntaxNode? types;

        internal TypePackSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets the <c>(</c> token.
        /// </summary>
        public SyntaxToken OpenParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypePackSyntax)this.Green).openParenthesisToken, Position, 0);

        /// <summary>Gets the list of the types of the pack's elements.</summary>
        public SeparatedSyntaxList<TypeSyntax> Types
        {
            get
            {
                var red = GetRed(ref this.types, 1);
                return red != null ? new SeparatedSyntaxList<TypeSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>
        /// Gets the <c>)</c> token.
        /// </summary>
        public SyntaxToken CloseParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypePackSyntax)this.Green).closeParenthesisToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.types, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.types : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypePack(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypePack(this);

        public TypePackSyntax Update(SyntaxToken openParenthesisToken, SeparatedSyntaxList<TypeSyntax> types, SyntaxToken closeParenthesisToken)
        {
            if (openParenthesisToken != this.OpenParenthesisToken || types != this.Types || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.TypePack(openParenthesisToken, types, closeParenthesisToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypePackSyntax WithOpenParenthesisToken(SyntaxToken openParenthesisToken) => Update(openParenthesisToken, this.Types, this.CloseParenthesisToken);
        public TypePackSyntax WithTypes(SeparatedSyntaxList<TypeSyntax> types) => Update(this.OpenParenthesisToken, types, this.CloseParenthesisToken);
        public TypePackSyntax WithCloseParenthesisToken(SyntaxToken closeParenthesisToken) => Update(this.OpenParenthesisToken, this.Types, closeParenthesisToken);

        public TypePackSyntax AddTypes(params TypeSyntax[] items) => WithTypes(this.Types.AddRange(items));
    }

    /// <summary>This node represents a function type.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.FunctionType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class FunctionTypeSyntax : TypeSyntax
    {
        private TypeParameterListSyntax? typeParameterList;
        private SyntaxNode? parameters;
        private TypeSyntax? returnType;

        internal FunctionTypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the type parameter list for this function (if any).</summary>
        public TypeParameterListSyntax? TypeParameterList => GetRedAtZero(ref this.typeParameterList);

        /// <summary>
        /// Gets the <c>(</c> token.
        /// </summary>
        public SyntaxToken OpenParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.FunctionTypeSyntax)this.Green).openParenthesisToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>Gets the list of the types of the function's parameters.</summary>
        public SeparatedSyntaxList<TypeSyntax> Parameters
        {
            get
            {
                var red = GetRed(ref this.parameters, 2);
                return red != null ? new SeparatedSyntaxList<TypeSyntax>(red, GetChildIndex(2)) : default;
            }
        }

        /// <summary>
        /// Gets the <c>)</c> token.
        /// </summary>
        public SyntaxToken CloseParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.FunctionTypeSyntax)this.Green).closeParenthesisToken, GetChildPosition(3), GetChildIndex(3));

        /// <summary>
        /// Gets the <c>-&gt;</c> token.
        /// </summary>
        public SyntaxToken MinusGreaterThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.FunctionTypeSyntax)this.Green).minusGreaterThanToken, GetChildPosition(4), GetChildIndex(4));

        /// <summary>The return type of the function type.</summary>
        public TypeSyntax ReturnType => GetRed(ref this.returnType, 5)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.typeParameterList),
                2 => GetRed(ref this.parameters, 2)!,
                5 => GetRed(ref this.returnType, 5)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.typeParameterList,
                2 => this.parameters,
                5 => this.returnType,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitFunctionType(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitFunctionType(this);

        public FunctionTypeSyntax Update(TypeParameterListSyntax? typeParameterList, SyntaxToken openParenthesisToken, SeparatedSyntaxList<TypeSyntax> parameters, SyntaxToken closeParenthesisToken, SyntaxToken minusGreaterThanToken, TypeSyntax returnType)
        {
            if (typeParameterList != this.TypeParameterList || openParenthesisToken != this.OpenParenthesisToken || parameters != this.Parameters || closeParenthesisToken != this.CloseParenthesisToken || minusGreaterThanToken != this.MinusGreaterThanToken || returnType != this.ReturnType)
            {
                var newNode = SyntaxFactory.FunctionType(typeParameterList, openParenthesisToken, parameters, closeParenthesisToken, minusGreaterThanToken, returnType);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public FunctionTypeSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) => Update(typeParameterList, this.OpenParenthesisToken, this.Parameters, this.CloseParenthesisToken, this.MinusGreaterThanToken, this.ReturnType);
        public FunctionTypeSyntax WithOpenParenthesisToken(SyntaxToken openParenthesisToken) => Update(this.TypeParameterList, openParenthesisToken, this.Parameters, this.CloseParenthesisToken, this.MinusGreaterThanToken, this.ReturnType);
        public FunctionTypeSyntax WithParameters(SeparatedSyntaxList<TypeSyntax> parameters) => Update(this.TypeParameterList, this.OpenParenthesisToken, parameters, this.CloseParenthesisToken, this.MinusGreaterThanToken, this.ReturnType);
        public FunctionTypeSyntax WithCloseParenthesisToken(SyntaxToken closeParenthesisToken) => Update(this.TypeParameterList, this.OpenParenthesisToken, this.Parameters, closeParenthesisToken, this.MinusGreaterThanToken, this.ReturnType);
        public FunctionTypeSyntax WithMinusGreaterThanToken(SyntaxToken minusGreaterThanToken) => Update(this.TypeParameterList, this.OpenParenthesisToken, this.Parameters, this.CloseParenthesisToken, minusGreaterThanToken, this.ReturnType);
        public FunctionTypeSyntax WithReturnType(TypeSyntax returnType) => Update(this.TypeParameterList, this.OpenParenthesisToken, this.Parameters, this.CloseParenthesisToken, this.MinusGreaterThanToken, returnType);

        public FunctionTypeSyntax AddTypeParameterListNames(params TypeParameterSyntax[] items)
        {
            var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
            return WithTypeParameterList(typeParameterList.WithNames(typeParameterList.Names.AddRange(items)));
        }
        public FunctionTypeSyntax AddParameters(params TypeSyntax[] items) => WithParameters(this.Parameters.AddRange(items));
    }

    /// <summary>This node represents a table based type.</summary>
    public abstract partial class TableBasedTypeSyntax : TypeSyntax
    {
        internal TableBasedTypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>This node represents an array type.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.ArrayType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class ArrayTypeSyntax : TableBasedTypeSyntax
    {
        private TypeSyntax? type;

        internal ArrayTypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets the <c>{</c> token.
        /// </summary>
        public SyntaxToken OpenBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ArrayTypeSyntax)this.Green).openBraceToken, Position, 0);

        /// <summary>Gets the array's type</summary>
        public TypeSyntax Type => GetRed(ref this.type, 1)!;

        /// <summary>
        /// Gets the <c>}</c> token.
        /// </summary>
        public SyntaxToken CloseBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.ArrayTypeSyntax)this.Green).closeBraceToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.type, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.type : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitArrayType(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitArrayType(this);

        public ArrayTypeSyntax Update(SyntaxToken openBraceToken, TypeSyntax type, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || type != this.Type || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.ArrayType(openBraceToken, type, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public ArrayTypeSyntax WithOpenBraceToken(SyntaxToken openBraceToken) => Update(openBraceToken, this.Type, this.CloseBraceToken);
        public ArrayTypeSyntax WithType(TypeSyntax type) => Update(this.OpenBraceToken, type, this.CloseBraceToken);
        public ArrayTypeSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.OpenBraceToken, this.Type, closeBraceToken);
    }

    /// <summary>This node represents a type inside of a table type.</summary>
    public abstract partial class TableTypeElementSyntax : LuaSyntaxNode
    {
        internal TableTypeElementSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }
    }

    /// <summary>This node represents a table type indexer.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TableTypeIndexer"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TableTypeIndexerSyntax : TableTypeElementSyntax
    {
        private TypeSyntax? indexType;
        private TypeSyntax? valueType;

        internal TableTypeIndexerSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The open bracket token.</summary>
        public SyntaxToken OpenBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TableTypeIndexerSyntax)this.Green).openBracketToken, Position, 0);

        /// <summary>The type's index</summary>
        public TypeSyntax IndexType => GetRed(ref this.indexType, 1)!;

        /// <summary>The close bracket token.</summary>
        public SyntaxToken CloseBracketToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TableTypeIndexerSyntax)this.Green).closeBracketToken, GetChildPosition(2), GetChildIndex(2));

        /// <summary>The colon token.</summary>
        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TableTypeIndexerSyntax)this.Green).colonToken, GetChildPosition(3), GetChildIndex(3));

        /// <summary>The type's value</summary>
        public TypeSyntax ValueType => GetRed(ref this.valueType, 4)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                1 => GetRed(ref this.indexType, 1)!,
                4 => GetRed(ref this.valueType, 4)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                1 => this.indexType,
                4 => this.valueType,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTableTypeIndexer(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTableTypeIndexer(this);

        public TableTypeIndexerSyntax Update(SyntaxToken openBracketToken, TypeSyntax indexType, SyntaxToken closeBracketToken, SyntaxToken colonToken, TypeSyntax valueType)
        {
            if (openBracketToken != this.OpenBracketToken || indexType != this.IndexType || closeBracketToken != this.CloseBracketToken || colonToken != this.ColonToken || valueType != this.ValueType)
            {
                var newNode = SyntaxFactory.TableTypeIndexer(openBracketToken, indexType, closeBracketToken, colonToken, valueType);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TableTypeIndexerSyntax WithOpenBracketToken(SyntaxToken openBracketToken) => Update(openBracketToken, this.IndexType, this.CloseBracketToken, this.ColonToken, this.ValueType);
        public TableTypeIndexerSyntax WithIndexType(TypeSyntax indexType) => Update(this.OpenBracketToken, indexType, this.CloseBracketToken, this.ColonToken, this.ValueType);
        public TableTypeIndexerSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) => Update(this.OpenBracketToken, this.IndexType, closeBracketToken, this.ColonToken, this.ValueType);
        public TableTypeIndexerSyntax WithColonToken(SyntaxToken colonToken) => Update(this.OpenBracketToken, this.IndexType, this.CloseBracketToken, colonToken, this.ValueType);
        public TableTypeIndexerSyntax WithValueType(TypeSyntax valueType) => Update(this.OpenBracketToken, this.IndexType, this.CloseBracketToken, this.ColonToken, valueType);
    }

    /// <summary>This node represents a table type property.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TableTypeProperty"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TableTypePropertySyntax : TableTypeElementSyntax
    {
        private TypeSyntax? valueType;

        internal TableTypePropertySyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The type's index</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.TableTypePropertySyntax)this.Green).identifier, Position, 0);

        /// <summary>The colon token.</summary>
        public SyntaxToken ColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TableTypePropertySyntax)this.Green).colonToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The type's value</summary>
        public TypeSyntax ValueType => GetRed(ref this.valueType, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.valueType, 2)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.valueType : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTableTypeProperty(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTableTypeProperty(this);

        public TableTypePropertySyntax Update(SyntaxToken identifier, SyntaxToken colonToken, TypeSyntax valueType)
        {
            if (identifier != this.Identifier || colonToken != this.ColonToken || valueType != this.ValueType)
            {
                var newNode = SyntaxFactory.TableTypeProperty(identifier, colonToken, valueType);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TableTypePropertySyntax WithIdentifier(SyntaxToken identifier) => Update(identifier, this.ColonToken, this.ValueType);
        public TableTypePropertySyntax WithColonToken(SyntaxToken colonToken) => Update(this.Identifier, colonToken, this.ValueType);
        public TableTypePropertySyntax WithValueType(TypeSyntax valueType) => Update(this.Identifier, this.ColonToken, valueType);
    }

    /// <summary>This node represents a table type.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TableType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TableTypeSyntax : TableBasedTypeSyntax
    {
        private SyntaxNode? elements;

        internal TableTypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets the <c>{</c> token.
        /// </summary>
        public SyntaxToken OpenBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TableTypeSyntax)this.Green).openBraceToken, Position, 0);

        /// <summary>Gets the list of table properties and/or a single indexer.</summary>
        public SeparatedSyntaxList<TableTypeElementSyntax> Elements
        {
            get
            {
                var red = GetRed(ref this.elements, 1);
                return red != null ? new SeparatedSyntaxList<TableTypeElementSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>
        /// Gets the <c>}</c> token.
        /// </summary>
        public SyntaxToken CloseBraceToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TableTypeSyntax)this.Green).closeBraceToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.elements, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.elements : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTableType(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTableType(this);

        public TableTypeSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<TableTypeElementSyntax> elements, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || elements != this.Elements || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.TableType(openBraceToken, elements, closeBraceToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TableTypeSyntax WithOpenBraceToken(SyntaxToken openBraceToken) => Update(openBraceToken, this.Elements, this.CloseBraceToken);
        public TableTypeSyntax WithElements(SeparatedSyntaxList<TableTypeElementSyntax> elements) => Update(this.OpenBraceToken, elements, this.CloseBraceToken);
        public TableTypeSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) => Update(this.OpenBraceToken, this.Elements, closeBraceToken);

        public TableTypeSyntax AddElements(params TableTypeElementSyntax[] items) => WithElements(this.Elements.AddRange(items));
    }

    /// <summary>This node represents a type cast expression.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeCastExpression"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeCastExpressionSyntax : ExpressionSyntax
    {
        private ExpressionSyntax? expression;
        private TypeSyntax? type;

        internal TypeCastExpressionSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the expression being cast to another type.</summary>
        public ExpressionSyntax Expression => GetRedAtZero(ref this.expression)!;

        /// <summary>
        /// Gets the <c>::</c> operator token.
        /// </summary>
        public SyntaxToken ColonColonToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeCastExpressionSyntax)this.Green).colonColonToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>Gets the type the expression is being cast to.</summary>
        public TypeSyntax Type => GetRed(ref this.type, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.expression)!,
                2 => GetRed(ref this.type, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.expression,
                2 => this.type,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeCastExpression(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeCastExpression(this);

        public TypeCastExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken colonColonToken, TypeSyntax type)
        {
            if (expression != this.Expression || colonColonToken != this.ColonColonToken || type != this.Type)
            {
                var newNode = SyntaxFactory.TypeCastExpression(expression, colonColonToken, type);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeCastExpressionSyntax WithExpression(ExpressionSyntax expression) => Update(expression, this.ColonColonToken, this.Type);
        public TypeCastExpressionSyntax WithColonColonToken(SyntaxToken colonColonToken) => Update(this.Expression, colonColonToken, this.Type);
        public TypeCastExpressionSyntax WithType(TypeSyntax type) => Update(this.Expression, this.ColonColonToken, type);
    }

    /// <summary>This node represents a union type.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.UnionType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class UnionTypeSyntax : TypeSyntax
    {
        private TypeSyntax? left;
        private TypeSyntax? right;

        internal UnionTypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the type on the left side of the operator.</summary>
        public TypeSyntax Left => GetRedAtZero(ref this.left)!;

        /// <summary>
        /// Gets the <c>|</c> operator token.
        /// </summary>
        public SyntaxToken PipeToken => new SyntaxToken(this, ((Syntax.InternalSyntax.UnionTypeSyntax)this.Green).pipeToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>Gets the type on the right side of the operator.</summary>
        public TypeSyntax Right => GetRed(ref this.right, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.left)!,
                2 => GetRed(ref this.right, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.left,
                2 => this.right,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitUnionType(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitUnionType(this);

        public UnionTypeSyntax Update(TypeSyntax left, SyntaxToken pipeToken, TypeSyntax right)
        {
            if (left != this.Left || pipeToken != this.PipeToken || right != this.Right)
            {
                var newNode = SyntaxFactory.UnionType(left, pipeToken, right);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public UnionTypeSyntax WithLeft(TypeSyntax left) => Update(left, this.PipeToken, this.Right);
        public UnionTypeSyntax WithPipeToken(SyntaxToken pipeToken) => Update(this.Left, pipeToken, this.Right);
        public UnionTypeSyntax WithRight(TypeSyntax right) => Update(this.Left, this.PipeToken, right);
    }

    /// <summary>This node represents an intersection type.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.IntersectionType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class IntersectionTypeSyntax : TypeSyntax
    {
        private TypeSyntax? left;
        private TypeSyntax? right;

        internal IntersectionTypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the type on the left side of the operator.</summary>
        public TypeSyntax Left => GetRedAtZero(ref this.left)!;

        /// <summary>
        /// Gets the <c>&amp;</c> operator token.
        /// </summary>
        public SyntaxToken AmpersandToken => new SyntaxToken(this, ((Syntax.InternalSyntax.IntersectionTypeSyntax)this.Green).ampersandToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>Gets the type on the right side of the operator.</summary>
        public TypeSyntax Right => GetRed(ref this.right, 2)!;

        internal override SyntaxNode? GetNodeSlot(int index)
            => index switch
            {
                0 => GetRedAtZero(ref this.left)!,
                2 => GetRed(ref this.right, 2)!,
                _ => null,
            };

        internal override SyntaxNode? GetCachedSlot(int index)
            => index switch
            {
                0 => this.left,
                2 => this.right,
                _ => null,
            };

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitIntersectionType(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitIntersectionType(this);

        public IntersectionTypeSyntax Update(TypeSyntax left, SyntaxToken ampersandToken, TypeSyntax right)
        {
            if (left != this.Left || ampersandToken != this.AmpersandToken || right != this.Right)
            {
                var newNode = SyntaxFactory.IntersectionType(left, ampersandToken, right);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public IntersectionTypeSyntax WithLeft(TypeSyntax left) => Update(left, this.AmpersandToken, this.Right);
        public IntersectionTypeSyntax WithAmpersandToken(SyntaxToken ampersandToken) => Update(this.Left, ampersandToken, this.Right);
        public IntersectionTypeSyntax WithRight(TypeSyntax right) => Update(this.Left, this.AmpersandToken, right);
    }

    /// <summary>This node represents the default type value of a type parameter.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.EqualsType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class EqualsTypeSyntax : LuaSyntaxNode
    {
        private TypeSyntax? type;

        internal EqualsTypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <c>=</c>
        public SyntaxToken EqualsToken => new SyntaxToken(this, ((Syntax.InternalSyntax.EqualsTypeSyntax)this.Green).equalsToken, Position, 0);

        /// <summary>Gets the type value.</summary>
        public TypeSyntax Type => GetRed(ref this.type, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.type, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.type : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitEqualsType(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitEqualsType(this);

        public EqualsTypeSyntax Update(SyntaxToken equalsToken, TypeSyntax type)
        {
            if (equalsToken != this.EqualsToken || type != this.Type)
            {
                var newNode = SyntaxFactory.EqualsType(equalsToken, type);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public EqualsTypeSyntax WithEqualsToken(SyntaxToken equalsToken) => Update(equalsToken, this.Type);
        public EqualsTypeSyntax WithType(TypeSyntax type) => Update(this.EqualsToken, type);
    }

    /// <summary>This node represents a type parameter.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeParameter"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeParameterSyntax : LuaSyntaxNode
    {
        private EqualsTypeSyntax? equalsType;

        internal TypeParameterSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>Gets the type parameter name identifier token.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeParameterSyntax)this.Green).identifier, Position, 0);

        /// <summary>
        /// Gets the <c>...</c> token (if this type parameter is a type pack).
        /// </summary>
        public SyntaxToken DotDotDotToken
        {
            get
            {
                var slot = ((Syntax.InternalSyntax.TypeParameterSyntax)this.Green).dotDotDotToken;
                return slot != null ? new SyntaxToken(this, slot, GetChildPosition(1), GetChildIndex(1)) : default;
            }
        }

        public EqualsTypeSyntax? EqualsType => GetRed(ref this.equalsType, 2);

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.equalsType, 2) : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.equalsType : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeParameter(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeParameter(this);

        public TypeParameterSyntax Update(SyntaxToken identifier, SyntaxToken dotDotDotToken, EqualsTypeSyntax? equalsType)
        {
            if (identifier != this.Identifier || dotDotDotToken != this.DotDotDotToken || equalsType != this.EqualsType)
            {
                var newNode = SyntaxFactory.TypeParameter(identifier, dotDotDotToken, equalsType);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeParameterSyntax WithIdentifier(SyntaxToken identifier) => Update(identifier, this.DotDotDotToken, this.EqualsType);
        public TypeParameterSyntax WithDotDotDotToken(SyntaxToken dotDotDotToken) => Update(this.Identifier, dotDotDotToken, this.EqualsType);
        public TypeParameterSyntax WithEqualsType(EqualsTypeSyntax? equalsType) => Update(this.Identifier, this.DotDotDotToken, equalsType);
    }

    /// <summary>This node represents a type parameter list.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeParameterList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeParameterListSyntax : LuaSyntaxNode
    {
        private SyntaxNode? names;

        internal TypeParameterListSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets the <c>&lt;</c> token.
        /// </summary>
        public SyntaxToken LessThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeParameterListSyntax)this.Green).lessThanToken, Position, 0);

        /// <summary>A list of types.</summary>
        public SeparatedSyntaxList<TypeParameterSyntax> Names
        {
            get
            {
                var red = GetRed(ref this.names, 1);
                return red != null ? new SeparatedSyntaxList<TypeParameterSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>
        /// Gets the <c>&gt;</c> token.
        /// </summary>
        public SyntaxToken GreaterThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeParameterListSyntax)this.Green).greaterThanToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.names, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.names : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeParameterList(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeParameterList(this);

        public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> names, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || names != this.Names || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.TypeParameterList(lessThanToken, names, greaterThanToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeParameterListSyntax WithLessThanToken(SyntaxToken lessThanToken) => Update(lessThanToken, this.Names, this.GreaterThanToken);
        public TypeParameterListSyntax WithNames(SeparatedSyntaxList<TypeParameterSyntax> names) => Update(this.LessThanToken, names, this.GreaterThanToken);
        public TypeParameterListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) => Update(this.LessThanToken, this.Names, greaterThanToken);

        public TypeParameterListSyntax AddNames(params TypeParameterSyntax[] items) => WithNames(this.Names.AddRange(items));
    }

    /// <summary>This node represents a type argument list.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeArgumentList"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeArgumentListSyntax : LuaSyntaxNode
    {
        private SyntaxNode? arguments;

        internal TypeArgumentListSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// Gets the <c>&lt;</c> token.
        /// </summary>
        public SyntaxToken LessThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeArgumentListSyntax)this.Green).lessThanToken, Position, 0);

        /// <summary>A list of types.</summary>
        public SeparatedSyntaxList<TypeSyntax> Arguments
        {
            get
            {
                var red = GetRed(ref this.arguments, 1);
                return red != null ? new SeparatedSyntaxList<TypeSyntax>(red, GetChildIndex(1)) : default;
            }
        }

        /// <summary>
        /// Gets the <c>&gt;</c> token.
        /// </summary>
        public SyntaxToken GreaterThanToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeArgumentListSyntax)this.Green).greaterThanToken, GetChildPosition(2), GetChildIndex(2));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.arguments, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.arguments : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeArgumentList(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeArgumentList(this);

        public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeArgumentListSyntax WithLessThanToken(SyntaxToken lessThanToken) => Update(lessThanToken, this.Arguments, this.GreaterThanToken);
        public TypeArgumentListSyntax WithArguments(SeparatedSyntaxList<TypeSyntax> arguments) => Update(this.LessThanToken, arguments, this.GreaterThanToken);
        public TypeArgumentListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) => Update(this.LessThanToken, this.Arguments, greaterThanToken);

        public TypeArgumentListSyntax AddArguments(params TypeSyntax[] items) => WithArguments(this.Arguments.AddRange(items));
    }

    /// <summary>Represents a literal-based singleton type.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.StringType"/></description></item>
    /// <item><description><see cref="SyntaxKind.TrueType"/></description></item>
    /// <item><description><see cref="SyntaxKind.FalseType"/></description></item>
    /// <item><description><see cref="SyntaxKind.NilType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class LiteralTypeSyntax : TypeSyntax
    {

        internal LiteralTypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The literal token.</summary>
        public SyntaxToken Token => new SyntaxToken(this, ((Syntax.InternalSyntax.LiteralTypeSyntax)this.Green).token, Position, 0);

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitLiteralType(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitLiteralType(this);

        public LiteralTypeSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralType(this.Kind(), token);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public LiteralTypeSyntax WithToken(SyntaxToken token) => Update(token);
    }

    /// <summary>This node represents a typeof type.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.TypeofType"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class TypeofTypeSyntax : TypeSyntax
    {
        private ExpressionSyntax? expression;

        internal TypeofTypeSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The typeof keyword.</summary>
        public SyntaxToken TypeofKeyword => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeofTypeSyntax)this.Green).typeofKeyword, Position, 0);

        /// <summary>The open parenthesis token.</summary>
        public SyntaxToken OpenParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeofTypeSyntax)this.Green).openParenthesisToken, GetChildPosition(1), GetChildIndex(1));

        /// <summary>The typeof call's expression</summary>
        public ExpressionSyntax Expression => GetRed(ref this.expression, 2)!;

        /// <summary>The close parenthesis token.</summary>
        public SyntaxToken CloseParenthesisToken => new SyntaxToken(this, ((Syntax.InternalSyntax.TypeofTypeSyntax)this.Green).closeParenthesisToken, GetChildPosition(3), GetChildIndex(3));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 2 ? GetRed(ref this.expression, 2)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 2 ? this.expression : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitTypeofType(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitTypeofType(this);

        public TypeofTypeSyntax Update(SyntaxToken typeofKeyword, SyntaxToken openParenthesisToken, ExpressionSyntax expression, SyntaxToken closeParenthesisToken)
        {
            if (typeofKeyword != this.TypeofKeyword || openParenthesisToken != this.OpenParenthesisToken || expression != this.Expression || closeParenthesisToken != this.CloseParenthesisToken)
            {
                var newNode = SyntaxFactory.TypeofType(typeofKeyword, openParenthesisToken, expression, closeParenthesisToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public TypeofTypeSyntax WithTypeofKeyword(SyntaxToken typeofKeyword) => Update(typeofKeyword, this.OpenParenthesisToken, this.Expression, this.CloseParenthesisToken);
        public TypeofTypeSyntax WithOpenParenthesisToken(SyntaxToken openParenthesisToken) => Update(this.TypeofKeyword, openParenthesisToken, this.Expression, this.CloseParenthesisToken);
        public TypeofTypeSyntax WithExpression(ExpressionSyntax expression) => Update(this.TypeofKeyword, this.OpenParenthesisToken, expression, this.CloseParenthesisToken);
        public TypeofTypeSyntax WithCloseParenthesisToken(SyntaxToken closeParenthesisToken) => Update(this.TypeofKeyword, this.OpenParenthesisToken, this.Expression, closeParenthesisToken);
    }

    /// <summary>This node represents a variadic type pack.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.VariadicTypePack"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class VariadicTypePackSyntax : TypeSyntax
    {
        private TypeSyntax? type;

        internal VariadicTypePackSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>
        /// The <c>...</c> token.
        /// </summary>
        public SyntaxToken DotDotDotToken => new SyntaxToken(this, ((Syntax.InternalSyntax.VariadicTypePackSyntax)this.Green).dotDotDotToken, Position, 0);

        /// <summary>Gets the type the expression is being cast to.</summary>
        public TypeSyntax Type => GetRed(ref this.type, 1)!;

        internal override SyntaxNode? GetNodeSlot(int index) => index == 1 ? GetRed(ref this.type, 1)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 1 ? this.type : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitVariadicTypePack(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitVariadicTypePack(this);

        public VariadicTypePackSyntax Update(SyntaxToken dotDotDotToken, TypeSyntax type)
        {
            if (dotDotDotToken != this.DotDotDotToken || type != this.Type)
            {
                var newNode = SyntaxFactory.VariadicTypePack(dotDotDotToken, type);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public VariadicTypePackSyntax WithDotDotDotToken(SyntaxToken dotDotDotToken) => Update(dotDotDotToken, this.Type);
        public VariadicTypePackSyntax WithType(TypeSyntax type) => Update(this.DotDotDotToken, type);
    }

    /// <summary>This node represents a generic type pack.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.GenericTypePack"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class GenericTypePackSyntax : TypeSyntax
    {

        internal GenericTypePackSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The identifier token.</summary>
        public SyntaxToken Identifier => new SyntaxToken(this, ((Syntax.InternalSyntax.GenericTypePackSyntax)this.Green).identifier, Position, 0);

        /// <summary>
        /// The <c>...</c> token.
        /// </summary>
        public SyntaxToken DotDotDotToken => new SyntaxToken(this, ((Syntax.InternalSyntax.GenericTypePackSyntax)this.Green).dotDotDotToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => null;

        internal override SyntaxNode? GetCachedSlot(int index) => null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitGenericTypePack(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitGenericTypePack(this);

        public GenericTypePackSyntax Update(SyntaxToken identifier, SyntaxToken dotDotDotToken)
        {
            if (identifier != this.Identifier || dotDotDotToken != this.DotDotDotToken)
            {
                var newNode = SyntaxFactory.GenericTypePack(identifier, dotDotDotToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public GenericTypePackSyntax WithIdentifier(SyntaxToken identifier) => Update(identifier, this.DotDotDotToken);
        public GenericTypePackSyntax WithDotDotDotToken(SyntaxToken dotDotDotToken) => Update(this.Identifier, dotDotDotToken);
    }

    /// <summary>The node containing all of the file's contents.</summary>
    /// <remarks>
    /// <para>This node is associated with the following syntax kinds:</para>
    /// <list type="bullet">
    /// <item><description><see cref="SyntaxKind.CompilationUnit"/></description></item>
    /// </list>
    /// </remarks>
    public sealed partial class CompilationUnitSyntax : LuaSyntaxNode
    {
        private StatementListSyntax? statements;

        internal CompilationUnitSyntax(InternalSyntax.LuaSyntaxNode green, SyntaxNode? parent, int position)
          : base(green, parent, position)
        {
        }

        /// <summary>The statements in the compilation unit.</summary>
        public StatementListSyntax Statements => GetRedAtZero(ref this.statements)!;

        /// <summary>The end-of-file token.</summary>
        public SyntaxToken EndOfFileToken => new SyntaxToken(this, ((Syntax.InternalSyntax.CompilationUnitSyntax)this.Green).endOfFileToken, GetChildPosition(1), GetChildIndex(1));

        internal override SyntaxNode? GetNodeSlot(int index) => index == 0 ? GetRedAtZero(ref this.statements)! : null;

        internal override SyntaxNode? GetCachedSlot(int index) => index == 0 ? this.statements : null;

        public override void Accept(LuaSyntaxVisitor visitor) => visitor.VisitCompilationUnit(this);
        public override TResult? Accept<TResult>(LuaSyntaxVisitor<TResult> visitor) where TResult : default => visitor.VisitCompilationUnit(this);

        public CompilationUnitSyntax Update(StatementListSyntax statements, SyntaxToken endOfFileToken)
        {
            if (statements != this.Statements || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.CompilationUnit(statements, endOfFileToken);
                var annotations = GetAnnotations();
                return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;
            }

            return this;
        }

        public CompilationUnitSyntax WithStatements(StatementListSyntax statements) => Update(statements, this.EndOfFileToken);
        public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken) => Update(this.Statements, endOfFileToken);

        public CompilationUnitSyntax AddStatementsStatements(params StatementSyntax[] items) => WithStatements(this.Statements.WithStatements(this.Statements.Statements.AddRange(items)));
    }
}
