// <auto-generated />

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using Tsu;

#nullable enable

namespace Loretta.CodeAnalysis.Lua
{
    public static partial class SyntaxFacts
    {
        internal static readonly int MinTokenLength = 1;
        internal static readonly int MaxTokenLength = 8;
        internal static readonly int MinNonKeywordTokenLength = 1;
        internal static readonly int MaxNonKeywordTokenLength = 3;
        internal static readonly int MinKeywordLength = 2;
        internal static readonly int MaxKeywordLength = 8;
        internal static readonly int MinUnaryOperatorLength = 1;
        internal static readonly int MaxUnaryOperatorLength = 3;
        internal static readonly int MinBinaryOperatorLength = 1;
        internal static readonly int MaxBinaryOperatorLength = 3;

        /// <summary>
        /// Returns the precedence for a given unary operator or 0 if not a unary operator.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns>
        /// A positive number indicating the binary operator precedence or 0 if the kind is not a binary operator.
        /// </returns>
        public static int GetUnaryOperatorPrecedence(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.TildeToken:
                case SyntaxKind.NotKeyword:
                case SyntaxKind.MinusToken:
                case SyntaxKind.HashToken:
                case SyntaxKind.BangToken:
                    return 12;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// Returns the expression kind for a given unary operator or None if not a unary operator.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns>
        /// A positive number indicating the binary operator precedence or 0 if the kind is not a binary operator.
        /// </returns>
        public static Option<SyntaxKind> GetUnaryExpression(SyntaxKind kind) =>
            kind switch
            {
                SyntaxKind.HashToken => Loretta.CodeAnalysis.Lua.SyntaxKind.LengthExpression,
                SyntaxKind.MinusToken => Loretta.CodeAnalysis.Lua.SyntaxKind.UnaryMinusExpression,
                SyntaxKind.BangToken => Loretta.CodeAnalysis.Lua.SyntaxKind.LogicalNotExpression,
                SyntaxKind.TildeToken => Loretta.CodeAnalysis.Lua.SyntaxKind.BitwiseNotExpression,
                SyntaxKind.NotKeyword => Loretta.CodeAnalysis.Lua.SyntaxKind.LogicalNotExpression,
                _ => default,
            };

        /// <summary>
        /// Returns the precedence for a given binary operator. Returns 0 if kind is not a binary operator.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns>
        /// A positive number indicating the binary operator precedence or 0 if the kind is not a binary operator.
        /// </returns>
        public static int GetBinaryOperatorPrecedence(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.HatToken:
                    return 14;

                case SyntaxKind.StarToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.SlashSlashToken:
                case SyntaxKind.PercentToken:
                    return 11;

                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                    return 10;

                case SyntaxKind.DotDotToken:
                    return 9;

                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                    return 7;

                case SyntaxKind.AmpersandToken:
                    return 6;

                case SyntaxKind.TildeToken:
                    return 5;

                case SyntaxKind.PipeToken:
                    return 4;

                case SyntaxKind.TildeEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.BangEqualsToken:
                    return 3;

                case SyntaxKind.AndKeyword:
                case SyntaxKind.AmpersandAmpersandToken:
                    return 2;

                case SyntaxKind.PipePipeToken:
                case SyntaxKind.OrKeyword:
                    return 1;

                default:
                    return 0;
            }
        }

        /// <summary>
        /// Returns the expression kind for a given unary operator or None if not a unary operator.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns>
        /// A positive number indicating the binary operator precedence or 0 if the kind is not a binary operator.
        /// </returns>
        public static Option<SyntaxKind> GetBinaryExpression(SyntaxKind kind) =>
            kind switch
            {
                SyntaxKind.PlusToken => Loretta.CodeAnalysis.Lua.SyntaxKind.AddExpression,
                SyntaxKind.MinusToken => Loretta.CodeAnalysis.Lua.SyntaxKind.SubtractExpression,
                SyntaxKind.StarToken => Loretta.CodeAnalysis.Lua.SyntaxKind.MultiplyExpression,
                SyntaxKind.SlashToken => Loretta.CodeAnalysis.Lua.SyntaxKind.DivideExpression,
                SyntaxKind.HatToken => Loretta.CodeAnalysis.Lua.SyntaxKind.ExponentiateExpression,
                SyntaxKind.PercentToken => Loretta.CodeAnalysis.Lua.SyntaxKind.ModuloExpression,
                SyntaxKind.DotDotToken => Loretta.CodeAnalysis.Lua.SyntaxKind.ConcatExpression,
                SyntaxKind.EqualsEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.EqualsExpression,
                SyntaxKind.TildeEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.NotEqualsExpression,
                SyntaxKind.BangEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.NotEqualsExpression,
                SyntaxKind.LessThanToken => Loretta.CodeAnalysis.Lua.SyntaxKind.LessThanExpression,
                SyntaxKind.LessThanEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.LessThanOrEqualExpression,
                SyntaxKind.LessThanLessThanToken => Loretta.CodeAnalysis.Lua.SyntaxKind.LeftShiftExpression,
                SyntaxKind.GreaterThanToken => Loretta.CodeAnalysis.Lua.SyntaxKind.GreaterThanExpression,
                SyntaxKind.GreaterThanEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.GreaterThanOrEqualExpression,
                SyntaxKind.GreaterThanGreaterThanToken => Loretta.CodeAnalysis.Lua.SyntaxKind.RightShiftExpression,
                SyntaxKind.AmpersandToken => Loretta.CodeAnalysis.Lua.SyntaxKind.BitwiseAndExpression,
                SyntaxKind.AmpersandAmpersandToken => Loretta.CodeAnalysis.Lua.SyntaxKind.LogicalAndExpression,
                SyntaxKind.PipeToken => Loretta.CodeAnalysis.Lua.SyntaxKind.BitwiseOrExpression,
                SyntaxKind.PipePipeToken => Loretta.CodeAnalysis.Lua.SyntaxKind.LogicalOrExpression,
                SyntaxKind.TildeToken => Loretta.CodeAnalysis.Lua.SyntaxKind.ExclusiveOrExpression,
                SyntaxKind.SlashSlashToken => Loretta.CodeAnalysis.Lua.SyntaxKind.FloorDivideExpression,
                SyntaxKind.AndKeyword => Loretta.CodeAnalysis.Lua.SyntaxKind.LogicalAndExpression,
                SyntaxKind.OrKeyword => Loretta.CodeAnalysis.Lua.SyntaxKind.LogicalOrExpression,
                _ => default,
            };

        /// <summary>
        /// Returns the <see cref="SyntaxKind"/> for a given keyword or <see cref="SyntaxKind.IdentifierName"/> if not a keyword.
        /// </summary>
        public static SyntaxKind GetKeywordKind(String text)
        {
            string? __candidate__1 = null;
            int __destination__1 = -1;
            var __skipCheck__1 = false;
            switch (text.Length)
            {
                case 2:
                    switch (text[1])
                    {
                        case 'o':
                            __candidate__1 = "do";
                            __destination__1 = 3;
                            break;
                        case 'f':
                            __candidate__1 = "if";
                            __destination__1 = 12;
                            break;
                        case 'n':
                            __candidate__1 = "in";
                            __destination__1 = 13;
                            break;
                        case 'r':
                            __candidate__1 = "or";
                            __destination__1 = 17;
                            break;
                    }
                    break;
                case 3:
                    switch (System.Runtime.InteropServices.MemoryMarshal.Read<int>(System.Runtime.InteropServices.MemoryMarshal.Cast<char, byte>(text.AsSpan(0, 2))))
                    {
                        case 0x006e0061:
                            __candidate__1 = "and";
                            __destination__1 = 0;
                            break;
                        case 0x006e0065:
                            __candidate__1 = "end";
                            __destination__1 = 6;
                            break;
                        case 0x006f0066:
                            __candidate__1 = "for";
                            __destination__1 = 9;
                            break;
                        case 0x0069006e:
                            __candidate__1 = "nil";
                            __destination__1 = 15;
                            break;
                        case 0x006f006e:
                            __candidate__1 = "not";
                            __destination__1 = 16;
                            break;
                    }
                    break;
                case 4:
                    switch (text[1])
                    {
                        case 'l':
                            __candidate__1 = "else";
                            __destination__1 = 5;
                            break;
                        case 'o':
                            __candidate__1 = "goto";
                            __destination__1 = 11;
                            break;
                        case 'h':
                            __candidate__1 = "then";
                            __destination__1 = 20;
                            break;
                        case 'r':
                            __candidate__1 = "true";
                            __destination__1 = 21;
                            break;
                        case 'y':
                            __candidate__1 = "type";
                            __destination__1 = 22;
                            break;
                    }
                    break;
                case 5:
                    switch (text[0])
                    {
                        case 'b':
                            __candidate__1 = "break";
                            __destination__1 = 1;
                            break;
                        case 'f':
                            __candidate__1 = "false";
                            __destination__1 = 8;
                            break;
                        case 'l':
                            __candidate__1 = "local";
                            __destination__1 = 14;
                            break;
                        case 'u':
                            __candidate__1 = "until";
                            __destination__1 = 24;
                            break;
                        case 'w':
                            __candidate__1 = "while";
                            __destination__1 = 25;
                            break;
                    }
                    break;
                case 6:
                    switch (System.Runtime.InteropServices.MemoryMarshal.Read<int>(System.Runtime.InteropServices.MemoryMarshal.Cast<char, byte>(text.AsSpan(1, 2))))
                    {
                        case 0x0073006c:
                            __candidate__1 = "elseif";
                            __destination__1 = 4;
                            break;
                        case 0x00700078:
                            __candidate__1 = "export";
                            __destination__1 = 7;
                            break;
                        case 0x00700065:
                            __candidate__1 = "repeat";
                            __destination__1 = 18;
                            break;
                        case 0x00740065:
                            __candidate__1 = "return";
                            __destination__1 = 19;
                            break;
                        case 0x00700079:
                            __candidate__1 = "typeof";
                            __destination__1 = 23;
                            break;
                    }
                    break;
                case 8:
                    switch (text[0])
                    {
                        case 'c':
                            __candidate__1 = "continue";
                            __destination__1 = 2;
                            break;
                        case 'f':
                            __candidate__1 = "function";
                            __destination__1 = 10;
                            break;
                    }
                    break;
            }
            if (__destination__1 != -1 && (__skipCheck__1 || string.Equals(text, __candidate__1, StringComparison.Ordinal)))
            {
                switch (__destination__1)
                {
                    case 0:
                    {
                        return SyntaxKind.AndKeyword;
                    }
                    case 1:
                    {
                        return SyntaxKind.BreakKeyword;
                    }
                    case 2:
                    {
                        return SyntaxKind.ContinueKeyword;
                    }
                    case 3:
                    {
                        return SyntaxKind.DoKeyword;
                    }
                    case 4:
                    {
                        return SyntaxKind.ElseIfKeyword;
                    }
                    case 5:
                    {
                        return SyntaxKind.ElseKeyword;
                    }
                    case 6:
                    {
                        return SyntaxKind.EndKeyword;
                    }
                    case 7:
                    {
                        return SyntaxKind.ExportKeyword;
                    }
                    case 8:
                    {
                        return SyntaxKind.FalseKeyword;
                    }
                    case 9:
                    {
                        return SyntaxKind.ForKeyword;
                    }
                    case 10:
                    {
                        return SyntaxKind.FunctionKeyword;
                    }
                    case 11:
                    {
                        return SyntaxKind.GotoKeyword;
                    }
                    case 12:
                    {
                        return SyntaxKind.IfKeyword;
                    }
                    case 13:
                    {
                        return SyntaxKind.InKeyword;
                    }
                    case 14:
                    {
                        return SyntaxKind.LocalKeyword;
                    }
                    case 15:
                    {
                        return SyntaxKind.NilKeyword;
                    }
                    case 16:
                    {
                        return SyntaxKind.NotKeyword;
                    }
                    case 17:
                    {
                        return SyntaxKind.OrKeyword;
                    }
                    case 18:
                    {
                        return SyntaxKind.RepeatKeyword;
                    }
                    case 19:
                    {
                        return SyntaxKind.ReturnKeyword;
                    }
                    case 20:
                    {
                        return SyntaxKind.ThenKeyword;
                    }
                    case 21:
                    {
                        return SyntaxKind.TrueKeyword;
                    }
                    case 22:
                    {
                        return SyntaxKind.TypeKeyword;
                    }
                    case 23:
                    {
                        return SyntaxKind.TypeofKeyword;
                    }
                    case 24:
                    {
                        return SyntaxKind.UntilKeyword;
                    }
                    case 25:
                    {
                        return SyntaxKind.WhileKeyword;
                    }
                    default:
                        throw new InvalidOperationException();
                }
            }
            else
            {
                return SyntaxKind.IdentifierToken;
            }
        }
        
        /// <summary>
        /// Returns the <see cref="SyntaxKind"/> for a given keyword or <see cref="SyntaxKind.IdentifierName"/> if not a keyword.
        /// </summary>
        public static SyntaxKind GetKeywordKind(ReadOnlySpan<char> span)
        {
            string? __candidate__1 = null;
            int __destination__1 = -1;
            var __skipCheck__1 = false;
            switch (span.Length)
            {
                case 2:
                    switch (span[1])
                    {
                        case 'o':
                            __candidate__1 = "do";
                            __destination__1 = 3;
                            break;
                        case 'f':
                            __candidate__1 = "if";
                            __destination__1 = 12;
                            break;
                        case 'n':
                            __candidate__1 = "in";
                            __destination__1 = 13;
                            break;
                        case 'r':
                            __candidate__1 = "or";
                            __destination__1 = 17;
                            break;
                    }
                    break;
                case 3:
                    switch (System.Runtime.InteropServices.MemoryMarshal.Read<int>(System.Runtime.InteropServices.MemoryMarshal.Cast<char, byte>(span.Slice(0, 2))))
                    {
                        case 0x006e0061:
                            __candidate__1 = "and";
                            __destination__1 = 0;
                            break;
                        case 0x006e0065:
                            __candidate__1 = "end";
                            __destination__1 = 6;
                            break;
                        case 0x006f0066:
                            __candidate__1 = "for";
                            __destination__1 = 9;
                            break;
                        case 0x0069006e:
                            __candidate__1 = "nil";
                            __destination__1 = 15;
                            break;
                        case 0x006f006e:
                            __candidate__1 = "not";
                            __destination__1 = 16;
                            break;
                    }
                    break;
                case 4:
                    switch (span[1])
                    {
                        case 'l':
                            __candidate__1 = "else";
                            __destination__1 = 5;
                            break;
                        case 'o':
                            __candidate__1 = "goto";
                            __destination__1 = 11;
                            break;
                        case 'h':
                            __candidate__1 = "then";
                            __destination__1 = 20;
                            break;
                        case 'r':
                            __candidate__1 = "true";
                            __destination__1 = 21;
                            break;
                        case 'y':
                            __candidate__1 = "type";
                            __destination__1 = 22;
                            break;
                    }
                    break;
                case 5:
                    switch (span[0])
                    {
                        case 'b':
                            __candidate__1 = "break";
                            __destination__1 = 1;
                            break;
                        case 'f':
                            __candidate__1 = "false";
                            __destination__1 = 8;
                            break;
                        case 'l':
                            __candidate__1 = "local";
                            __destination__1 = 14;
                            break;
                        case 'u':
                            __candidate__1 = "until";
                            __destination__1 = 24;
                            break;
                        case 'w':
                            __candidate__1 = "while";
                            __destination__1 = 25;
                            break;
                    }
                    break;
                case 6:
                    switch (System.Runtime.InteropServices.MemoryMarshal.Read<int>(System.Runtime.InteropServices.MemoryMarshal.Cast<char, byte>(span.Slice(1, 2))))
                    {
                        case 0x0073006c:
                            __candidate__1 = "elseif";
                            __destination__1 = 4;
                            break;
                        case 0x00700078:
                            __candidate__1 = "export";
                            __destination__1 = 7;
                            break;
                        case 0x00700065:
                            __candidate__1 = "repeat";
                            __destination__1 = 18;
                            break;
                        case 0x00740065:
                            __candidate__1 = "return";
                            __destination__1 = 19;
                            break;
                        case 0x00700079:
                            __candidate__1 = "typeof";
                            __destination__1 = 23;
                            break;
                    }
                    break;
                case 8:
                    switch (span[0])
                    {
                        case 'c':
                            __candidate__1 = "continue";
                            __destination__1 = 2;
                            break;
                        case 'f':
                            __candidate__1 = "function";
                            __destination__1 = 10;
                            break;
                    }
                    break;
            }
            if (__destination__1 != -1 && (__skipCheck__1 || System.MemoryExtensions.Equals(span, __candidate__1.AsSpan(), StringComparison.Ordinal)))
            {
                switch (__destination__1)
                {
                    case 0:
                    {
                        return SyntaxKind.AndKeyword;
                    }
                    case 1:
                    {
                        return SyntaxKind.BreakKeyword;
                    }
                    case 2:
                    {
                        return SyntaxKind.ContinueKeyword;
                    }
                    case 3:
                    {
                        return SyntaxKind.DoKeyword;
                    }
                    case 4:
                    {
                        return SyntaxKind.ElseIfKeyword;
                    }
                    case 5:
                    {
                        return SyntaxKind.ElseKeyword;
                    }
                    case 6:
                    {
                        return SyntaxKind.EndKeyword;
                    }
                    case 7:
                    {
                        return SyntaxKind.ExportKeyword;
                    }
                    case 8:
                    {
                        return SyntaxKind.FalseKeyword;
                    }
                    case 9:
                    {
                        return SyntaxKind.ForKeyword;
                    }
                    case 10:
                    {
                        return SyntaxKind.FunctionKeyword;
                    }
                    case 11:
                    {
                        return SyntaxKind.GotoKeyword;
                    }
                    case 12:
                    {
                        return SyntaxKind.IfKeyword;
                    }
                    case 13:
                    {
                        return SyntaxKind.InKeyword;
                    }
                    case 14:
                    {
                        return SyntaxKind.LocalKeyword;
                    }
                    case 15:
                    {
                        return SyntaxKind.NilKeyword;
                    }
                    case 16:
                    {
                        return SyntaxKind.NotKeyword;
                    }
                    case 17:
                    {
                        return SyntaxKind.OrKeyword;
                    }
                    case 18:
                    {
                        return SyntaxKind.RepeatKeyword;
                    }
                    case 19:
                    {
                        return SyntaxKind.ReturnKeyword;
                    }
                    case 20:
                    {
                        return SyntaxKind.ThenKeyword;
                    }
                    case 21:
                    {
                        return SyntaxKind.TrueKeyword;
                    }
                    case 22:
                    {
                        return SyntaxKind.TypeKeyword;
                    }
                    case 23:
                    {
                        return SyntaxKind.TypeofKeyword;
                    }
                    case 24:
                    {
                        return SyntaxKind.UntilKeyword;
                    }
                    case 25:
                    {
                        return SyntaxKind.WhileKeyword;
                    }
                    default:
                        throw new InvalidOperationException();
                }
            }
            else
            {
                return SyntaxKind.IdentifierToken;
            }
        }

        /// <summary>
        /// Returns all <see cref="SyntaxKind"/>s that can be considered unary operators.
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<SyntaxKind> GetUnaryOperatorKinds() => ImmutableArray.Create(new[]
        {
            SyntaxKind.BangToken,
            SyntaxKind.HashToken,
            SyntaxKind.MinusToken,
            SyntaxKind.NotKeyword,
            SyntaxKind.TildeToken,
        });

        /// <summary>
        /// Returns all <see cref="SyntaxKind"/>s that can be considered binary operators.
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<SyntaxKind> GetBinaryOperatorKinds() => ImmutableArray.Create(new[]
        {
            SyntaxKind.AmpersandAmpersandToken,
            SyntaxKind.AmpersandToken,
            SyntaxKind.AndKeyword,
            SyntaxKind.BangEqualsToken,
            SyntaxKind.DotDotToken,
            SyntaxKind.EqualsEqualsToken,
            SyntaxKind.GreaterThanEqualsToken,
            SyntaxKind.GreaterThanGreaterThanToken,
            SyntaxKind.GreaterThanToken,
            SyntaxKind.HatToken,
            SyntaxKind.LessThanEqualsToken,
            SyntaxKind.LessThanLessThanToken,
            SyntaxKind.LessThanToken,
            SyntaxKind.MinusToken,
            SyntaxKind.OrKeyword,
            SyntaxKind.PercentToken,
            SyntaxKind.PipePipeToken,
            SyntaxKind.PipeToken,
            SyntaxKind.PlusToken,
            SyntaxKind.SlashSlashToken,
            SyntaxKind.SlashToken,
            SyntaxKind.StarToken,
            SyntaxKind.TildeEqualsToken,
            SyntaxKind.TildeToken,
        });

        /// <summary>
        /// Gets the predefined text that corresponds to the provided syntax kind.
        /// </summary>
        /// <param name="kind">The kind to obtain the text for.</param>
        /// <returns>The text corresponding to the provided kind or <see cref="string.Empty" /> if none.</returns>
        public static string GetText (SyntaxKind kind) =>
            kind switch
            {
                #region Tokens

                SyntaxKind.AmpersandAmpersandToken => "&&",
                SyntaxKind.AmpersandToken => "&",
                SyntaxKind.BangEqualsToken => "!=",
                SyntaxKind.BangToken => "!",
                SyntaxKind.CloseBraceToken => "}",
                SyntaxKind.CloseBracketToken => "]",
                SyntaxKind.CloseParenthesisToken => ")",
                SyntaxKind.ColonColonToken => "::",
                SyntaxKind.ColonToken => ":",
                SyntaxKind.CommaToken => ",",
                SyntaxKind.DotDotDotToken => "...",
                SyntaxKind.DotDotEqualsToken => "..=",
                SyntaxKind.DotDotToken => "..",
                SyntaxKind.DotToken => ".",
                SyntaxKind.EqualsEqualsToken => "==",
                SyntaxKind.EqualsToken => "=",
                SyntaxKind.GreaterThanEqualsToken => ">=",
                SyntaxKind.GreaterThanGreaterThanToken => ">>",
                SyntaxKind.GreaterThanToken => ">",
                SyntaxKind.HashToken => "#",
                SyntaxKind.HatEqualsToken => "^=",
                SyntaxKind.HatToken => "^",
                SyntaxKind.LessThanEqualsToken => "<=",
                SyntaxKind.LessThanLessThanToken => "<<",
                SyntaxKind.LessThanToken => "<",
                SyntaxKind.MinusEqualsToken => "-=",
                SyntaxKind.MinusGreaterThanToken => "->",
                SyntaxKind.MinusToken => "-",
                SyntaxKind.OpenBraceToken => "{",
                SyntaxKind.OpenBracketToken => "[",
                SyntaxKind.OpenParenthesisToken => "(",
                SyntaxKind.PercentEqualsToken => "%=",
                SyntaxKind.PercentToken => "%",
                SyntaxKind.PipePipeToken => "||",
                SyntaxKind.PipeToken => "|",
                SyntaxKind.PlusEqualsToken => "+=",
                SyntaxKind.PlusToken => "+",
                SyntaxKind.QuestionToken => "?",
                SyntaxKind.SemicolonToken => ";",
                SyntaxKind.SlashEqualsToken => "/=",
                SyntaxKind.SlashSlashToken => "//",
                SyntaxKind.SlashToken => "/",
                SyntaxKind.StarEqualsToken => "*=",
                SyntaxKind.StarToken => "*",
                SyntaxKind.TildeEqualsToken => "~=",
                SyntaxKind.TildeToken => "~",

                #endregion Tokens
                #region Keywords

                SyntaxKind.AndKeyword => "and",
                SyntaxKind.BreakKeyword => "break",
                SyntaxKind.ContinueKeyword => "continue",
                SyntaxKind.DoKeyword => "do",
                SyntaxKind.ElseIfKeyword => "elseif",
                SyntaxKind.ElseKeyword => "else",
                SyntaxKind.EndKeyword => "end",
                SyntaxKind.ExportKeyword => "export",
                SyntaxKind.FalseKeyword => "false",
                SyntaxKind.ForKeyword => "for",
                SyntaxKind.FunctionKeyword => "function",
                SyntaxKind.GotoKeyword => "goto",
                SyntaxKind.IfKeyword => "if",
                SyntaxKind.InKeyword => "in",
                SyntaxKind.LocalKeyword => "local",
                SyntaxKind.NilKeyword => "nil",
                SyntaxKind.NotKeyword => "not",
                SyntaxKind.OrKeyword => "or",
                SyntaxKind.RepeatKeyword => "repeat",
                SyntaxKind.ReturnKeyword => "return",
                SyntaxKind.ThenKeyword => "then",
                SyntaxKind.TrueKeyword => "true",
                SyntaxKind.TypeKeyword => "type",
                SyntaxKind.TypeofKeyword => "typeof",
                SyntaxKind.UntilKeyword => "until",
                SyntaxKind.WhileKeyword => "while",

                #endregion Keywords
                _ => string.Empty,
            };

        public static partial Option<Loretta.CodeAnalysis.Lua.SyntaxKind> GetCompoundAssignmentOperator(SyntaxKind kind)
        {
            return kind switch
            {
                SyntaxKind.PlusEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.PlusToken,
                SyntaxKind.MinusEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.MinusToken,
                SyntaxKind.StarEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.StarToken,
                SyntaxKind.SlashEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.SlashToken,
                SyntaxKind.HatEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.HatToken,
                SyntaxKind.PercentEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.PercentToken,
                SyntaxKind.DotDotEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.DotDotToken,
                _ => default,
            };
        }

        public static partial Option<Loretta.CodeAnalysis.Lua.SyntaxKind> GetCompoundAssignmentStatement(SyntaxKind kind)
        {
            return kind switch
            {
                SyntaxKind.PlusEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.AddAssignmentStatement,
                SyntaxKind.MinusEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.SubtractAssignmentStatement,
                SyntaxKind.StarEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.MultiplyAssignmentStatement,
                SyntaxKind.SlashEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.DivideAssignmentStatement,
                SyntaxKind.HatEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.ExponentiateAssignmentStatement,
                SyntaxKind.PercentEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.ModuloAssignmentStatement,
                SyntaxKind.DotDotEqualsToken => Loretta.CodeAnalysis.Lua.SyntaxKind.ConcatAssignmentStatement,
                _ => default,
            };
        }

        public static partial Option<Loretta.CodeAnalysis.Lua.SyntaxKind> GetLiteralExpression(SyntaxKind kind)
        {
            return kind switch
            {
                SyntaxKind.NilKeyword => Loretta.CodeAnalysis.Lua.SyntaxKind.NilLiteralExpression,
                SyntaxKind.TrueKeyword => Loretta.CodeAnalysis.Lua.SyntaxKind.TrueLiteralExpression,
                SyntaxKind.FalseKeyword => Loretta.CodeAnalysis.Lua.SyntaxKind.FalseLiteralExpression,
                SyntaxKind.NumericLiteralToken => Loretta.CodeAnalysis.Lua.SyntaxKind.NumericalLiteralExpression,
                SyntaxKind.StringLiteralToken => Loretta.CodeAnalysis.Lua.SyntaxKind.StringLiteralExpression,
                SyntaxKind.HashStringLiteralToken => Loretta.CodeAnalysis.Lua.SyntaxKind.HashStringLiteralExpression,
                _ => default,
            };
        }

        public static partial Option<Loretta.CodeAnalysis.Lua.SyntaxKind> GetOperatorTokenKind(SyntaxKind kind)
        {
            return kind switch
            {
                SyntaxKind.UnaryMinusExpression or SyntaxKind.SubtractExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.MinusToken,
                SyntaxKind.LogicalNotExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.NotKeyword,
                SyntaxKind.LengthExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.HashToken,
                SyntaxKind.BitwiseNotExpression or SyntaxKind.ExclusiveOrExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.TildeToken,
                SyntaxKind.AddExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.PlusToken,
                SyntaxKind.MultiplyExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.StarToken,
                SyntaxKind.DivideExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.SlashToken,
                SyntaxKind.ModuloExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.PercentToken,
                SyntaxKind.ConcatExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.DotDotToken,
                SyntaxKind.EqualsExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.EqualsEqualsToken,
                SyntaxKind.NotEqualsExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.TildeEqualsToken,
                SyntaxKind.LessThanExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.LessThanToken,
                SyntaxKind.LessThanOrEqualExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.LessThanEqualsToken,
                SyntaxKind.GreaterThanExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.GreaterThanToken,
                SyntaxKind.GreaterThanOrEqualExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.GreaterThanEqualsToken,
                SyntaxKind.LogicalAndExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.AndKeyword,
                SyntaxKind.LogicalOrExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.OrKeyword,
                SyntaxKind.ExponentiateExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.HatToken,
                SyntaxKind.BitwiseOrExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.PipeToken,
                SyntaxKind.BitwiseAndExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.AmpersandToken,
                SyntaxKind.RightShiftExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.GreaterThanGreaterThanToken,
                SyntaxKind.LeftShiftExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.LessThanLessThanToken,
                SyntaxKind.TypeCastExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.ColonColonToken,
                SyntaxKind.FloorDivideExpression => Loretta.CodeAnalysis.Lua.SyntaxKind.SlashSlashToken,
                SyntaxKind.AssignmentStatement => Loretta.CodeAnalysis.Lua.SyntaxKind.EqualsToken,
                SyntaxKind.AddAssignmentStatement => Loretta.CodeAnalysis.Lua.SyntaxKind.PlusEqualsToken,
                SyntaxKind.SubtractAssignmentStatement => Loretta.CodeAnalysis.Lua.SyntaxKind.MinusEqualsToken,
                SyntaxKind.MultiplyAssignmentStatement => Loretta.CodeAnalysis.Lua.SyntaxKind.StarEqualsToken,
                SyntaxKind.DivideAssignmentStatement => Loretta.CodeAnalysis.Lua.SyntaxKind.SlashEqualsToken,
                SyntaxKind.ModuloAssignmentStatement => Loretta.CodeAnalysis.Lua.SyntaxKind.PercentEqualsToken,
                SyntaxKind.ConcatAssignmentStatement => Loretta.CodeAnalysis.Lua.SyntaxKind.DotDotEqualsToken,
                SyntaxKind.ExponentiateAssignmentStatement => Loretta.CodeAnalysis.Lua.SyntaxKind.HatEqualsToken,
                _ => default,
            };
        }

        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a trivia's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsTrivia(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.EndOfLineTrivia:
                case SyntaxKind.MultiLineCommentTrivia:
                case SyntaxKind.ShebangTrivia:
                case SyntaxKind.SingleLineCommentTrivia:
                case SyntaxKind.SkippedTokensTrivia:
                case SyntaxKind.WhitespaceTrivia:
                    return true;

                default:
                    return false;
            }
        }

        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a keyword's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsKeyword(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.AndKeyword:
                case SyntaxKind.BreakKeyword:
                case SyntaxKind.ContinueKeyword:
                case SyntaxKind.DoKeyword:
                case SyntaxKind.ElseIfKeyword:
                case SyntaxKind.ElseKeyword:
                case SyntaxKind.EndKeyword:
                case SyntaxKind.ExportKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.ForKeyword:
                case SyntaxKind.FunctionKeyword:
                case SyntaxKind.GotoKeyword:
                case SyntaxKind.IfKeyword:
                case SyntaxKind.InKeyword:
                case SyntaxKind.LocalKeyword:
                case SyntaxKind.NilKeyword:
                case SyntaxKind.NotKeyword:
                case SyntaxKind.OrKeyword:
                case SyntaxKind.RepeatKeyword:
                case SyntaxKind.ReturnKeyword:
                case SyntaxKind.ThenKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.TypeKeyword:
                case SyntaxKind.TypeofKeyword:
                case SyntaxKind.UntilKeyword:
                case SyntaxKind.WhileKeyword:
                    return true;

                default:
                    return false;
            }
        }

        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a token's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsToken(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.AmpersandAmpersandToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AndKeyword:
                case SyntaxKind.BadToken:
                case SyntaxKind.BangEqualsToken:
                case SyntaxKind.BangToken:
                case SyntaxKind.BreakKeyword:
                case SyntaxKind.CloseBraceToken:
                case SyntaxKind.CloseBracketToken:
                case SyntaxKind.CloseParenthesisToken:
                case SyntaxKind.ColonColonToken:
                case SyntaxKind.ColonToken:
                case SyntaxKind.CommaToken:
                case SyntaxKind.ContinueKeyword:
                case SyntaxKind.DoKeyword:
                case SyntaxKind.DotDotDotToken:
                case SyntaxKind.DotDotEqualsToken:
                case SyntaxKind.DotDotToken:
                case SyntaxKind.DotToken:
                case SyntaxKind.ElseIfKeyword:
                case SyntaxKind.ElseKeyword:
                case SyntaxKind.EndKeyword:
                case SyntaxKind.EndOfFileToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.EqualsToken:
                case SyntaxKind.ExportKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.ForKeyword:
                case SyntaxKind.FunctionKeyword:
                case SyntaxKind.GotoKeyword:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.HashStringLiteralToken:
                case SyntaxKind.HashToken:
                case SyntaxKind.HatEqualsToken:
                case SyntaxKind.HatToken:
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.IfKeyword:
                case SyntaxKind.InKeyword:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LocalKeyword:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.MinusGreaterThanToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.NilKeyword:
                case SyntaxKind.NotKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.OpenBraceToken:
                case SyntaxKind.OpenBracketToken:
                case SyntaxKind.OpenParenthesisToken:
                case SyntaxKind.OrKeyword:
                case SyntaxKind.PercentEqualsToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.PipePipeToken:
                case SyntaxKind.PipeToken:
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.PlusToken:
                case SyntaxKind.QuestionToken:
                case SyntaxKind.RepeatKeyword:
                case SyntaxKind.ReturnKeyword:
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.SlashSlashToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.StarEqualsToken:
                case SyntaxKind.StarToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.ThenKeyword:
                case SyntaxKind.TildeEqualsToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.TypeKeyword:
                case SyntaxKind.TypeofKeyword:
                case SyntaxKind.UntilKeyword:
                case SyntaxKind.WhileKeyword:
                    return true;

                default:
                    return false;
            }
        }
        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a operatortoken's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsOperatorToken(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.AmpersandAmpersandToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AndKeyword:
                case SyntaxKind.BangEqualsToken:
                case SyntaxKind.BangToken:
                case SyntaxKind.DotDotToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.HashToken:
                case SyntaxKind.HatToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.NotKeyword:
                case SyntaxKind.OrKeyword:
                case SyntaxKind.PercentToken:
                case SyntaxKind.PipePipeToken:
                case SyntaxKind.PipeToken:
                case SyntaxKind.PlusToken:
                case SyntaxKind.SlashSlashToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.StarToken:
                case SyntaxKind.TildeEqualsToken:
                case SyntaxKind.TildeToken:
                    return true;

                default:
                    return false;
            }
        }
        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a unaryoperatortoken's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsUnaryOperatorToken(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.BangToken:
                case SyntaxKind.HashToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.NotKeyword:
                case SyntaxKind.TildeToken:
                    return true;

                default:
                    return false;
            }
        }
        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a binaryoperatortoken's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsBinaryOperatorToken(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.AmpersandAmpersandToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AndKeyword:
                case SyntaxKind.BangEqualsToken:
                case SyntaxKind.DotDotToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.HatToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.OrKeyword:
                case SyntaxKind.PercentToken:
                case SyntaxKind.PipePipeToken:
                case SyntaxKind.PipeToken:
                case SyntaxKind.PlusToken:
                case SyntaxKind.SlashSlashToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.StarToken:
                case SyntaxKind.TildeEqualsToken:
                case SyntaxKind.TildeToken:
                    return true;

                default:
                    return false;
            }
        }


        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a compoundassignmentoperatortoken's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsCompoundAssignmentOperatorToken(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.DotDotEqualsToken:
                case SyntaxKind.HatEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.PercentEqualsToken:
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.StarEqualsToken:
                    return true;

                default:
                    return false;
            }
        }

        /// <summary>
        /// Returns all <see cref="SyntaxKind"/>s that are in the CompoundAssignmentOperatorToken category.
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<SyntaxKind> GetCompoundAssignmentOperatorTokenKinds() => ImmutableArray.Create(new[]
        {
            SyntaxKind.PlusEqualsToken,
            SyntaxKind.MinusEqualsToken,
            SyntaxKind.StarEqualsToken,
            SyntaxKind.SlashEqualsToken,
            SyntaxKind.HatEqualsToken,
            SyntaxKind.PercentEqualsToken,
            SyntaxKind.DotDotEqualsToken,
        });

        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a literaltoken's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsLiteralToken(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.HashStringLiteralToken:
                case SyntaxKind.NilKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.TrueKeyword:
                    return true;

                default:
                    return false;
            }
        }

        /// <summary>
        /// Returns all <see cref="SyntaxKind"/>s that are in the LiteralToken category.
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<SyntaxKind> GetLiteralTokenKinds() => ImmutableArray.Create(new[]
        {
            SyntaxKind.NilKeyword,
            SyntaxKind.TrueKeyword,
            SyntaxKind.FalseKeyword,
            SyntaxKind.NumericLiteralToken,
            SyntaxKind.StringLiteralToken,
            SyntaxKind.HashStringLiteralToken,
        });

        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a functionexpressionordeclaration's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsFunctionExpressionOrDeclaration(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.AnonymousFunctionExpression:
                case SyntaxKind.FunctionDeclarationStatement:
                case SyntaxKind.LocalFunctionDeclarationStatement:
                    return true;

                default:
                    return false;
            }
        }

        /// <summary>
        /// Returns all <see cref="SyntaxKind"/>s that are in the FunctionExpressionOrDeclaration category.
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<SyntaxKind> GetFunctionExpressionOrDeclarationKinds() => ImmutableArray.Create(new[]
        {
            SyntaxKind.AnonymousFunctionExpression,
            SyntaxKind.LocalFunctionDeclarationStatement,
            SyntaxKind.FunctionDeclarationStatement,
        });

        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a variableexpression's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsVariableExpression(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.ElementAccessExpression:
                case SyntaxKind.IdentifierName:
                case SyntaxKind.MemberAccessExpression:
                    return true;

                default:
                    return false;
            }
        }

        /// <summary>
        /// Returns all <see cref="SyntaxKind"/>s that are in the VariableExpression category.
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<SyntaxKind> GetVariableExpressionKinds() => ImmutableArray.Create(new[]
        {
            SyntaxKind.IdentifierName,
            SyntaxKind.MemberAccessExpression,
            SyntaxKind.ElementAccessExpression,
        });

        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a unaryexpression's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsUnaryExpression(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.LengthExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.UnaryMinusExpression:
                    return true;

                default:
                    return false;
            }
        }

        /// <summary>
        /// Returns all <see cref="SyntaxKind"/>s that are in the UnaryExpression category.
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<SyntaxKind> GetUnaryExpressionKinds() => ImmutableArray.Create(new[]
        {
            SyntaxKind.UnaryMinusExpression,
            SyntaxKind.LogicalNotExpression,
            SyntaxKind.LengthExpression,
            SyntaxKind.BitwiseNotExpression,
        });

        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a binaryexpression's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsBinaryExpression(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.AddExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.ConcatExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.ExclusiveOrExpression:
                case SyntaxKind.ExponentiateExpression:
                case SyntaxKind.FloorDivideExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.LogicalAndExpression:
                case SyntaxKind.LogicalOrExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.NotEqualsExpression:
                case SyntaxKind.RightShiftExpression:
                case SyntaxKind.SubtractExpression:
                case SyntaxKind.TypeCastExpression:
                    return true;

                default:
                    return false;
            }
        }

        /// <summary>
        /// Returns all <see cref="SyntaxKind"/>s that are in the BinaryExpression category.
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<SyntaxKind> GetBinaryExpressionKinds() => ImmutableArray.Create(new[]
        {
            SyntaxKind.AddExpression,
            SyntaxKind.SubtractExpression,
            SyntaxKind.MultiplyExpression,
            SyntaxKind.DivideExpression,
            SyntaxKind.ModuloExpression,
            SyntaxKind.ConcatExpression,
            SyntaxKind.EqualsExpression,
            SyntaxKind.NotEqualsExpression,
            SyntaxKind.LessThanExpression,
            SyntaxKind.LessThanOrEqualExpression,
            SyntaxKind.GreaterThanExpression,
            SyntaxKind.GreaterThanOrEqualExpression,
            SyntaxKind.LogicalAndExpression,
            SyntaxKind.LogicalOrExpression,
            SyntaxKind.ExponentiateExpression,
            SyntaxKind.BitwiseOrExpression,
            SyntaxKind.BitwiseAndExpression,
            SyntaxKind.RightShiftExpression,
            SyntaxKind.LeftShiftExpression,
            SyntaxKind.ExclusiveOrExpression,
            SyntaxKind.TypeCastExpression,
            SyntaxKind.FloorDivideExpression,
        });

        /// <summary>
        /// Checks whether the provided <see cref="SyntaxKind"/> is a compoundassignmentstatement's.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool IsCompoundAssignmentStatement(SyntaxKind kind)
        {
            switch(kind)
            {
                case SyntaxKind.AddAssignmentStatement:
                case SyntaxKind.ConcatAssignmentStatement:
                case SyntaxKind.DivideAssignmentStatement:
                case SyntaxKind.ExponentiateAssignmentStatement:
                case SyntaxKind.ModuloAssignmentStatement:
                case SyntaxKind.MultiplyAssignmentStatement:
                case SyntaxKind.SubtractAssignmentStatement:
                    return true;

                default:
                    return false;
            }
        }

        /// <summary>
        /// Returns all <see cref="SyntaxKind"/>s that are in the CompoundAssignmentStatement category.
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<SyntaxKind> GetCompoundAssignmentStatementKinds() => ImmutableArray.Create(new[]
        {
            SyntaxKind.AddAssignmentStatement,
            SyntaxKind.SubtractAssignmentStatement,
            SyntaxKind.MultiplyAssignmentStatement,
            SyntaxKind.DivideAssignmentStatement,
            SyntaxKind.ModuloAssignmentStatement,
            SyntaxKind.ConcatAssignmentStatement,
            SyntaxKind.ExponentiateAssignmentStatement,
        });
    }
}
